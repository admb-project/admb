Index: df1b2-separable/adrndeff.h
===================================================================
--- df1b2-separable/adrndeff.h	(revision 682)
+++ df1b2-separable/adrndeff.h	(working copy)
@@ -187,9 +187,11 @@
   nested_calls_shape nested_shape;
   int separable_call_level;
   int dd_nr_flag;
+  int no_re_ders_flag;
   dmatrix * antiepsilon;
   i3_array * triplet_information;
   imatrix * compressed_triplet_information;
+  imatrix * compressed_triplet_information_for_sparse_qp;
   imatrix * calling_set;
   dvector *  importance_sampling_values; 
   dvector *  importance_sampling_weights; 
@@ -287,7 +289,7 @@
   dmatrix get_gradient_for_hessian_calcs(const dmatrix& local_Hess,
     double & f);
   fmm fmc1;
-  //fmmt1 fmc1;
+  fmmt1 fmc2;
   fmm fmc;
   dvector scale;
   dvector curv;
@@ -391,6 +393,7 @@
   void begin_separable_call_stuff(void);
   void end_separable_call_stuff(void);
   void build_up_nested_shape(void);
+  int sparse_cutoff;
 };
 
 /**
Index: df1b2-separable/df1b2bet.cpp
===================================================================
--- df1b2-separable/df1b2bet.cpp	(revision 682)
+++ df1b2-separable/df1b2bet.cpp	(working copy)
@@ -9,11 +9,13 @@
 #define EPS double(1.0e-9)
 #define FPMIN double(1.0e-30)
 df1b2variable betacf(const df1b2variable& a,const df1b2variable& b,
-  double x, int MAXIT);
+  double x, int MAXIT=100);
 
 
 //df1b2variable betai(const df1b2variable& a,const df1b2variable& b,
  // double x, int maxit=100);
+df3_two_variable betacf(df3_two_variable& a, df3_two_variable& b, 
+  double x,int MAXIT=100);
 
 /** Incomplete beta function for df1b2variable objects.
     \param a \f$a\f$
@@ -41,6 +43,52 @@
     return 1.0-bt*betacf(b,a,1.0-x,maxit)/b;
 }
 
+
+  df3_two_variable betacf(df3_two_variable& a, df3_two_variable& b, 
+    double x,int MAXIT)
+  {
+    int m,m2;
+    df3_two_variable aa,c,d,del,h,qab,qam,qap;
+     
+    qab=a+b;
+    qap=a+1.0;
+    qam=a-1.0;
+    c=1.0;
+    d=1.0-qab*x/qap;
+    if (fabs(value(d)) < FPMIN) d=FPMIN;
+    d=1.0/d;
+    h=d;
+    for (m=1;m<=MAXIT;m++) 
+    {
+      m2=2*m;
+      aa=m*(b-m)*x/((qam+m2)*(a+m2));
+      d=1.0+aa*d;
+      if (fabs(value(d)) < FPMIN) d=FPMIN;
+      c=1.0+aa/c;
+      if (fabs(value(c)) < FPMIN) c=FPMIN;
+      d=1.0/d;
+      h *= d*c;
+      aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
+      d=1.0+aa*d;
+      if (fabs(value(d)) < FPMIN) d=FPMIN;
+      c=1.0+aa/c;
+      if (fabs(value(c)) < FPMIN) c=FPMIN;
+      d=1.0/d;
+  
+      del=d*c;
+      h *= del;
+      if (fabs(value(del)-1.0) < EPS) break;
+    }
+    if (m > MAXIT) 
+    {
+      cerr << "a or b too big, or MAXIT too small in betacf"
+         << endl;
+      ad_exit(1);
+    }
+    return h;
+  }
+  
+
 /** Incomplete beta function for df1b2variable objects.
     Evaluates the continued fraction for imcomplete beta function.
     \param _a \f$a\f$
@@ -53,43 +101,19 @@
     "Numerical Recipes in C", 2nd edition,
     Press, Teukolsky, Vetterling, Flannery, chapter 2
 */
-df1b2variable betacf(const df1b2variable& a,const df1b2variable& b,
-  double x, int MAXIT)
+df1b2variable betacf(const df1b2variable& _xa,const df1b2variable& _xb, 
+    double x,int MAXIT)
 {
-  int m,m2;
-  df1b2variable aa,c,d,del,h,qab,qam,qap;
+  ADUNCONST(df1b2variable,xa)
+  ADUNCONST(df1b2variable,xb) 
+  init_df3_two_variable a(xa);
+  init_df3_two_variable b(xb);
+  df3_two_variable z=betacf(a,b,x,MAXIT);
+  df1b2variable tmp;
+  tmp=z;
+  return tmp;
+}
 
-  qab=a+b;
-  qap=a+double(1.0);
-  qam=a-double(1.0);
-  c=double(1.0);
-  d=double(1.0)-qab*x/qap;
-  if (fabs(value(d)) < FPMIN) d=FPMIN;
-  d=double(1.0)/d;
-  h=d;
-  for (m=1;m<=MAXIT;m++) {
-    m2=2*m;
-    aa=double(m)*(b-double(m))*x/((qam+double(m2))*(a+double(m2)));
-    d=double(1.0)+aa*d;
-    if (fabs(value(d)) < FPMIN) d=FPMIN;
-    c=double(1.0)+aa/c;
-    if (fabs(value(c)) < FPMIN) c=FPMIN;
-    d=double(1.0)/d;
-    h *= d*c;
-    aa = -(a+double(m))*(qab+double(m))*x/((a+double(m2))*(qap+double(m2)));
-    d=double(1.0)+aa*d;
-    if (fabs(value(d)) < FPMIN) d=FPMIN;
-    c=double(1.0)+aa/c;
-    if (fabs(value(c)) < FPMIN) c=FPMIN;
-    d=double(1.0)/d;
-    del=d*c;
-    h *= del;
-    if (fabs(value(del)-double(1.0)) < EPS) break;
-  }
-  if (m > MAXIT) cerr << "a or b too big, or MAXIT too small in betacf"
-         << endl;
-  return h;
-}
 #undef MAXIT
 #undef EPS
 #undef FPMIN
Index: df1b2-separable/df1b2compressed.cpp
===================================================================
--- df1b2-separable/df1b2compressed.cpp	(revision 0)
+++ df1b2-separable/df1b2compressed.cpp	(working copy)
@@ -0,0 +1,56 @@
+#include <admodel.h>
+#include <df1b2fun.h>
+df1b2_compressed_triplet::df1b2_compressed_triplet(int mmin,int mmax,int _n,int _m)
+{
+  allocate(mmin,mmax,_n,_m);
+}
+
+void df1b2_compressed_triplet::initialize(void)
+{
+  x.initialize();
+}
+
+df1b2_compressed_triplet::df1b2_compressed_triplet(void)
+{
+  n=0;
+  m=-1;
+}
+
+void df1b2_compressed_triplet::allocate(int mmin,int mmax,int _n,int _m)
+{
+  n=_n;
+  m=_m;
+  coords.allocate(1,2,mmin,mmax);
+  x.allocate(mmin,mmax);
+}
+
+  // this is for a symmetrixc matrix
+  df1b2vector operator * (const df1b2_compressed_triplet& _M,const dvector& _v)
+  {
+    ADUNCONST(df1b2_compressed_triplet,M)
+    ADUNCONST(dvector,v)
+    
+    if (v.indexmin()!=1 ||
+         M.get_m() !=v.indexmax() )
+    {
+      cerr << "Indices do not match in "
+        " operator * (const dcompressed_triplet& _M,const dvector& _v)"
+        << endl;
+      ad_exit(1);
+    }
+    imatrix& coords= M.get_coords();
+    df1b2vector& x= M.get_x();
+    df1b2vector tmp(1,v.indexmax());
+    int mmin=x.indexmin();
+    int mmax=x.indexmax();
+    tmp.initialize();
+    for (int i=mmin;i<=mmax;i++)
+    {
+      tmp(coords(1,i))+=x(i)*v(coords(2,i));
+      if(coords(1,i)!=coords(2,i))
+        tmp(coords(2,i))+=x(i)*v(coords(1,i));
+    }
+     
+    return tmp;
+  } 
+    
Index: df1b2-separable/df1b2f20.cpp
===================================================================
--- df1b2-separable/df1b2f20.cpp	(revision 682)
+++ df1b2-separable/df1b2f20.cpp	(working copy)
@@ -9,89 +9,133 @@
  * Description not yet available.
  */
 #include <df1b2fun.h>
+#include "df3fun.h"
 
+df3_one_variable lgam(const df3_one_variable& _x);
+
 /**
- * Description not yet available.
- * \param
- */
-df1b2variable gammlnguts(const df1b2variable _zz)
+ * Log Gamma Function
+ *
+ * Used to find the Natural log of the gamma function.
+ *
+ * \param _x the argument
+ *
+ */  
+df1b2variable lgam(const df1b2variable& _v1)
 {
-  ADUNCONST(df1b2variable,zz)
-  df1b2variable u;
-  double  z = value(_zz);
-  double zdot=1.0;
-  double z2dot=0.0;
-  double z3dot=0.0;
-  const double lpi =1.1447298858494001741434272;
-  const double pi =3.1415926535897932384626432;
-  const double lpp =0.9189385332046727417803297;
-  int n=7;
-  const double c[9]={0.99999999999980993, 
-    676.5203681218851, 
-    -1259.1392167224028,
-     771.32342877765313, 
-    -176.61502916214059, 
-    12.507343278686905,
-     -0.13857109526572012, 
-    9.9843695780195716e-6, 
-    1.5056327351493116e-7};
-  z-=1.0;
-  double x=c[0];
-  double xdot=0.0;
-  double x2dot=0.0;
-  double x3dot=0.0;
-  int i;
-  for (i=1;i<=n+1;i++)
+  df1b2variable tmp;
+  tmp = 0.0;
+  const double phi = 0.5772156649015328606065121;
+  const double zeta = 1.2020569031595942853997382;
+  init_df3_one_variable v1(_v1);
+
+  if (value(v1)==1.0)
   {
-    double zinv=1.0/(z+i);
-    x+=c[i]*zinv;
-    //xdot-=c[i]/square(z+i)*zdot;  since zdot=1.0
-    xdot-=c[i]*square(zinv);
-    x2dot+=2.0*c[i]*cube(zinv);
-    x3dot-=6.0*c[i]*fourth(zinv);
-  }    
-  double t=z+n+0.5;
-  double tdot=zdot;
-  //return lpp + (z+0.5)*log(t) -t + log(x);
-  double ans= lpp + (z+0.5)*log(t) -t + log(x);
-  //double dfx=zdot*log(t) + (z+0.5)/t*tdot -tdot +xdot/x;
-  // since tdot=1.0
-  // since zdot=1.0
-  double dfx=log(t) + (z+0.5)/t -1.0 +xdot/x;
-  double d2f=2.0/t -(z+0.5)/square(t)+x2dot/x
-    -square(xdot)/square(x);
-  double d3f=-3.0/square(t) + 2.0*(z+0.5)/cube(t)+ x3dot/x
-    -3.0*x2dot*xdot/square(x)+2.0*cube(xdot)/cube(x);
+    // value of lgam(1.0) is 0
+    // 1st derivative is -phi
+    // 2nd deriv is PI*PI/6
+    // 3rd deriv is -2*zeta
+    df3_one_variable v;
+    v = 0.0;
+    *v.get_udot() = -phi; 
+    *v.get_udot2() = PI*PI/6;
+    *v.get_udot3() = -2*zeta;
+    tmp=v;
 
-  double * xd=zz.get_u_dot();
-  double * zd=u.get_u_dot();
-  *u.get_u()=ans;
-  for (i=0;i<df1b2variable::nvar;i++)
+  }
+  else if (value(v1)==2.0)
   {
-    *zd++ =dfx * *xd++;
+    // value of lgam(2.0) is 0 and
+    // 1st derivative is 1-phi
+    // 2nd deriv is PI*PI/6 - 1
+    // 3rd deriv is 2*(1-zeta)
+    df3_one_variable v;
+    v = 0.0;
+    *v.get_udot() = 1 - phi; 
+    *v.get_udot2() = PI*PI/6 - 1;
+    *v.get_udot3() = -2*(1-zeta);
+    tmp=v;
   }
+  else
+  {
+     tmp=lgam(v1);
+  }
+  return(tmp);
+}
 
-  if (!df1b2_gradlist::no_derivatives)
-    f1b2gradlist->write_pass1(&zz,&u,dfx,d2f,d3f);
-  return(u);
+/**
+ * Log Gamma Function
+ *
+ * Used to find the Natural log of the gamma function.
+ *
+ *
+ * \n\n Modified from lgamma.cpp (http://www.crbond.com/download/lgamma.cpp),
+ *      an algorithm that was translated by C. Bond
+ *      from "Computation of Special Functions", Zhang and Jin, John Wiley and Sons, 1996.
+ */ 
+df3_one_variable lgam(const df3_one_variable& _x)
+{
+   df3_one_variable&  x = (df3_one_variable&)_x;
+   df3_one_variable x0;
+   df3_one_variable x2;
+   df3_one_variable xp;
+   df3_one_variable gl;
+   df3_one_variable gl0;
+   x0 = 0.0;
+   x2 = 0.0;
+   xp = 0.0;
+   gl = 0.0;
+   gl0 = 0.0;
+   int n = 0;
+   int k = 0;
+   static double a[] = {
+       8.333333333333333e-02,
+      -2.777777777777778e-03,
+       7.936507936507937e-04,
+      -5.952380952380952e-04,
+       8.417508417508418e-04,
+      -1.917526917526918e-03,
+       6.410256410256410e-03,
+      -2.955065359477124e-02,
+       1.796443723688307e-01,
+      -1.39243221690590};
+
+    x0 = x;
+    if (value(x) <= 0.0)
+    {
+       df3_one_variable ret;
+       ret = 1e308;
+       return ret;
+    }
+    else if (value(x) <= 7.0)
+    {
+        n = (int)(7-value(x));
+        x0 = x+n;
+    }
+    x2 = 1.0/(x0*x0);
+    xp = 2.0*PI;
+    gl0 = a[9];
+    for (k=8;k>=0;k--)
+    {
+        gl0 = gl0*x2 + a[k];
+    }
+    gl = gl0/x0+0.5*log(xp)+(x0-0.5)*log(x0)-x0;
+    if (value(x) <= 7.0)
+    {
+        for (k=1;k<=n;k++)
+        {
+            gl -= log(x0-1.0);
+            x0 -= 1.0;
+        }
+    }
+    return gl;
 }
 
-/**
- * Description not yet available.
- * \param
- */
+
+
 df1b2variable gammln(const df1b2variable& z)
 {
-  const double lpi =1.1447298858494001741434272;
-  const double pi =3.1415926535897932384626432;
-  if (value(z)<0.5)
-  {
-    return lpi - log(sin(pi*z)) - gammlnguts(1.0-z);
-  }
-  else
-  {
-    return gammlnguts(z);
-  }
+   return lgam(z);
 }
 
 /**
Index: df1b2-separable/df1b2fun.h
===================================================================
--- df1b2-separable/df1b2fun.h	(revision 682)
+++ df1b2-separable/df1b2fun.h	(working copy)
@@ -1137,6 +1137,7 @@
 df1b2matrix mfexp(const df1b2matrix& M);
 df1b2matrix log(const df1b2matrix& M);
 df1b2matrix trans(const df1b2matrix& M);
+df1b2matrix inv(const df1b2matrix& M);
 df1b2matrix choleski_decomp(const df1b2matrix& M);
 df1b2matrix choleski_decomp_extra(const df1b2matrix& M);
 df1b2matrix exp(const df1b2matrix& M);
@@ -1734,16 +1735,11 @@
 int allocated(const df1b2_init_matrix&);
 #include <df3fun.h>
 
-/*
 df1b2variable betai(const df1b2variable & _a, const df1b2variable & _b,
-		     const df1b2variable & _x);
+		     const df1b2variable & _x,int MAXIT=100);
 df1b2variable betai(const df1b2variable & _a, const df1b2variable & _b,
-		     double _x);
-*/
+		     double _x,int MAXIT=100);
 
-df1b2variable betai(const df1b2variable& a, const df1b2variable& b,
-  double x, int maxit=100);
-
 double do_gauss_hermite_block_diagonal(const dvector& x,
   const dvector& u0,const dmatrix& Hess,const dvector& _xadjoint,
   const dvector& _uadjoint,const dmatrix& _Hessadjoint,
@@ -1807,41 +1803,63 @@
  */
 class quadratic_prior : public style_flag_class
 {
+public:
+  dcompressed_triplet * SCM;
+  double d;
+  ivector * indx;
+  double sgn;
+  double lndet;
+  dmatrix * CM;
+  dmatrix * LU;
+  dmatrix * pM;
   dmatrix * pMinv;
+  dcompressed_triplet * SCMinv;
   dvar_matrix * dfpMinv;
+  dvar_compressed_triplet * S_dfpMinv;
+  dvar_compressed_triplet * DFSCM;
   dvar_vector * pu;
   int xmyindex;
-public:
   static int qflag; 
   static quadratic_prior * ptr[]; // this should be a resizeable array
   static void get_M_calculations(void);
   static void cleanup_pMinv();
   static void cleanup_dfpMinv();
   static int num_quadratic_prior;
+  static int calc_matrix_flag;
+  static int matrix_mult_flag;
+  static int sparse_flag;
   static const int max_num_quadratic_prior;
   void add_to_list(void);
 public:
   static int in_qp_calculations; 
+  static void cleanup(void);
   int get_offset(int xs);
   int get_myindex(void) { return xmyindex;}
   static quadratic_prior * get_ptr(int i){ return ptr[i];} 
   void operator = (const dvar_matrix &);
+  void operator = (const dcompressed_triplet &);
+  void operator = (const dvar_compressed_triplet &);
   void operator = (const dmatrix &);
   static int get_in_qp_calculations() { return in_qp_calculations; }
   static int get_num_quadratic_prior(void) { return num_quadratic_prior;}
   static dvariable get_quadratic_priors(void);
   dvariable get_function(void);
   quadratic_prior(void); 
-  ~quadratic_prior(void);
+  void deallocate(void);
+  virtual ~quadratic_prior(void);
   void allocate(const dvar_vector & _u,const char * s);
   void allocate(const dvar_vector & _u);
   void allocate(const dvar_matrix & _M, const dvar_vector & _u,const char * s);
   void allocate(const dvar_matrix & _M, const dvar_vector & _u);
   //dmatrix get_cHessian(void);
   void get_cHessian(dmatrix,int);
+  void get_cHessian(dcompressed_triplet *,int,ivector& sparse_iterator,int & sparse_count);
   void get_cHessian(dvar_matrix,int);
   void get_cHessian_from_vHessian(dmatrix ,int);
   void get_vHessian(dvar_matrix ,int);
+  //void get_vHessian(const dvar_compressed_triplet&  ,int );
+  void get_vHessian(const dvar_compressed_triplet& _H,
+    int xsize,ivector& sparse_iterator,int& sparse_count);
   void get_cgradient(dvector,int); 
   dvar_matrix get_Hessian(void);
   dvar_vector get_gradient(void); 
@@ -1849,22 +1867,35 @@
   static dvar_matrix get_Hessian_contribution(void);
   static void get_cgradient_contribution(dvector,int);
   static void get_cHessian_contribution(dmatrix,int);
+  static void get_cHessian_contribution(dcompressed_triplet *,int,ivector&,
+    int& );
   static void get_vHessian_contribution(dvar_matrix  ,int );
+  static void get_vHessian_contribution(const dvar_compressed_triplet&  ,int );
   static void get_cHessian_contribution_from_vHessian(dmatrix,int);
   friend class df1b2quadratic_prior;
   virtual void get_cM(void)=0;
+  static void get_cHessian_contribution_from_vHessian(dcompressed_triplet * dct,
+    int xsize,ivector& sparse_iterator,int & sparse_count);
+  void get_cHessian_from_vHessian(dcompressed_triplet*, int, ivector&, int&);
+
 };
 
 /**
  * Description not yet available.
  * \param
  */
+class df1b2_compressed_triplet;
+
 class df1b2quadratic_prior : public style_flag_class
 {
+public:
   ivector * index;
   df1b2matrix * M;
+  df1b2matrix * dfpMinv;
   dmatrix * CM;
-public:
+  df1b2_compressed_triplet * DFSCM;
+  df1b2_compressed_triplet * S_dfpMinv;
+  dcompressed_triplet * SCM;
   dmatrix * Lxu;
   df1b2_init_vector * pu;
   int xmyindex;
@@ -1874,16 +1905,20 @@
   void add_to_list(void);
 public:
   static df1b2quadratic_prior * get_ptr(int i){ return ptr[i];} 
+  static void cleanup(void);
   int num_active_parameters;
   int get_num_active_parameters(void) { return num_active_parameters; } 
   int get_myindex(void) { return xmyindex;}
   void operator = (const df1b2matrix &);
   void operator = (const dmatrix &);
+  void operator = (const dcompressed_triplet &);
+  void operator = (const df1b2_compressed_triplet &);
   static int get_num_quadratic_prior(void) { return num_quadratic_prior;}
   static dvariable get_quadratic_priors(void);
   df1b2variable get_function(void);
   df1b2quadratic_prior(void); 
-  ~df1b2quadratic_prior(void);
+  virtual void deallocate(void);
+  virtual ~df1b2quadratic_prior(void);
   void allocate(const df1b2_init_vector & _u,const char * s);
   void allocate(const df1b2_init_vector & _u);
   void allocate(const df1b2matrix & _M, const df1b2_init_vector & _u,const char * s);
@@ -1902,8 +1937,10 @@
   virtual void get_Lxu(dmatrix&)=0;
   friend class quadratic_prior;
   friend class df1b2_parameters;
+  virtual void get_cM(void)=0;
 };
 
+
 /**
  * Description not yet available.
  * \param
@@ -1950,6 +1987,7 @@
   virtual void set_old_style_flag(void);
 public:
   void operator = (const df1b2matrix & M);
+  void operator = (const df1b2_compressed_triplet & M);
   void operator = (const dmatrix & M);
   df1b2quadratic_re_penalty(void);
 };
@@ -2065,5 +2103,102 @@
   void ADMB_getcallindex(const df1b2variable& x);
   void ADMB_getcallindex(const df1b2vector& x);
   void ADMB_getcallindex(const df1b2matrix& x);
+
+class sparse_quadratic_prior : public style_flag_class
+{
+public:
+  dcompressed_triplet * SCM;
+  dmatrix * CM;
+  dmatrix * pM;
+  dmatrix * pMinv;
+  dvar_matrix * dfpMinv;
+  dvar_compressed_triplet * SdfpMinv;
+  dvar_vector * pu;
+  int xmyindex;
+  static int qflag; 
+  static sparse_quadratic_prior * ptr[]; // this should be a resizeable array
+  static void get_M_calculations(void);
+  static void cleanup_pMinv();
+  static void cleanup_dfpMinv();
+  static int num_sparse_quadratic_prior;
+  static int calc_matrix_flag;
+  static int matrix_mult_flag;
+  static const int max_num_sparse_quadratic_prior;
+  void add_to_list(void);
+public:
+  static int in_qp_calculations; 
+  int get_offset(int xs);
+  int get_myindex(void) { return xmyindex;}
+  static sparse_quadratic_prior * get_ptr(int i){ return ptr[i];} 
+  void operator = (const dvar_matrix &);
+  void operator = (const dmatrix &);
+  static int get_in_qp_calculations() { return in_qp_calculations; }
+  static int get_num_quadratic_prior(void) { return num_sparse_quadratic_prior;}
+  static dvariable get_quadratic_priors(void);
+  dvariable get_function(void);
+  sparse_quadratic_prior(void); 
+  ~sparse_quadratic_prior(void);
+  void allocate(const dvar_vector & _u,const char * s);
+  void allocate(const dvar_vector & _u);
+  void allocate(const dvar_matrix & _M, const dvar_vector & _u,const char * s);
+  void allocate(const dvar_matrix & _M, const dvar_vector & _u);
+  //dmatrix get_cHessian(void);
+  void get_cHessian(dmatrix,int);
+  void get_cHessian(dvar_matrix,int);
+  void get_cHessian_from_vHessian(dmatrix ,int);
+  void get_vHessian(dvar_matrix ,int);
+  void get_cgradient(dvector,int); 
+  dvar_matrix get_Hessian(void);
+  dvar_vector get_gradient(void); 
+  static dvar_vector get_gradient_contribution(void);
+  static dvar_matrix get_Hessian_contribution(void);
+  static void get_cgradient_contribution(dvector,int);
+  void get_cHessian_contribution(dmatrix,int);
+  static void get_cHessian_contribution(dcompressed_triplet * dct,int);
+  void get_cHessian(dcompressed_triplet * dct,int xsize); 
+  static void get_vHessian_contribution(dvar_matrix  ,int );
+  static void get_cHessian_contribution_from_vHessian(dmatrix,int);
+  friend class df1b2quadratic_prior;
+  virtual void get_cM(void)=0;
+};
+
+  class sparse_quadratic_re_penalty : public quadratic_prior
+  {
+    virtual void set_old_style_flag(void);
+  public:
+    sparse_quadratic_re_penalty(void);
+    void operator = (const dvar_matrix & M);
+    void operator = (const dmatrix & M);
+    void operator = (const dcompressed_triplet & M);
+    void operator = (const dvar_compressed_triplet & M);
+  };
+
+ class df1b2_compressed_triplet
+  {
+    int n;  // number of rows
+    int m;  // number of columns
+    imatrix coords;
+    df1b2vector x;
+  public:
+    int indexmin(void) { return x.indexmin();}
+    int indexmax(void) { return x.indexmax();}
+    df1b2variable& operator [] (int i) { return x[i];}
+    df1b2variable& operator () (int i) { return x(i);}
+    int& operator () (int i,int j) { return coords(i,j);}
+    df1b2_compressed_triplet(int mmin,int mmax,int n,int m);
+    explicit df1b2_compressed_triplet(const df1b2matrix&);
+    df1b2_compressed_triplet(void);
+    //dcompressed_triplet make_dcompressed_triplet(const dmatrix & );
+    void allocate(int mmin,int mmax,int n,int m);
+    void deallocate(void);
+    imatrix& get_coords(void)  { return coords; }
+    df1b2vector& get_x(void)  { return x; }
+    int get_n(){return n;}
+    int get_m(){return m;}
+    void initialize(void);
+    void operator = (const df1b2_compressed_triplet & M);
+  };
+
+  df1b2vector operator * (const df1b2_compressed_triplet& M,const dvector & v);
 #endif //!defined(__DF1B2FUN__)
 
Index: df1b2-separable/df1b2lap.cpp
===================================================================
--- df1b2-separable/df1b2lap.cpp	(revision 682)
+++ df1b2-separable/df1b2lap.cpp	(working copy)
@@ -15,8 +15,12 @@
 #  include <admodel.h>
 #  include <df1b2fun.h>
 #  include <adrndeff.h>
+#include <fvar.hpp>
+
+#define PI 3.14159265358979323846
+
         int fcount =0;
-static int no_stuff=0;
+ int no_stuff=0;
 static int write_sparse_flag=0;
     static void trapper(void)
     {
@@ -79,49 +83,41 @@
     u=ubest;
   }
  
+  dvariable pen=0.0;
   fmc1.dfn=1.e-2;
-  dvariable pen=0.0;
-  //cout << "starting  norm(u) = " << norm(u) << endl;
+  gradient_structure::no_derivatives=1;
+  if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
+  {
+    quadratic_prior::calc_matrix_flag=1;
+    quadratic_prior::matrix_mult_flag=0;
+    quadratic_prior::get_M_calculations();
+  }
+  gradient_structure::no_derivatives=0;
   while (fmc1.ireturn>=0)
   {
-   /*
-    double nu=norm(value(u));
-    if (nu>400)
-    {
-      cout << "U norm(u) = " << nu  << endl;
-    }
-    cout << "V norm(u) = " << nu
-         << " f = " << f  << endl;
-    */
     fmc1.fmin(f,u,g);
-    //cout << "W norm(u) = " << norm(value(u)) << endl;
+    
     if (fmc1.ireturn>0)
     {
       dvariable vf=0.0;
       pen=initial_params::reset(dvar_vector(u));
       *objective_function_value::pobjfun=0.0;
       pfmin->AD_uf_inner();
+      if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
+      {
+        quadratic_prior::calc_matrix_flag=0;
+	quadratic_prior::matrix_mult_flag=1;
+        quadratic_prior::get_M_calculations();
+	quadratic_prior::matrix_mult_flag=0;
+      }
       if (saddlepointflag)
       {
         *objective_function_value::pobjfun*=-1.0;
       }
-      if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
-      {
-        quadratic_prior::get_M_calculations();
-      }
       vf+=*objective_function_value::pobjfun;
      
-     /*  this is now done in the operator = function
-      if (quadratic_prior::get_num_quadratic_prior()>0)
-      {
-        vf+= quadratic_prior::get_quadratic_priors();
-      }
-      */
-      
-
       objective_function_value::fun_without_pen=value(vf);
       
-      //cout << " pen = " << pen << endl;
       if (noboundepen_flag==0)
       {
         vf+=pen;
@@ -133,9 +129,6 @@
         ub=u;
       }
       gradcalc(usize,g);
-      //cout << " f = " << setprecision(17) << f << " " << norm(g) 
-       // << " " << norm(u) << endl;
-     
     }
     u=ub;
   }
@@ -165,8 +158,15 @@
         pfmin->AD_uf_inner();
         if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
         {
+	  quadratic_prior::calc_matrix_flag=0;
+	  quadratic_prior::matrix_mult_flag=1;
           quadratic_prior::get_M_calculations();
+	  quadratic_prior::matrix_mult_flag=0;
         }
+        if (saddlepointflag)
+        {
+          *objective_function_value::pobjfun*=-1.0;
+        }
         vf+=*objective_function_value::pobjfun;
         objective_function_value::fun_without_pen=value(vf);
 
@@ -187,14 +187,17 @@
   cout << "  Inner f = " << fb << endl;
   fmc1.ireturn=0;
   fmc1.fbest=fb;
-  gradient_structure::set_NO_DERIVATIVES();
+  //gradient_structure::set_NO_DERIVATIVES();
   *objective_function_value::pobjfun=0.0;
   pfmin->AD_uf_inner();
   if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
   {
+    quadratic_prior::calc_matrix_flag=0;
+    quadratic_prior::matrix_mult_flag=1;
     quadratic_prior::get_M_calculations();
+    quadratic_prior::matrix_mult_flag=0;
   }
-  gradient_structure::set_YES_DERIVATIVES();
+  //gradient_structure::set_YES_DERIVATIVES();
   pfmin->inner_opt_flag=0;
   return u;
 }
@@ -337,7 +340,6 @@
   vsparse_triplet_adjoint(0),
   sparse_symbolic(0),
   sparse_symbolic2(0),
-  fmc1(usize,1),
   fmc(_xsize),
   xadjoint(1,_xsize),
   check_local_uadjoint(1,_usize),
@@ -346,8 +348,10 @@
   check_local_xadjoint2(1,_xsize),
   uadjoint(1,_usize),
   uhat(1,_usize),
-  ubest(1,_usize)
+  ubest(1,_usize),
+  no_re_ders_flag(0)
 {
+  cout << &uadjoint << endl;
   ubest.initialize();
   nested_shape.allocate(100,100,10);
   nested_shape.initialize();
@@ -392,6 +396,7 @@
   bw=0;
   bHess=0;
   grad_x_u=0;
+  sparse_cutoff=0;
   grad_x=0;
   int ndi=20000;
   int nopt=0;
@@ -428,11 +433,18 @@
   }
   inner_lmnflag=0;
   inner_lmnsteps=10;
+
+  if ( (on=option_match(ad_comm::argc,ad_comm::argv,"-noreders",nopt))>-1)
+  {
+    no_re_ders_flag=1;
+  }
+
+
   if ( (on=option_match(ad_comm::argc,ad_comm::argv,"-noinit",nopt))>-1)
   {
     init_switch=0;
   }
-  if ( (inner_lmnflag=option_match(ad_comm::argc,ad_comm::argv,"-ilmn",nopt))
+  if ( (inner_lmnflag=option_match(ad_comm::argc,ad_comm::argv,"-ilmn2",nopt))
     >-1)
   {
     if (!nopt)
@@ -451,7 +463,30 @@
         inner_lmnsteps=jj;
       }
     }
+    inner_lmnflag=2;
   }
+  else if 
+   ( (inner_lmnflag=option_match(ad_comm::argc,ad_comm::argv,"-ilmn",nopt))
+    >-1)
+  {
+    if (!nopt)
+    {
+      cerr << "Usage -ilmn option needs integer  -- set to default 10" << endl;
+    }
+    else
+    {   
+      int jj=atoi(ad_comm::argv[inner_lmnflag+1]);
+      if (jj<=0)
+      {
+        cerr << "Usage -ilmn option needs positive integer  -- set to defalt 10" << endl;
+      }
+      else
+      {
+        inner_lmnsteps=jj;
+      }
+    }
+    inner_lmnflag=1;
+  }
   else
   {
     inner_lmnflag=0;
@@ -516,6 +551,15 @@
     dd_nr_flag=1;
   }
 
+  if (inner_lmnflag==0)
+  {
+    fmc1.allocate(usize,1);
+  }
+  else
+  {
+    fmc2.allocate(usize,inner_lmnsteps);
+  }
+
   nvariables=xsize+usize;
   int rem=0;
   if (nvariables%xsize!=0)
@@ -1030,6 +1074,7 @@
   uadjoint(1,_usize),
   uhat(1,_usize)
 {
+  cout << &uadjoint << endl;
   nested_tree_position.initialize();
   nested_separable_calls_counter.initialize();
   //hesstype=1;
@@ -1055,6 +1100,7 @@
   bw=0;
   bHess=0;
   grad_x_u=0;
+  sparse_cutoff=0;
   grad_x=0;
   have_users_hesstype=0;
   int mmin=_minder.indexmin();
@@ -1431,7 +1477,9 @@
   //dcompressed_triplet & lst2 = *(pmin->lapprox->sparse_triplet);
   //hs_symbolic & ssymb=*(pmin->lapprox->sparse_symbolic);
   //dcompressed_triplet & xxxt = *(pmin->lapprox->sparse_triplet);
-  dcompressed_triplet & lst = *(pmin->lapprox->sparse_triplet2);
+  
+  dcompressed_triplet*  plst = pmin->lapprox->sparse_triplet2;
+
   hs_symbolic & ssymb=*(pmin->lapprox->sparse_symbolic2);
   {
   /*
@@ -1451,7 +1499,7 @@
   }
   else
   {
-    int sz= lst.indexmax()-lst.indexmin()+1;
+    int sz= plst->indexmax()-plst->indexmin()+1;
     nvar=x.size()+u0.size()+sz;
   }
   independent_variables y(1,nvar);
@@ -1468,39 +1516,52 @@
   dvar_vector d(1,xs+us);
 
   dmatrix Hess_save;
+  dcompressed_triplet  S_Hess_save;
   // contribution for quadratic prior
   if (quadratic_prior::get_num_quadratic_prior()>0)
   {
-    if (allocated(Hess_save)) Hess_save.deallocate();
-    int mmin=Hess.indexmin();
-    int mmax=Hess.indexmax();
-    Hess_save.allocate(mmin,mmax,mmin,mmax);
-    Hess_save=Hess;
     int & vxs = (int&)(xs);
-    quadratic_prior::get_cHessian_contribution(Hess,vxs);
+    if (pmin->lapprox->sparse_hessian_flag==0)
+    {
+      if (allocated(Hess_save)) Hess_save.deallocate();
+      int mmin=Hess.indexmin();
+      int mmax=Hess.indexmax();
+      Hess_save.allocate(mmin,mmax,mmin,mmax);
+      Hess_save=Hess;
+      quadratic_prior::get_cHessian_contribution(Hess,vxs);
+    }
   }
  // Here need hooks for sparse matrix structures
   int ii=xs+us+1;
   if (pmin->lapprox->sparse_hessian_flag==0)
   {
-    for (i=1;i<=us;i++)
-      for (j=1;j<=us;j++)
-      y(ii++)=Hess(i,j);
+    if (quadratic_prior::get_num_quadratic_prior()>0)
+      for (i=1;i<=us;i++)
+        for (j=1;j<=us;j++)
+          y(ii++)=Hess_save(i,j);
+    else
+      for (i=1;i<=us;i++)
+        for (j=1;j<=us;j++)
+          y(ii++)=Hess(i,j);
   }
   else
   {
-    int smin=lst.indexmin();
-    int smax=lst.indexmax();
+    int smin=plst->indexmin();
+    int smax=plst->indexmax();
     for (i=smin;i<=smax;i++)
-      y(ii++)=lst(i);
+      y(ii++)=(*plst)(i);
   }
 
-//#if !defined(__MSVC32__)
+ 
   if (quadratic_prior::get_num_quadratic_prior()>0)
   {
-    Hess=Hess_save;
+    if (pmin->lapprox->sparse_hessian_flag==0)
+      Hess=Hess_save;
   }
-//#endif
+  {
+    dvector tmp(1,1);
+    gradcalc(0,tmp);
+  }
 
   dvar_vector vy=dvar_vector(y); 
   initial_params::stddev_vscale(d,vy);
@@ -1551,8 +1612,8 @@
     }
     else
     {
-      int mmin=lst.indexmin();
-      int mmax=lst.indexmax();
+      int mmin=plst->indexmin();
+      int mmax=plst->indexmax();
       dvar_compressed_triplet * vsparse_triplet = 
         pmin->lapprox->vsparse_triplet;
    
@@ -1563,8 +1624,8 @@
         vsparse_triplet = pmin->lapprox->vsparse_triplet;
         for (i=mmin;i<=mmax;i++)
         {
-          (*vsparse_triplet)(1,i)=lst(1,i);
-          (*vsparse_triplet)(2,i)=lst(2,i);
+          (*vsparse_triplet)(1,i)=(*plst)(1,i);
+          (*vsparse_triplet)(2,i)=(*plst)(2,i);
         }
       }
       else
@@ -1574,13 +1635,14 @@
           (*vsparse_triplet).allocate(mmin,mmax,us,us);
           for (i=mmin;i<=mmax;i++)
           {
-            (*vsparse_triplet)(1,i)=lst(1,i);
-            (*vsparse_triplet)(2,i)=lst(2,i);
+            (*vsparse_triplet)(1,i)=(*plst)(1,i);
+            (*vsparse_triplet)(2,i)=(*plst)(2,i);
           }
         } 
       }
       dcompressed_triplet * vsparse_triplet_adjoint = 
         pmin->lapprox->vsparse_triplet_adjoint;
+      int shit=1;
    
       if (vsparse_triplet_adjoint==0)
       {
@@ -1589,8 +1651,8 @@
         vsparse_triplet_adjoint = pmin->lapprox->vsparse_triplet_adjoint;
         for (i=mmin;i<=mmax;i++)
         {
-          (*vsparse_triplet_adjoint)(1,i)=lst(1,i);
-          (*vsparse_triplet_adjoint)(2,i)=lst(2,i);
+          (*vsparse_triplet_adjoint)(1,i)=(*plst)(1,i);
+          (*vsparse_triplet_adjoint)(2,i)=(*plst)(2,i);
         }
       }
       else
@@ -1600,37 +1662,120 @@
           (*vsparse_triplet_adjoint).allocate(mmin,mmax,us,us);
           for (i=mmin;i<=mmax;i++)
           {
-            (*vsparse_triplet_adjoint)(1,i)=lst(1,i);
-            (*vsparse_triplet_adjoint)(2,i)=lst(2,i);
+            (*vsparse_triplet_adjoint)(1,i)=(*plst)(1,i);
+            (*vsparse_triplet_adjoint)(2,i)=(*plst)(2,i);
           }
         } 
       }
       vsparse_triplet->get_x()=vy(ii,ii+mmax-mmin).shift(1);
+      shit=0;
+      if (quadratic_prior::get_num_quadratic_prior()>0)
+      {
+        if (pmin->lapprox->sparse_hessian_flag) 
+        {
+          quadratic_prior::get_cHessian_contribution(
+            pmin->lapprox->sparse_triplet2,xs,
+            *pmin->lapprox->sparse_iterator,pmin->lapprox->sparse_count);
+          pmin->lapprox->sparse_count=pmin->lapprox->sparse_cutoff;
+        }
+      }
     }
   }
+  int exvar=0;
+  if (exvar)
+  {
+    pmin->lapprox->vsparse_triplet->get_x()+=1.0;
+    dvariable ld=0.5*ln_det(*(pmin->lapprox->vsparse_triplet));
+      
+    dvector g(1,nvar);
+    gradcalc(nvar,g);
+    cout << ld << endl;
+    cout << g << endl;
+    exvar=0;
+  }
    dvariable vf=0.0;
-
    
    *objective_function_value::pobjfun=0.0;
-   pmin->AD_uf_outer();
-   if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
+
+   int cx=1;
+   if (cx)
    {
-     quadratic_prior::get_M_calculations();
+     pmin->AD_uf_outer();
+     cx=1;
    }
-   vf+=*objective_function_value::pobjfun;
+
+   int fx=0;
+   if (fx)
+   {
+     dvector tmpg(1,nvar);
+     tmpg.initialize();
+     gradcalc(nvar,tmpg);
+     fx=0;
+   }
+
+   pmin->inner_opt_flag=0;
+   int rx=1;
+   if (rx)
+   {
+     if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
+     {
+       quadratic_prior::calc_matrix_flag=1;
+       quadratic_prior::matrix_mult_flag=1;
+       quadratic_prior::get_M_calculations();
+       quadratic_prior::matrix_mult_flag=0;
+       quadratic_prior::calc_matrix_flag=0;
+     }
+     rx=1;
+   }
+       
+   int gx=0;
+   if (gx)
+   {
+     dvector tmpg(1,nvar);
+     tmpg.initialize();
+     gradcalc(nvar,tmpg);
+     gx=0;
+   }
+
+   if (quadratic_prior::get_num_quadratic_prior()>0)
+   {
+     if (pmin->lapprox->sparse_hessian_flag)  
+     {
+       for (int i=0;i<quadratic_prior::get_num_quadratic_prior()>0;i++)
+       {
+         quadratic_prior::ptr[i]->get_vHessian(*pmin->lapprox->vsparse_triplet,
+           xs,*pmin->lapprox->sparse_iterator,
+           pmin->lapprox->sparse_count);
+       }
+     }
+     else
+     {
+       for (int i=0;i<quadratic_prior::get_num_quadratic_prior()>0;i++)
+       {
+         quadratic_prior::ptr[i]->get_vHessian(vHess,xs);
+       }
+     }
+   }
+
+   pmin->inner_opt_flag=0;
    //cout << setprecision(15) << vf << endl;
   // *********************************************
   // *********************************************
   // *********************************************
-  // dvector tmpg(1,nvar);
-  // tmpg.initialize();
-  // gradcalc(nvar,tmpg);
+   dvector tmpg(1,nvar);
+   tmpg.initialize();
+   int bx=0;
+   if (bx)
+   {
+     gradcalc(nvar,tmpg);
+     bx=0;
+   }
   // *********************************************
   // *********************************************
   // *********************************************
 
    int sgn=0;
-   dvariable ld = 0;
+   dvariable ld=0.0;
    if (ad_comm::no_ln_det_choleski_flag)
    {
      if(laplace_approximation_calculator::saddlepointflag==0)
@@ -1649,7 +1794,8 @@
        int ierr=0;
        if (pmin->lapprox->sparse_hessian_flag==0)
        {
-         ld=0.5*ln_det_choleski_error(vHess,ierr);
+         dvariable ld2=0.5*ln_det_choleski_error(vHess,ierr);
+         *objective_function_value::pobjfun+=ld2;
          if (ierr==1)
          {
            ofstream ofs("hessian.diag");
@@ -1671,10 +1817,11 @@
            //ofstream ofs("sparse");
            //ofs << *(pmin->lapprox->vsparse_triplet) << endl;
          }
-         ld=0.5*ln_det(*(pmin->lapprox->vsparse_triplet),
+         // !!! need to fix this
+         //dvariable ld=0.5*ln_det(*(pmin->lapprox->vsparse_triplet));
+         dvariable ld2=0.5*ln_det(*(pmin->lapprox->vsparse_triplet),
            ssymb,*(pmin->lapprox->sparse_triplet2));
-           //*(pmin->lapprox->sparse_symbolic2),pmin->lapprox);
-         //cout << ld-ld1 << endl;
+         *objective_function_value::pobjfun+=ld2;
        }
      }
      else 
@@ -1721,11 +1868,7 @@
    }
 
    int nx=0;
-   if (nx==0)
-   {
-     vf+=ld;
-   }
-   double f=value(vf);
+   double f=value(*objective_function_value::pobjfun);
    f-=us*0.5*log(2.0*PI);
    dvector g(1,nvar);
    gradcalc(nvar,g);
@@ -1749,8 +1892,8 @@
     dcompressed_triplet * vsparse_triplet_adjoint = 
       pmin->lapprox->vsparse_triplet_adjoint;
 
-    int smin=lst.indexmin();
-    int smax=lst.indexmax();
+    int smin=plst->indexmin();
+    int smax=plst->indexmax();
     for (i=smin;i<=smax;i++)
     {
       (*vsparse_triplet_adjoint)(i)=g(ii);
@@ -1920,6 +2063,7 @@
   int usize=initial_params::nvarcalc(); 
   //double f=0.0;
   dvector g(1,usize);
+  gradcalc(0,g);
   independent_variables u(1,usize);
   u=x;
   dvariable vf=0.0;
@@ -1927,11 +2071,15 @@
   //vf=0.0;
   *objective_function_value::pobjfun=0.0;
   laplace_approximation_calculator::where_are_we_flag=2; 
+  pfmin->inner_opt_flag=1;
   pfmin->AD_uf_inner();
   if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
   {
+    quadratic_prior::matrix_mult_flag=1;
     quadratic_prior::get_M_calculations();
+    quadratic_prior::matrix_mult_flag=0;
   }
+  pfmin->inner_opt_flag=0;
   vf+=*objective_function_value::pobjfun;
   laplace_approximation_calculator::where_are_we_flag=0; 
   initial_df1b2params::cobjfun=value(vf);
@@ -2698,114 +2846,52 @@
  * Description not yet available.
  * \param
  */
-dvector laplace_approximation_calculator::get_uhat_lm_newton2
-  (const dvector& x,function_minimizer * pfmin)
-{
-  //int on,nopt;
-  pfmin->inner_opt_flag=1;
-  double f=0.0;
-  double fb=1.e+100;
-  dvector g(1,usize);
-  dvector ub(1,usize);
-  independent_variables u(1,usize);
-  gradcalc(0,g);
-  fmc1.itn=0;
-  fmc1.ifn=0;
-  fmc1.ireturn=0;
-  initial_params::xinit(u);    // get the initial values into the
-  initial_params::xinit(ubest);    // get the initial values into the
-  fmc1.ialph=0;
-  fmc1.ihang=0;
-  fmc1.ihflag=0;
-  
-  if (init_switch)
+
+  dvector laplace_approximation_calculator::get_uhat_lm_newton2
+    (const dvector& x,function_minimizer * pfmin)
   {
-    u.initialize();
-  }
-  else
-  {
-    u=ubest;
-  }
- 
-  fmc1.dfn=1.e-2;
-  dvariable pen=0.0;
-  //cout << "starting  norm(u) = " << norm(u) << endl;
-  while (fmc1.ireturn>=0)
-  {
-   /*
-    double nu=norm(value(u));
-    if (nu>400)
+    fmc2.iprint=0;
+    fmc2.noprintx=1;
+    int on,nopt;
+    pfmin->inner_opt_flag=1;
+    double f=0.0;
+    double fb=1.e+100;
+    dvector g(1,usize);
+    dvector ub(1,usize);
+    independent_variables u(1,usize);
+    gradcalc(0,g);
+    fmc2.itn=0;
+    fmc2.ifn=0;
+    fmc2.ireturn=0;
+    initial_params::xinit(u);    // get the initial values into the
+    initial_params::xinit(ubest);    // get the initial values into the
+    fmc2.ialph=0;
+    fmc2.ihang=0;
+    fmc2.ihflag=0;
+    fmc1.use_control_c=0;
+    
+    if (init_switch)
     {
-      cout << "U norm(u) = " << nu  << endl;
+      u.initialize();
     }
-    cout << "V norm(u) = " << nu
-         << " f = " << f  << endl;
-    */
-    fmc1.fmin(f,u,g);
-    //cout << "W norm(u) = " << norm(value(u)) << endl;
-    if (fmc1.ireturn>0)
+    else
     {
-      dvariable vf=0.0;
-      pen=initial_params::reset(dvar_vector(u));
-      *objective_function_value::pobjfun=0.0;
-      pfmin->AD_uf_inner();
-      if (saddlepointflag)
-      {
-        *objective_function_value::pobjfun*=-1.0;
-      }
-      if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
-      {
-        quadratic_prior::get_M_calculations();
-      }
-      vf+=*objective_function_value::pobjfun;
-     
-     /*  this is now done in the operator = function
-      if (quadratic_prior::get_num_quadratic_prior()>0)
-      {
-        vf+= quadratic_prior::get_quadratic_priors();
-      }
-      */
-      
-
-      objective_function_value::fun_without_pen=value(vf);
-      
-      //cout << " pen = " << pen << endl;
-      if (noboundepen_flag==0)
-      {
-        vf+=pen;
-      }
-      f=value(vf);
-      if (f<fb) 
-      {
-        fb=f;
-        ub=u;
-      }
-      gradcalc(usize,g);
-      //cout << " f = " << setprecision(17) << f << " " << norm(g) 
-       // << " " << norm(u) << endl;
-     
+      u=ubest;
     }
-    u=ub;
-  }
-  cout <<  " inner maxg = " <<  fmc1.gmax;
-  if (fabs(fmc1.gmax)>1.e+3)
-    trapper();
+   
+    fmc2.dfn=1.e-2;
+    dvariable pen=0.0;
+    if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
+    {
+      quadratic_prior::calc_matrix_flag=1;
+      quadratic_prior::matrix_mult_flag=0;
+      quadratic_prior::get_M_calculations();
+    }
 
-  if (fabs(fmc1.gmax)>1.e-4)
-  {
-    fmc1.itn=0;
-    //fmc1.crit=1.e-9;
-    fmc1.ifn=0;
-    fmc1.ireturn=0;
-    fmc1.ihang=0;
-    fmc1.ihflag=0;
-    fmc1.ialph=0;
-    initial_params::xinit(u);    // get the initial values into the
-    //u.initialize();
-    while (fmc1.ireturn>=0)
+    while (fmc2.ireturn>=0)
     {
-      fmc1.fmin(f,u,g);
-      if (fmc1.ireturn>0)
+      fmc2.fmin(f,u,g);
+      if (fmc2.ireturn>0)
       {
         dvariable vf=0.0;
         pen=initial_params::reset(dvar_vector(u));
@@ -2813,12 +2899,24 @@
         pfmin->AD_uf_inner();
         if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
         {
+          quadratic_prior::calc_matrix_flag=0;
+          quadratic_prior::matrix_mult_flag=1;
           quadratic_prior::get_M_calculations();
+          quadratic_prior::matrix_mult_flag=0;
         }
+
+        if (saddlepointflag)
+        {
+          *objective_function_value::pobjfun*=-1.0;
+        }
         vf+=*objective_function_value::pobjfun;
+
         objective_function_value::fun_without_pen=value(vf);
 
-        vf+=pen;
+        if (noboundepen_flag==0)
+        {
+          vf+=pen;
+        }
         f=value(vf);
         if (f<fb) 
         {
@@ -2826,27 +2924,79 @@
           ub=u;
         }
         gradcalc(usize,g);
-        //cout << " f = " << setprecision(15) << f << " " << norm(g) << endl;
       }
+      u=ub;
     }
-    u=ub;
-    cout <<  "  Inner second time = " << fmc1.gmax;
+    cout <<  " inner maxg = " <<  fmc2.gmax;
+    if (fabs(fmc2.gmax)>1.e+3)
+      trapper();
+  
+    if (fabs(fmc2.gmax)>1.e-4)
+    {
+      fmc2.itn=0;
+      //fmc2.crit=1.e-9;
+      fmc2.ifn=0;
+      fmc2.ireturn=0;
+      fmc2.ihang=0;
+      fmc2.ihflag=0;
+      fmc2.ialph=0;
+      initial_params::xinit(u);    // get the initial values into the
+      //u.initialize();
+      while (fmc2.ireturn>=0)
+      {
+        fmc2.fmin(f,u,g);
+        if (fmc2.ireturn>0)
+        {
+          dvariable vf=0.0;
+          pen=initial_params::reset(dvar_vector(u));
+          *objective_function_value::pobjfun=0.0;
+          pfmin->AD_uf_inner();
+          if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
+          {
+            quadratic_prior::calc_matrix_flag=0;
+            quadratic_prior::matrix_mult_flag=1;
+            quadratic_prior::get_M_calculations();
+            quadratic_prior::matrix_mult_flag=0;
+          }
+          if (saddlepointflag)
+          {
+            *objective_function_value::pobjfun*=-1.0;
+          }
+
+          vf+=*objective_function_value::pobjfun;
+          objective_function_value::fun_without_pen=value(vf);
+
+          vf+=pen;
+          f=value(vf);
+
+          if (f<fb) 
+          {
+            fb=f;
+            ub=u;
+          }
+          gradcalc(usize,g);
+        }
+      }
+      u=ub;
+      cout <<  "  Inner second time = " << fmc2.gmax;
+    }
+    cout << "  Inner f = " << fb << endl;
+    fmc2.ireturn=0;
+    fmc2.fbest=fb;
+ //   gradient_structure::set_NO_DERIVATIVES();
+    *objective_function_value::pobjfun=0.0;
+    pfmin->AD_uf_inner();
+    if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
+    {
+      quadratic_prior::calc_matrix_flag=0;
+      quadratic_prior::matrix_mult_flag=1;
+      quadratic_prior::get_M_calculations();
+      quadratic_prior::matrix_mult_flag=0;
+    }
+ //   gradient_structure::set_YES_DERIVATIVES();
+    pfmin->inner_opt_flag=0;
+    return u;
   }
-  cout << "  Inner f = " << fb << endl;
-  fmc1.ireturn=0;
-  fmc1.fbest=fb;
-  gradient_structure::set_NO_DERIVATIVES();
-  *objective_function_value::pobjfun=0.0;
-  pfmin->AD_uf_inner();
-  if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
-  {
-    quadratic_prior::get_M_calculations();
-  }
-  gradient_structure::set_YES_DERIVATIVES();
-  pfmin->inner_opt_flag=0;
-  return u;
-}
-
 #  endif
   
 #endif
Index: df1b2-separable/df1b2lp6.cpp
===================================================================
--- df1b2-separable/df1b2lp6.cpp	(revision 682)
+++ df1b2-separable/df1b2lp6.cpp	(working copy)
@@ -25,11 +25,14 @@
 double calculate_importance_sample_shess(const dvector& x,const dvector& u0,
   const dmatrix& Hess,const dvector& _xadjoint,const dvector& _uadjoint,
   const dmatrix& _Hessadjoint,function_minimizer * pmin);
+dvector evaluate_quadprior(const dvector& x,int usize,
+  function_minimizer * pfmin);
 
 int use_dd_nr=0;
 int admb_ssflag=0;
 dvector solve(const dmatrix & st,const dmatrix & Hess,
   const dvector& grad);
+dvector return_choleski_decomp_solve(dcompressed_triplet & st,dvector& eps);
 
 #if defined(USE_DD_STUFF)
 #  if defined(__MSVC32__)
@@ -94,8 +97,19 @@
       cout << "Newton raphson " << ii << "  ";
     if (quadratic_prior::get_num_quadratic_prior()>0)
     {
-      quadratic_prior::get_cHessian_contribution(Hess,xsize);
-      quadratic_prior::get_cgradient_contribution(grad,xsize);
+      if (sparse_hessian_flag==0)
+      {
+        quadratic_prior::get_cHessian_contribution(Hess,xsize);
+        quadratic_prior::get_cgradient_contribution(grad,xsize);
+      }
+      else
+      {
+        quadratic_prior::get_cHessian_contribution(sparse_triplet2,xsize,
+          *sparse_iterator,sparse_count);
+
+        quadratic_prior::get_cgradient_contribution(grad,xsize);
+
+      }
     }
 
     int ierr=0;
@@ -135,11 +149,12 @@
             ad_exit(1);
 #endif
           }
+
           maxg=fabs(evaluate_function(uhat,pfmin));
-          if (f_from_1< pfmin->lapprox->fmc1.fbest)
+          if (f_from_1< fmc1.fbest)
           {
-            uhat=banded_calculations_trust_region_approach(uhat,pfmin);
-            maxg=fabs(evaluate_function(uhat,pfmin));
+            //uhat=banded_calculations_trust_region_approach(uhat,pfmin);
+            //maxg=fabs(evaluate_function(uhat,pfmin));
           }
         }
       }
@@ -207,7 +222,13 @@
         if (sparse_hessian_flag)
         {
           //step=-solve(*sparse_triplet,Hess,grad,*sparse_symbolic);
+          //dmatrix S=make_sdmatrix(*sparse_triplet2);
+          int ierrx=22;
+          //dvector temp1= choleski_solve_error(S,grad,ierrx);
+          //dvector temp2=return_choleski_decomp_solve(*sparse_triplet2,grad);
           dvector temp=solve(*sparse_triplet2,grad,*sparse_symbolic2,ierr);
+          //cout << norm2(temp2-temp) << endl;
+          //cout << norm2(temp-temp1) << endl;
           if (ierr)
           {
             step=-temp;
@@ -313,14 +334,13 @@
     {
       uhat=get_uhat_quasi_newton_qd(x,pfmin);
     }
+    return fmc1.fbest;
   }
   else
   {
-    uhat=get_uhat_lm_newton(x,pfmin);
-    //uhat=get_uhat_lm_newton2(x,pfmin);
-    //maxg=objective_function_value::gmax;
+    uhat=get_uhat_lm_newton2(x,pfmin);
+    return fmc2.fbest;
   }
-  return fmc1.fbest;
 }
 
 /**
@@ -408,7 +428,7 @@
     }
     while(no_converge_flag);
 
-    /* If we are in mcmc phase we just need to calcualte the
+    /* If we are in mcmc phase we just need to calculate the
        ln_det(Hess) and return
     */
     hs_symbolic & ssymb=*(pmin->lapprox->sparse_symbolic2);
@@ -513,7 +533,7 @@
         f=1.e+30;
       }
 
-      // set flag for thrid erivatvies and call function again because
+      // set flag for third derivatives and call function again because
       // stack is wiped out
       
     
@@ -548,27 +568,30 @@
       pfmin->user_function();
     
       // *** Hessian calculated just above did not have quadratic prior
-      // in it so can save this part for quadratci prioer adjoint calculations
+      // in it so can save this part for quadratic prior adjoint calculations
       if (quadratic_prior::get_num_quadratic_prior()>0)
       {
-        if (pHess_non_quadprior_part)
+        if (sparse_hessian_flag==0)
         {
-          if (pHess_non_quadprior_part->indexmax() != Hess.indexmax())
+          if (pHess_non_quadprior_part)
           {
-            delete pHess_non_quadprior_part;
-            pHess_non_quadprior_part=0;
+            if (pHess_non_quadprior_part->indexmax() != Hess.indexmax())
+            {
+              delete pHess_non_quadprior_part;
+              pHess_non_quadprior_part=0;
+            }
           }
-        }
-        if (!pHess_non_quadprior_part)
-        {
-          pHess_non_quadprior_part=new dmatrix(1,usize,1,usize);
           if (!pHess_non_quadprior_part)
           {
-            cerr << "Error allocating memory for Hesssian part" << endl;
-            ad_exit(1);
+            pHess_non_quadprior_part=new dmatrix(1,usize,1,usize);
+            if (!pHess_non_quadprior_part)
+            {
+              cerr << "Error allocating memory for Hesssian part" << endl;
+              ad_exit(1);
+            }
           }
+          (*pHess_non_quadprior_part)=Hess;
         }
-        (*pHess_non_quadprior_part)=Hess;
       } 
            
       block_diagonal_flag=0;
@@ -585,8 +608,9 @@
       /*int check=*/initial_params::stddev_scale(scale1,x);
       //for (i=1;i<=xadjoint.indexmax();i++)
       //  xadjoint(i)*=scale1(i);
+  
       laplace_approximation_calculator::where_are_we_flag=0; 
-  
+
       if (df1b2quadratic_prior::get_num_quadratic_prior()>0)
       {  
        // !!!! need to fix this!!!!!!!!!!!!!!!!!!!!!!!
@@ -594,11 +618,32 @@
         quadratic_prior::in_qp_calculations=1;
         funnel_init_var::lapprox=this;
         df1b2_gradlist::set_no_derivatives(); 
+        //pfmin->inner_opt_flag=1;
+        quadratic_prior::calc_matrix_flag=1;
+        quadratic_prior::matrix_mult_flag=1;
         df1b2quadratic_prior::get_Lxu_contribution(Dux);
+        //pfmin->inner_opt_flag=0;
+        quadratic_prior::matrix_mult_flag=0;
+        quadratic_prior::calc_matrix_flag=0;
         quadratic_prior::in_qp_calculations=0;
         funnel_init_var::lapprox=0;
         laplace_approximation_calculator::where_are_we_flag=0; 
       }   
+     
+      // we don;t seem to need this in the sparse case ?????
+     
+     /*
+      if (sparse_hessian_flag==0 && 
+        quadratic_prior::get_num_quadratic_prior()>0)
+      {
+        quadratic_prior::matrix_mult_flag=1;
+        dvector tmp=evaluate_quadprior(x,usize,pfmin);
+        quadratic_prior::matrix_mult_flag=0;
+        local_dtemp+=tmp;
+      }
+      */
+     
+      
       if (initial_df1b2params::separable_flag)
       {
         dvector scale(1,nvar);   // need to get scale from somewhere
@@ -612,11 +657,6 @@
       }
       //cout << trans(Dux)(1) << endl;
       //cout << trans(Dux)(3) << endl;  
-      if (quadratic_prior::get_num_quadratic_prior()>0)
-      {
-        dvector tmp=evaluate_function_with_quadprior(x,usize,pfmin);
-        local_dtemp+=tmp;
-      }
           
       for (i=1;i<=xsize;i++)
       {
@@ -625,7 +665,14 @@
       if (df1b2quadratic_prior::get_num_quadratic_prior()>0)
       {
        // !!!! need to fix this!!!!!!!!!!!!!!!!!!!!!!!
-        quadratic_prior::get_cHessian_contribution_from_vHessian(Hess,xsize);
+        if (sparse_hessian_flag==0)
+          quadratic_prior::get_cHessian_contribution_from_vHessian(Hess,xsize);
+        else
+        {
+          int sc=pfmin->lapprox->sparse_cutoff;
+          quadratic_prior::get_cHessian_contribution_from_vHessian
+            (sparse_triplet2,xsize,*sparse_iterator,sc);
+        }
       }
    
       if (hesstype==3)
@@ -1103,7 +1150,7 @@
   //do
   dvector values(1,300);
   double oldfbest=pmin->lapprox->fmc1.fbest; 
-  double newfbest;
+  double newfbest=1.e+150;
   int have_value=0;
   //for (int jj=1;jj<=300;jj++)
   int jj=1;
Index: df1b2-separable/df1b2lp8.cpp
===================================================================
--- df1b2-separable/df1b2lp8.cpp	(revision 682)
+++ df1b2-separable/df1b2lp8.cpp	(working copy)
@@ -403,7 +403,8 @@
 {
   //int i,j,ip; 
   int i,ip; 
-  if (quadratic_prior::get_num_quadratic_prior()>0)
+  if (quadratic_prior::get_num_quadratic_prior()>0 && 
+     quadratic_prior::sparse_flag==0)
   {
     hesstype=4;
     if (allocated(Hess))
@@ -470,22 +471,28 @@
   
       quadratic_prior::in_qp_calculations=1; 
 
+      int nsc=0;
       if (sparse_hessian_flag)
       {
         // just to get the number of separable calls
         separable_calls_counter=0;
         pfmin->AD_uf_inner();
         // allocate space for uncompressed sparse hessian information
+        nsc=separable_calls_counter;
 
-        //num_separable_calls=separable_calls_counter;
+        if (quadratic_prior::get_num_quadratic_prior()>0 && 
+          quadratic_prior::sparse_flag==1)
+        {
+          nsc+=1;
+        }
         if (triplet_information==0) 
         {
-          triplet_information =new i3_array(1,separable_calls_counter);
+          triplet_information =new i3_array(1,nsc);
         }
-        else if ( triplet_information->indexmax() != separable_calls_counter) 
+        else if ( triplet_information->indexmax() != nsc) 
         {
           delete triplet_information;
-          triplet_information =new i3_array(1,separable_calls_counter);
+          triplet_information =new i3_array(1,nsc);
         }
         triplet_information->initialize();
         separable_calls_counter=0;
@@ -493,10 +500,33 @@
 
       pfmin->pre_user_function();
 
+      if (quadratic_prior::get_num_quadratic_prior()>0 && 
+          quadratic_prior::sparse_flag==1)
+      {
+        pfmin->inner_opt_flag=1;
+        quadratic_prior::calc_matrix_flag=1;
+        quadratic_prior::matrix_mult_flag=0;
+        df1b2quadratic_prior::ptr[0]->get_cM();
+        quadratic_prior::ptr[0]->get_cM();
+        pfmin->inner_opt_flag=0;
+        quadratic_prior::calc_matrix_flag=0;
 
+        (*triplet_information)(nsc)=quadratic_prior::ptr[0]->SCM->get_coords();
+        //imatrix * tmp=new imatrix(quadratic_prior::ptr[0]->SCM->get_coords());
+      }
+      int non_block_diagonal=0;
+
       if (sparse_hessian_flag)
       {
-        // turn triplet_informaiton into  compressed_triplet_information 
+        // if we have a sparse_quadratic_prior object
+        // get extra stuff for sparseness
+        non_block_diagonal=1;
+        // turn triplet_information into  compressed_triplet_information 
+        if (pfmin->spqp)
+        {
+          imatrix tmp;
+          pfmin->get_sparse_stuff(&tmp,1);
+        }
         int mmin= triplet_information->indexmin();
         int mmax= triplet_information->indexmax();
         int i;
@@ -505,6 +535,11 @@
         {
           if (allocated((*triplet_information)(i)))
           {
+            if (i==mmax)
+            {
+              sparse_cutoff=ndim;
+              //cout << "HERE" << endl;
+            }
             ndim+=(*triplet_information)(i,1).indexmax();
           }
         }
@@ -514,8 +549,10 @@
           compressed_triplet_information=0;
         }
         compressed_triplet_information=new imatrix(1,ndim,1,3);
-        (*compressed_triplet_information)(3).fill_seqadd(1,1);
+        //(*compressed_triplet_information)(3).fill_seqadd(1,1);
         int ii=0;
+
+
         for (i=mmin;i<=mmax;i++)
         {
           if (allocated((*triplet_information)(i)))
@@ -556,7 +593,6 @@
 
       quadratic_prior::in_qp_calculations=0; 
   
-      int non_block_diagonal=0;
       for (i=xsize+1;i<=xsize+usize;i++)
       {
         if (used_flags(i)>1)
@@ -565,6 +601,7 @@
           break;
         } 
       }
+
       if (non_block_diagonal)
       {
         if (bw< usize/2 && sparse_hessian_flag==0)
@@ -1212,5 +1249,63 @@
 }      
       
 
+/*
+imatrix  get_compressed_triplet_for_sparse_qp()
+{
+  int mmin= lapprox->triplet_information->indexmin();
+  int mmax= lapprox->triplet_information->indexmax();
+  int i;
+  int ndim=0;
+  for (i=mmin;i<=mmax;i++)
+  {
+    if (allocated((*triplet_information)(i)))
+    {
+      ndim+=(*triplet_information)(i,1).indexmax();
+    }
+  }
+  if (compressed_triplet_information)
+  {
+    delete compressed_triplet_information;
+    compressed_triplet_information=0;
+  }
+  compressed_triplet_information=new imatrix(1,ndim,1,3);
+  (*compressed_triplet_information)(3).fill_seqadd(1,1);
+  int ii=0;
+  for (i=mmin;i<=mmax;i++)
+  {
+    if (allocated((*triplet_information)(i)))
+    {
+      int jmin=(*triplet_information)(i,1).indexmin();
+      int jmax=(*triplet_information)(i,1).indexmax();
+      int j;
+      for (j=jmin;j<=jmax;j++)
+      {
+        ii++;
+        (*compressed_triplet_information)(ii,1)=
+          (*triplet_information)(i,1,j);
+        (*compressed_triplet_information)(ii,2)=
+          (*triplet_information)(i,2,j);
+        (*compressed_triplet_information)(ii,3)=ii;
+      }
+    }
+  }
+  imatrix & cti= *compressed_triplet_information;
+  cti=sort(cti,1);
+  int lmin=1;
+  int lmax=0;
+  for (i=2;i<=ndim;i++)
+  {
+    if (cti(i,1)>cti(i-1,1))
+    {
+      lmax=i-1;
+      cti.sub(lmin,lmax)=sort(cti.sub(lmin,lmax),2);
+      lmin=i;
+    }
+  } 
+  cti.sub(lmin,ndim)=sort(cti.sub(lmin,ndim),2);
+  imatrix tmp=trans(cti);
+  delete compressed_triplet_information;
+  compressed_triplet_information=new imatrix(tmp);
+  */  
 
 #endif // if defined(USE_LAPLACE)
Index: df1b2-separable/df1b2lp9.cpp
===================================================================
--- df1b2-separable/df1b2lp9.cpp	(revision 682)
+++ df1b2-separable/df1b2lp9.cpp	(working copy)
@@ -1,282 +1,283 @@
-/*
- * $Id$
- *
- * Author: David Fournier
- * Copyright (c) 2008-2012 Regents of the University of California 
- */
-/**
- * \file
- * Description not yet available.
- */
-#if defined(USE_LAPLACE)
-#  include <admodel.h>
-#  include <df1b2fun.h>
-#  include <adrndeff.h>
-        //int fcount =0;
-  static int no_stuff=0;
-              static void crap(void)
-              {
-              }
-              static void crap(double ff,dvector& uuu,dvector& gg)
-              {
-                //cout << setprecision(10) << setw(19) << ff << " " 
-                 //    << setw(19) << uuu   << "  "  << setw(19) << gg << endl;
-              }
-
-typedef fmm * pfmm;
-
-/**
- * Description not yet available.
- * \param
- */
-dvector laplace_approximation_calculator::get_uhat_quasi_newton_block_diagonal
-  (const dvector& x,function_minimizer * pfmin)
-{
-
-  if (separable_function_difference)
-  {
-    delete separable_function_difference;
-    separable_function_difference=0;
-  }
-  separable_function_difference = new dvector(1,num_separable_calls);
-  
-  fmm ** pfmc1 = new pfmm[num_separable_calls];
-  pfmc1--;
-  int i;
-  ivector ishape(1,num_separable_calls);
-  dvector gmax(1,num_separable_calls);
-
-  for (i=1;i<=num_separable_calls;i++)
-  {
-    int m=(*derindex)(i).indexmax();
-    ishape(i)=m;
-    if (m>0)
-    {
-    pfmc1[i] = new fmm(m);
-    pfmc1[i]->iprint=0;
-    pfmc1[i]->crit=inner_crit;
-    pfmc1[i]->ireturn=0;
-    pfmc1[i]->itn=0;
-    pfmc1[i]->ifn=0;
-    pfmc1[i]->ialph=0;
-    pfmc1[i]->ihang=0;
-    pfmc1[i]->ihflag=0;
-    pfmc1[i]->maxfn=100;
-    pfmc1[i]->gmax=1.e+100;
-    pfmc1[i]->use_control_c=0;
-    }
-    else
-    {
-      pfmc1[i]= (fmm *)(0);
-    }
-  }
-  dmatrix gg(1,num_separable_calls,1,ishape);
-  dmatrix ggb(1,num_separable_calls,1,ishape);
-  dmatrix uu(1,num_separable_calls,1,ishape);
-  dmatrix uub(1,num_separable_calls,1,ishape);
-  dvector ff(1,num_separable_calls);
-  dvector ffb(1,num_separable_calls);
-  ivector icon(1,num_separable_calls);
-  icon.initialize();
-  ffb=1.e+100;
-
-  double f=0.0;
-  double fb=1.e+100;
-  dvector g(1,usize);
-  dvector ub(1,usize);
-  independent_variables u(1,usize);
-  gradcalc(0,g);
-  fmc1.itn=0;
-  fmc1.ifn=0;
-  fmc1.ireturn=0;
-  initial_params::xinit(u);    // get the initial values into the
-  fmc1.ialph=0;
-  fmc1.ihang=0;
-  fmc1.ihflag=0;
-  
-  if (init_switch)
-  {
-    u.initialize();
-  }
- 
-  for (int ii=1;ii<=2;ii++)
-  {
-    // get the initial u into the uu's
-    for (i=1;i<=num_separable_calls;i++)
-    {
-      int m=(*derindex)(i).indexmax();
-      for (int j=1;j<=m;j++)
-      {
-        uu(i,j)=u((*derindex)(i)(j));
-      }
-    }
-    fmc1.dfn=1.e-2;
-    dvariable pen=0.0;
-    int converged=0;
-    int initrun_flag=1;
-    int loop_counter=0;
-    int loop_flag=0;
-  
-    while (converged==0)
-    {
-      if (loop_flag) loop_counter++;
-      if (loop_counter>18)
-      {
-        cout << loop_counter;
-      }
-      if (!initrun_flag)
-      {
-        converged=1;
-      }
-      for (int i=1;i<=num_separable_calls;i++)
-      {
-        if (ishape(i)>0) //check to see if there are any active randoem effects
-        {               // in this function call
-          if (!icon(i))
-          {
-            independent_variables& uuu=*(independent_variables*)(&(uu(i)));
-            if (i==19)
-              crap(ff[i],uuu,gg[i]);
-            (pfmc1[i])->fmin(ff[i],uuu,gg(i));
-            if (i==19)
-              crap();
-            gmax(i)=fabs(pfmc1[i]->gmax);
-            if (!initrun_flag)
-            {
-              if (gmax(i)<1.e-4  || pfmc1[i]->ireturn<=0)
-              {
-                icon(i)=1;
-              }
-              else
-              {
-                converged=0;
-              }
-            }
-          }
-        }
-      }
-      initrun_flag=0;
-      for (int i2=1;i2<=num_separable_calls;i2++)
-      {
-        int m=(*derindex)(i2).indexmax();
-        for (int j=1;j<=m;j++)
-        {
-          u((*derindex)(i2)(j))=uu(i2,j);
-        }
-      }
-      // put the 
-      //if (fmc1.ireturn>0)
-      {
-        dvariable vf=0.0;
-        pen=initial_params::reset(dvar_vector(u));
-        *objective_function_value::pobjfun=0.0;
-  
-        //num_separable_calls=0;
-  
-        pmin->inner_opt_flag=1;
-        pfmin->AD_uf_inner();
-        pmin->inner_opt_flag=0;
-
-        if (saddlepointflag)
-        {
-          *objective_function_value::pobjfun*=-1.0;
-        }
-        if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
-        {
-          quadratic_prior::get_M_calculations();
-        }
-        vf+=*objective_function_value::pobjfun;
-       
-        objective_function_value::fun_without_pen=value(vf);
-        vf+=pen;
-          
-        gradcalc(usize,g);
-        for (int i=1;i<=num_separable_calls;i++)
-        {
-          int m=(*derindex)(i).indexmax();
-          for (int j=1;j<=m;j++)
-          {
-            gg(i,j)=g((*derindex)(i)(j));
-          }
-        }
-        {
-          ofstream ofs("l:/temp1.dat");
-          ofs << g.indexmax() << " " << setprecision(15) << g << endl;
-        }
-        if (saddlepointflag==2)
-        {
-          ff[1]=-(*separable_function_difference)(1);
-          for (int i=2;i<=num_separable_calls;i++)
-          {
-            ff[i]=-(*separable_function_difference)(i);
-            //ff[i]=-(*separable_function_difference)(i)
-             // +(*separable_function_difference)(i-1);
-  
-            if (ff[i] < ffb[i])
-            {
-              ffb[i]=ff[i];
-              uub[i]=uu[i];
-              ggb[i]=gg[i];
-            }
-          }
-        }
-        else
-        {
-          ff[1]=(*separable_function_difference)(1);
-          for (int i=2;i<=num_separable_calls;i++)
-          {
-            ff[i]=(*separable_function_difference)(i);
-            //ff[i]=(*separable_function_difference)(i)
-             // -(*separable_function_difference)(i-1);
-  
-            if (ff[i] < ffb[i])
-            {
-              ffb[i]=ff[i];
-              uub[i]=uu[i];
-              ggb[i]=gg[i];
-            }
-          }
-        }
-        f=0.0;
-        for (int i2=1;i2<=num_separable_calls;i2++)
-        {
-          f+=ff[i2];
-        }
-        if (f<fb) 
-        {
-          fb=f;
-          ub=u;
-        }
-      }
-      u=ub;
-    }
-    double tmax=max(gmax); 
-    cout <<  " inner maxg = " << tmax << endl; 
-  
-    if (tmax< 1.e-4) break;
-  }
-  fmc1.ireturn=0;
-  fmc1.fbest=fb;
-  gradient_structure::set_NO_DERIVATIVES();
-  //num_separable_calls=0;
-  pmin->inner_opt_flag=1;
-  pfmin->AD_uf_inner();
-  pmin->inner_opt_flag=0;
-  if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
-  {
-    quadratic_prior::get_M_calculations();
-  }
-  gradient_structure::set_YES_DERIVATIVES();
-  for (i=1;i<=num_separable_calls;i++)
-  {
-    if (pfmc1[i])
-    {
-      delete pfmc1[i];
-    }
-  }
-  pfmc1++;
-  delete [] pfmc1;
-  pfmc1 = 0;
-  return u;
-}
-#endif  // #if defined(USE_LAPLACE)
+/*
+ * $Id$
+ *
+ * Author: David Fournier
+ * Copyright (c) 2008-2011 Regents of the University of California 
+ */
+/**
+ * \file
+ * Description not yet available.
+ */
+#if defined(USE_LAPLACE)
+#  include <admodel.h>
+#  include <df1b2fun.h>
+#  include <adrndeff.h>
+        //int fcount =0;
+  static int no_stuff=0;
+              static void crap(void)
+              {
+              }
+              static void crap(double ff,dvector& uuu,dvector& gg)
+              {
+                //cout << setprecision(10) << setw(19) << ff << " " 
+                 //    << setw(19) << uuu   << "  "  << setw(19) << gg << endl;
+              }
+
+typedef fmm * pfmm;
+
+/**
+ * Description not yet available.
+ * \param
+ */
+dvector laplace_approximation_calculator::get_uhat_quasi_newton_block_diagonal
+  (const dvector& x,function_minimizer * pfmin)
+{
+
+  if (separable_function_difference)
+  {
+    delete separable_function_difference;
+    separable_function_difference=0;
+  }
+  separable_function_difference = new dvector(1,num_separable_calls);
+  
+  fmm ** pfmc1 = new pfmm[num_separable_calls];
+  pfmc1--;
+  int i;
+  ivector ishape(1,num_separable_calls);
+  dvector gmax(1,num_separable_calls);
+
+  for (i=1;i<=num_separable_calls;i++)
+  {
+    int m=(*derindex)(i).indexmax();
+    ishape(i)=m;
+    if (m>0)
+    {
+    pfmc1[i] = new fmm(m);
+    pfmc1[i]->iprint=0;
+    pfmc1[i]->crit=inner_crit;
+    pfmc1[i]->ireturn=0;
+    pfmc1[i]->itn=0;
+    pfmc1[i]->ifn=0;
+    pfmc1[i]->ialph=0;
+    pfmc1[i]->ihang=0;
+    pfmc1[i]->ihflag=0;
+    pfmc1[i]->maxfn=100;
+    pfmc1[i]->gmax=1.e+100;
+    pfmc1[i]->use_control_c=0;
+    }
+    else
+    {
+      pfmc1[i]= (fmm *)(0);
+    }
+  }
+  dmatrix gg(1,num_separable_calls,1,ishape);
+  dmatrix ggb(1,num_separable_calls,1,ishape);
+  dmatrix uu(1,num_separable_calls,1,ishape);
+  dmatrix uub(1,num_separable_calls,1,ishape);
+  dvector ff(1,num_separable_calls);
+  dvector ffb(1,num_separable_calls);
+  ivector icon(1,num_separable_calls);
+  icon.initialize();
+  ffb=1.e+100;
+
+  double f=0.0;
+  double fb=1.e+100;
+  dvector g(1,usize);
+  dvector ub(1,usize);
+  independent_variables u(1,usize);
+  gradcalc(0,g);
+  fmc1.itn=0;
+  fmc1.ifn=0;
+  fmc1.ireturn=0;
+  initial_params::xinit(u);    // get the initial values into the
+  fmc1.ialph=0;
+  fmc1.ihang=0;
+  fmc1.ihflag=0;
+  
+  if (init_switch)
+  {
+    u.initialize();
+  }
+ 
+  for (int ii=1;ii<=2;ii++)
+  {
+    // get the initial u into the uu's
+    for (i=1;i<=num_separable_calls;i++)
+    {
+      int m=(*derindex)(i).indexmax();
+      for (int j=1;j<=m;j++)
+      {
+        uu(i,j)=u((*derindex)(i)(j));
+      }
+    }
+    fmc1.dfn=1.e-2;
+    dvariable pen=0.0;
+    int converged=0;
+    int initrun_flag=1;
+    int loop_counter=0;
+    int loop_flag=0;
+  
+    while (converged==0)
+    {
+      if (loop_flag) loop_counter++;
+      if (loop_counter>18)
+      {
+        cout << loop_counter;
+      }
+      if (!initrun_flag)
+      {
+        converged=1;
+      }
+      for (int i=1;i<=num_separable_calls;i++)
+      {
+        if (ishape(i)>0) //check to see if there are any active randoem effects
+        {               // in this function call
+          if (!icon(i))
+          {
+            independent_variables& uuu=*(independent_variables*)(&(uu(i)));
+            if (i==19)
+              crap(ff[i],uuu,gg[i]);
+            (pfmc1[i])->fmin(ff[i],uuu,gg(i));
+            if (i==19)
+              crap();
+            gmax(i)=fabs(pfmc1[i]->gmax);
+            if (!initrun_flag)
+            {
+              if (gmax(i)<1.e-4  || pfmc1[i]->ireturn<=0)
+              {
+                icon(i)=1;
+              }
+              else
+              {
+                converged=0;
+              }
+            }
+          }
+        }
+      }
+      initrun_flag=0;
+      for (int i2=1;i2<=num_separable_calls;i2++)
+      {
+        int m=(*derindex)(i2).indexmax();
+        for (int j=1;j<=m;j++)
+        {
+          u((*derindex)(i2)(j))=uu(i2,j);
+        }
+      }
+      // put the 
+      //if (fmc1.ireturn>0)
+      {
+        dvariable vf=0.0;
+        pen=initial_params::reset(dvar_vector(u));
+        *objective_function_value::pobjfun=0.0;
+  
+        //num_separable_calls=0;
+  
+        pmin->inner_opt_flag=1;
+        pfmin->AD_uf_inner();
+
+        if (saddlepointflag)
+        {
+          *objective_function_value::pobjfun*=-1.0;
+        }
+        no_function_component_flag=1;
+       	quadratic_prior::matrix_mult_flag=1;
+        if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
+        {
+          quadratic_prior::get_M_calculations();
+        }
+       	quadratic_prior::matrix_mult_flag=0;
+        no_function_component_flag=0;
+        pmin->inner_opt_flag=0;
+
+        vf+=*objective_function_value::pobjfun;
+       
+        objective_function_value::fun_without_pen=value(vf);
+        vf+=pen;
+          
+        gradcalc(usize,g);
+        for (int i=1;i<=num_separable_calls;i++)
+        {
+          int m=(*derindex)(i).indexmax();
+          for (int j=1;j<=m;j++)
+          {
+            gg(i,j)=g((*derindex)(i)(j));
+          }
+        }
+        if (saddlepointflag==2)
+        {
+          ff[1]=-(*separable_function_difference)(1);
+          for (int i=2;i<=num_separable_calls;i++)
+          {
+            ff[i]=-(*separable_function_difference)(i);
+            //ff[i]=-(*separable_function_difference)(i)
+             // +(*separable_function_difference)(i-1);
+  
+            if (ff[i] < ffb[i])
+            {
+              ffb[i]=ff[i];
+              uub[i]=uu[i];
+              ggb[i]=gg[i];
+            }
+          }
+        }
+        else
+        {
+          ff[1]=(*separable_function_difference)(1);
+          for (int i=2;i<=num_separable_calls;i++)
+          {
+            ff[i]=(*separable_function_difference)(i);
+            //ff[i]=(*separable_function_difference)(i)
+             // -(*separable_function_difference)(i-1);
+  
+            if (ff[i] < ffb[i])
+            {
+              ffb[i]=ff[i];
+              uub[i]=uu[i];
+              ggb[i]=gg[i];
+            }
+          }
+        }
+        f=0.0;
+        for (int i2=1;i2<=num_separable_calls;i2++)
+        {
+          f+=ff[i2];
+        }
+        if (f<fb) 
+        {
+          fb=f;
+          ub=u;
+        }
+      }
+      u=ub;
+    }
+    double tmax=max(gmax); 
+    cout <<  " inner maxg = " << tmax << endl; 
+  
+    if (tmax< 1.e-4) break;
+  }
+  fmc1.ireturn=0;
+  fmc1.fbest=fb;
+  gradient_structure::set_NO_DERIVATIVES();
+  //num_separable_calls=0;
+  pmin->inner_opt_flag=1;
+  pfmin->AD_uf_inner();
+  pmin->inner_opt_flag=0;
+  if ( no_stuff==0 && quadratic_prior::get_num_quadratic_prior()>0)
+  {
+    quadratic_prior::get_M_calculations();
+  }
+  gradient_structure::set_YES_DERIVATIVES();
+  for (i=1;i<=num_separable_calls;i++)
+  {
+    if (pfmc1[i])
+    {
+      delete pfmc1[i];
+    }
+  }
+  pfmc1++;
+  delete [] pfmc1;
+  pfmc1 = 0;
+  return u;
+}
+#endif  // #if defined(USE_LAPLACE)
Index: df1b2-separable/df1b2qnm.cpp
===================================================================
--- df1b2-separable/df1b2qnm.cpp	(revision 682)
+++ df1b2-separable/df1b2qnm.cpp	(working copy)
@@ -8,15 +8,12 @@
  * \file
  * Description not yet available.
  */
-#include <sstream>
-using std::istringstream;
-
 #if defined(USE_LAPLACE)
 #  include <admodel.h>
 #  include <df1b2fun.h>
 #  include <adrndeff.h>
 //#include <vmon.h>
-static int no_stuff=0;
+extern int no_stuff;
 //static void xxxy(void) {}
 
 /**
@@ -175,7 +172,10 @@
           pre_userfunction();
           if ( no_stuff ==0 && quadratic_prior::get_num_quadratic_prior()>0)
           {
+            quadratic_prior::calc_matrix_flag=0;
+            quadratic_prior::matrix_mult_flag=1;
             quadratic_prior::get_M_calculations();
+            quadratic_prior::matrix_mult_flag=0;
           }
           vf+=*objective_function_value::pobjfun;
           f=value(vf);
Index: df1b2-separable/fquadpri.cpp
===================================================================
--- df1b2-separable/fquadpri.cpp	(revision 682)
+++ df1b2-separable/fquadpri.cpp	(working copy)
@@ -11,6 +11,9 @@
 static char unallocatederror[] = " Trying to access unallocated"
  " matrix in df1b2quadratic_prior";
 
+int quadratic_prior::sparse_flag=0;
+int quadratic_prior::calc_matrix_flag=0;
+int quadratic_prior::matrix_mult_flag=0;
  df1b2quadratic_prior * df1b2quadratic_prior::ptr[100]; // this should be a resizeable array
  int df1b2quadratic_prior::num_quadratic_prior=0;
  const int df1b2quadratic_prior::max_num_quadratic_prior=100;
@@ -87,17 +90,41 @@
     pu=0; 
     index=0;
     Lxu=0;
+    SCM=0;
+    DFSCM=0;
+    S_dfpMinv=0;
+    dfpMinv=0;
+    CM=0;
   } 
+
   df1b2quadratic_prior::~df1b2quadratic_prior(void)
   {
+    deallocate();
+    if (pu) delete pu;
+    pu=0; 
+  }
+  void df1b2quadratic_prior::deallocate(void)
+  {
     if (index) delete index; 
     index=0;
+    if (DFSCM) delete DFSCM;
+    DFSCM=0;
+    if (CM) delete SCM;
+    CM=0;
+    if (SCM) delete SCM;
+    SCM=0;
     if (Lxu) delete Lxu;
     Lxu=0;
     if (M) delete M;
     M=0; 
-    if (pu) delete pu;
-    pu=0; 
+    //if (pu) delete pu;
+    //pu=0; 
+    if (S_dfpMinv)
+      delete S_dfpMinv;
+    S_dfpMinv=0;
+    if (dfpMinv)
+      delete dfpMinv;
+    dfpMinv=0;
   } 
 
 
@@ -123,7 +150,7 @@
   void df1b2quadratic_prior::operator = (const df1b2matrix & M)
   { 
     quadratic_prior::in_qp_calculations=0; 
-    num_active_parameters=funnel_init_var::num_vars;
+    num_active_parameters=funnel_init_var::num_active_parameters;
     df1b2_gradlist::no_derivatives=1;
     dvector cu=value(*pu);
 
@@ -215,6 +242,110 @@
     df1b2_gradlist::no_derivatives=0;
   }
 
+  void df1b2quadratic_prior::operator = (const df1b2_compressed_triplet & _M)
+  { 
+    ADUNCONST(df1b2_compressed_triplet,M)
+    quadratic_prior::in_qp_calculations=0; 
+    num_active_parameters=funnel_init_var::num_active_parameters;
+    df1b2_gradlist::no_derivatives=1;
+    dvector cu=value(*pu);
+
+    if (laplace_approximation_calculator::where_are_we_flag==3) 
+    {
+      df1b2variable::noallocate=1;
+      df1b2vector v(1,M.get_n());
+      df1b2variable::noallocate=0;
+      switch (old_style_flag)
+      {
+      case 0:
+      case 1:
+        cerr << "Error -- no solve defined yet" << endl;
+        ad_exit(1);
+        //v = solve(M,cu);
+        break;
+      case 2:
+        v = M*cu;
+        break;
+      default:
+        cerr << "Illegal value for quadratic_prior::old_style_flag"
+             << endl;
+        ad_exit(1);
+      }
+      int mmin=v.indexmin();
+      int mmax=v.indexmax();
+
+      if (index)
+      {
+        if (index->indexmax() != num_active_parameters)
+        delete index;
+        index=0;
+      }
+  
+      if (num_active_parameters>0)
+      {
+        if (!index)
+        {
+          index=new ivector(column(*funnel_init_var::plist,1));
+        }
+      
+        if (Lxu)
+        {
+          int tmin = Lxu->indexmin();
+          if ( (Lxu->indexmin() != mmin)    ||
+               (Lxu->indexmax() != mmax) ||
+               ((*Lxu)(tmin).indexmin() != 1) ||
+               ((*Lxu)(tmin).indexmax() != num_active_parameters)) 
+          delete Lxu;
+          Lxu=0;
+        }
+        if (!Lxu)
+        {
+          Lxu=new dmatrix(1,num_active_parameters,mmin-1,mmax);
+        }
+    
+        for (int i=1;i<=num_active_parameters;i++)
+        {
+          (*Lxu)(i,mmin-1)=(*funnel_init_var::plist)(i,1);
+        }
+        for (int j=mmin;j<=mmax;j++)
+        {
+          for (int i=1;i<=num_active_parameters;i++)
+          {
+            switch (old_style_flag)
+            {
+              cerr << "Illegal value for quadratic_prior::old_style_flag"
+                   << endl;
+              ad_exit(1);
+            case 0:
+              (*Lxu)(i,j)=v(j).get_u_dot()[i-1];
+              break;
+            case 1:
+              cerr << "Illegal value for quadratic_prior::old_style_flag"
+                   << endl;
+              ad_exit(1);
+            case 2:
+              (*Lxu)(i,j)=v(j).get_u_dot()[i-1];
+              break;
+            default:
+              cerr << "Illegal value for quadratic_prior::old_style_flag"
+                   << endl;
+              ad_exit(1);
+            }
+          }
+        } 
+      }
+      else
+      {
+        if (Lxu)
+        {
+          delete Lxu;
+          Lxu=0;
+        }
+      }
+    }
+    df1b2_gradlist::no_derivatives=0;
+  }
+
  void df1b2quadratic_prior::get_Lxu_contribution(dmatrix& M)
  {
    for (int i=0;i<num_quadratic_prior;i++)
@@ -227,6 +358,17 @@
    }
  }
 
+ void df1b2quadratic_prior::cleanup(void)
+ {
+   for (int i=0;i<num_quadratic_prior;i++)
+   {
+     if (ptr[i])
+     {
+       ptr[i]->deallocate();
+     }
+   }
+ }
+
 normal_df1b2quadratic_prior::normal_df1b2quadratic_prior(void) 
 { 
   set_old_style_flag();
@@ -245,6 +387,10 @@
 {
   old_style_flag=2;
 }
+void df1b2quadratic_re_penalty::operator = (const df1b2_compressed_triplet & M) 
+{ 
+  df1b2quadratic_prior::operator = (M);
+}
 void df1b2quadratic_re_penalty::operator = (const df1b2matrix & M) 
 { 
   df1b2quadratic_prior::operator = (M);
Index: df1b2-separable/objects.lst
===================================================================
--- df1b2-separable/objects.lst	(revision 682)
+++ df1b2-separable/objects.lst	(working copy)
@@ -1,4 +1,5 @@
 OBJ0 = \
+df1b2compressed.obj \
 df1b2impspf.obj \
 df1b2lmn2.obj \
 dflogistic.obj \
Index: df1b2-separable/quadpri.cpp
===================================================================
--- df1b2-separable/quadpri.cpp	(revision 682)
+++ df1b2-separable/quadpri.cpp	(working copy)
@@ -2,7 +2,7 @@
  * $Id$
  *
  * Author: David Fournier
- * Copyright (c) 2008-2012 Regents of the University of California 
+ * Copyright (c) 2008-2011 Regents of the University of California 
  */
 /**
  * \file
@@ -17,6 +17,11 @@
 int quadratic_prior::num_quadratic_prior=0;
 const int quadratic_prior::max_num_quadratic_prior=100;
 
+static void NOT_IMPLEMENTED(void)
+{
+  cerr << "not implemented" << endl;
+  ad_exit(1);
+}
 /**
  * Description not yet available.
  * \param
@@ -32,6 +37,17 @@
    }
  }
 
+ void quadratic_prior::cleanup(void)
+ {
+   for (int i=0;i<num_quadratic_prior;i++)
+   {
+     if (ptr[i])
+     {
+       ptr[i]->deallocate();
+     }
+   }
+ }
+
 /**
  * Description not yet available.
  * \param
@@ -48,11 +64,40 @@
   dvariable vf=0.0;
   initial_params::reset(dvar_vector(u));
   //vf=0.0;
-  dvar_matrix Hess_all(1,usize,1,usize);
+  dvar_matrix Hess_all;
+  dvar_compressed_triplet S_Hess_all;
+
+  if (pfmin->lapprox->sparse_hessian_flag==0)
+  {
+    if (allocated(Hess_all))
+      Hess_all.deallocate();
+
+    Hess_all.allocate(1,usize,1,usize);
+  }
+  else
+  {
+    if (pfmin->lapprox->sparse_triplet2==0)
+    {
+      cerr << "need to deal with 0 ptr here" << endl;
+      ad_exit(1);
+    }
+    int us=pfmin->lapprox->sparse_triplet2->get_n();
+    int mmin=pfmin->lapprox->sparse_triplet2->indexmin();
+    int mmax=pfmin->lapprox->sparse_triplet2->indexmax();
+    if (allocated(S_Hess_all))
+      S_Hess_all.deallocate();
+
+    S_Hess_all.allocate(mmin,mmax,us,us);
+
+  }
+  
+ 
   *objective_function_value::pobjfun=0.0;
   // so that dvar_matrix Hessian contributions are calculated
   laplace_approximation_calculator::where_are_we_flag=3; 
-  pfmin->AD_uf_inner();
+  cout << "need to fix this" << endl;
+  sleep(1);
+  //pfmin->AD_uf_inner();
   if ( quadratic_prior::get_num_quadratic_prior()>0)
   {
     quadratic_prior::get_M_calculations();
@@ -60,22 +105,97 @@
   laplace_approximation_calculator::where_are_we_flag=0; 
 
   *objective_function_value::pobjfun=0.0;
-  Hess_all=pfmin->lapprox->Hess;
+  if (pfmin->lapprox->sparse_hessian_flag==0)
+  {
+    Hess_all=pfmin->lapprox->Hess;
+  }
+  else
+  {
+    S_Hess_all=*(pfmin->lapprox->sparse_triplet2);
+
+  }
   for (int i=0;i<quadratic_prior::get_num_quadratic_prior();i++)
   {
     //Hess_all += quadratic_prior::get_ptr(i)->get_vHessian();
     int nv=df1b2quadratic_prior::get_ptr(i)->get_num_active_parameters();
-    if (nv>0)
-      quadratic_prior::get_ptr(i)->get_vHessian(Hess_all,xsize);
+    if (pfmin->lapprox->sparse_hessian_flag==0)
+    {
+      if (nv>0)
+        quadratic_prior::get_ptr(i)->get_vHessian(Hess_all,xsize);
+      else
+        quadratic_prior::get_ptr(i)->get_cHessian(Hess_all,xsize);
+    }
     else
-      quadratic_prior::get_ptr(i)->get_cHessian(Hess_all,xsize);
+    {
+      if (nv>0)
+      {
+        quadratic_prior::get_ptr(i)->get_vHessian(S_Hess_all,xsize,
+          *pfmin->lapprox->sparse_iterator,
+          pfmin->lapprox->sparse_count);
+      }
+      else
+      {
+        NOT_IMPLEMENTED();
+        //quadratic_prior::get_ptr(i)->get_cHessian(Hess_all,xsize);
+      }
+    }
   }
   int sgn;
-  vf=0.5*ln_det(Hess_all,sgn);
+  if (pfmin->lapprox->sparse_hessian_flag==0)
+  {
+    vf=0.5*ln_det(Hess_all,sgn);
+  }
+  else
+  {
+    //dvariable ln_det(dvar_compressed_triplet& VM,hs_symbolic& S)
+    if (pfmin->lapprox->sparse_symbolic2==0)
+    {
+      NOT_IMPLEMENTED();
+    }
+    //dvar_matrix tmp=make_sdvar_matrix(S_Hess_all);
+    //vf=0.5*ln_det_choleski_error(tmp,sgn);
+
+    hs_symbolic & ssymb=*(pfmin->lapprox->sparse_symbolic2);
+    vf=0.5*ln_det(S_Hess_all,ssymb,*(pfmin->lapprox->sparse_triplet2));
+  }
   gradcalc(xsize,g);
   return g;
 }
+dvector evaluate_quadprior(const dvector& x,int usize,
+  function_minimizer * pfmin)
+{
+  int xsize=initial_params::nvarcalc(); 
+  dvector g(1,xsize);
+  gradcalc(0,g);
+  //double f=0.0;
+  independent_variables u(1,xsize);
+  u=x;
+  dvariable vf=0.0;
+  initial_params::reset(dvar_vector(u));
 
+  if (pfmin->lapprox->sparse_hessian_flag &&
+    pfmin->lapprox->sparse_triplet2==0)
+  {
+    cerr << "need to deal with 0 ptr here" << endl;
+    ad_exit(1);
+  }
+  *objective_function_value::pobjfun=0.0;
+  // so that dvar_matrix Hessian contributions are calculated
+  laplace_approximation_calculator::where_are_we_flag=3; 
+  if ( quadratic_prior::get_num_quadratic_prior()>0)
+  {
+    quadratic_prior::calc_matrix_flag=1;
+    quadratic_prior::matrix_mult_flag=1;
+    quadratic_prior::get_M_calculations();
+    quadratic_prior::matrix_mult_flag=0;
+    quadratic_prior::calc_matrix_flag=0;
+  }
+  laplace_approximation_calculator::where_are_we_flag=0; 
+  vf=*objective_function_value::pobjfun;
+  gradcalc(xsize,g);
+  return g;
+}
+
 /**
  * Description not yet available.
  * \param
@@ -304,6 +424,84 @@
       }
     }
   }
+
+  void quadratic_prior::get_vHessian(const dvar_compressed_triplet& _H,
+    int xsize,ivector& sparse_iterator,int& sparse_count)
+  { 
+    ADUNCONST(dvar_compressed_triplet,H) 
+    int offset=get_offset(xsize);
+    if (S_dfpMinv==0)
+    {
+      cerr << "This can't happen" << endl;
+      ad_exit(1);
+    }
+    if (offset==0)
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        NOT_IMPLEMENTED();
+        /*
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=(*dfpMinv)(i,j);
+        break;
+        */
+      case 1:
+        NOT_IMPLEMENTED();
+        /*
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*(*dfpMinv)(i,j);
+        break;
+        */
+      case 2:
+        {
+          int imin=S_dfpMinv->indexmin();
+          int imax=S_dfpMinv->indexmax();
+          for (i=imin;i<=imax;i++)
+          {
+            sparse_count++;
+            H.get_x()(sparse_iterator(sparse_count))+=S_dfpMinv->get_x()(i);
+            //H(i)+=(*S_dfpMinv)(i);
+          }
+          break;
+        }
+      default:
+         cerr << "Illegal valueinswitch statement" << endl;
+         ad_exit(1);
+      }
+    }
+    else
+    {
+      NOT_IMPLEMENTED();
+      /*
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=(*dfpMinv)(i,j);
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*(*dfpMinv)(i,j);
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*(*dfpMinv)(i,j);
+         break;
+      default:
+         cerr << "Illegal valueinswitch statement" << endl;
+         ad_exit(1);
+      }
+    */
+    }
+  }
  /*
   dvar_matrix quadratic_prior::get_vHessian(void) 
   { 
@@ -391,52 +589,62 @@
   void quadratic_prior::get_cgradient(dvector g,int xs) 
   { 
     int offset=get_offset(xs);
-    dvector tg=((*pMinv)*value(*pu));
-    int imin=pMinv->indexmin();
-    int imax=pMinv->indexmax();
-    if (offset==0)
+    if (SCM==0)
     {
-      int i;
-      switch(old_style_flag)
+      dvector tg=((*pMinv)*value(*pu));
+      int imin=pMinv->indexmin();
+      int imax=pMinv->indexmax();
+      if (offset==0)
       {
-      case 0:
-        for (i=imin;i<=imax;i++)
-          g(i)+=tg(i);
-        break;
-      case 1:
-        for (i=imin;i<=imax;i++)
-          g(i)+=2.0*tg(i);
-        break;
-      case 2:
-        for (i=imin;i<=imax;i++)
-          g(i)+=2.0*tg(i);
-        break;
-      default:
-        cerr << "Illegal valueinswitch statement" << endl;
-        ad_exit(1);
+        int i;
+        switch(old_style_flag)
+        {
+        case 0:
+          for (i=imin;i<=imax;i++)
+            g(i)+=tg(i);
+          break;
+        case 1:
+          for (i=imin;i<=imax;i++)
+            g(i)+=2.0*tg(i);
+          break;
+        case 2:
+          for (i=imin;i<=imax;i++)
+            g(i)+=2.0*tg(i);
+          break;
+        default:
+          cerr << "Illegal valueinswitch statement" << endl;
+          ad_exit(1);
+        }
       }
+      else
+      {
+        int i;
+        switch(old_style_flag)
+        {
+        case 0:
+          for (i=imin;i<=imax;i++)
+            g(offset+i)+=tg(i);
+          break;
+        case 1:
+          for (i=imin;i<=imax;i++)
+            g(offset+i)+=2.0*tg(i);
+          break;
+        case 2:
+          for (i=imin;i<=imax;i++)
+            g(offset+i)+=2.0*tg(i);
+          break;
+        default:
+          cerr << "Illegal valueinswitch statement" << endl;
+          ad_exit(1);
+        }
+      }
     }
     else
     {
-      int i;
-      switch(old_style_flag)
-      {
-      case 0:
-        for (i=imin;i<=imax;i++)
-          g(offset+i)+=tg(i);
-        break;
-      case 1:
-        for (i=imin;i<=imax;i++)
-          g(offset+i)+=2.0*tg(i);
-        break;
-      case 2:
-        for (i=imin;i<=imax;i++)
-          g(offset+i)+=2.0*tg(i);
-        break;
-      default:
-        cerr << "Illegal valueinswitch statement" << endl;
-        ad_exit(1);
-      }
+      dvector tg=((*SCM)*value(*pu));
+      int imin=tg.indexmin();
+      int imax=tg.indexmax();
+      g(offset+1,tg.indexmax()).shift(1)+=tg;
     }
     //return ((*pMinv)*value(*pu));
   }
@@ -447,9 +655,18 @@
  */
   quadratic_prior::quadratic_prior(void)
   {
+    LU=0;
+    CM=0;
+    SCM=0;
+    DFSCM=0;
+    SCMinv=0;
     pMinv=0; 
     dfpMinv=0; 
+    indx=0;
+    sgn=0;
+    S_dfpMinv=0; 
     pu=0; 
+    pM=0; 
     add_to_list();
   } 
 
@@ -459,12 +676,35 @@
  */
   quadratic_prior::~quadratic_prior(void)
   {
+    deallocate();
+    if (pu) delete pu;
+    pu=0; 
+  }
+
+  void quadratic_prior::deallocate(void)
+  {
+    if (SCMinv) delete SCMinv;
+    SCMinv=0; 
+    if (DFSCM) delete DFSCM;
+    DFSCM=0; 
+    if (LU) delete LU;
+    LU=0; 
+    if (SCM) delete SCM;
+    SCM=0; 
+    if (pM) delete pM;
+    pM=0; 
     if (pMinv) delete pMinv;
     pMinv=0; 
     if (pu) delete pu;
     pu=0; 
-    if (dfpMinv) delete pMinv;
+    if (S_dfpMinv) delete S_dfpMinv;
+    S_dfpMinv=0; 
+    if (dfpMinv) delete dfpMinv;
     dfpMinv=0; 
+    if (indx) delete indx;
+    indx=0;
+    if (CM) delete CM;
+    CM=0;
   } 
 
 /**
@@ -489,6 +729,9 @@
       ad_exit(1);
     }
     pu = new dvar_vector((dvar_vector&)(_u));
+    if (indx)
+     delete indx;
+    indx=new ivector(_u.indexmin(),_u.indexmax());
   }
 
 /**
@@ -573,13 +816,13 @@
          " quadratic_prior::get_cHessian_contribution" << endl;
        ad_exit(1);
      }
-     if (!ptr[i]->pMinv)
+     if (!ptr[i]->pMinv && !ptr[i]->SCMinv)
      {
        cerr << "ptr["<<i<<"]->pMinv = 0 in" 
          " quadratic_prior::get_cHessian_contribution" << endl;
        ad_exit(1);
      }
-     if (!allocated(*(ptr[i]->pMinv)))
+     if (!allocated(*(ptr[i]->pMinv))&& !allocated(*(ptr[i]->pMinv)))
      {
        cerr << "*ptr["<<i<<"] is unallocated in" 
          " quadratic_prior::get_cHessian_contribution" << endl;
@@ -599,7 +842,38 @@
    }
    //return f;
  }
+ 
+ void quadratic_prior::get_cHessian_contribution(dcompressed_triplet * dct ,
+   int xsize,ivector& sparse_iterator,int & sparse_count)
+ {
+   int nqp=get_num_quadratic_prior();
+   for (int i=0;i<nqp;i++)
+   {
+     /*
+     if (!ptr[i])
+     {
+       cerr << "ptr["<<i<<"] = 0 in" 
+         " quadratic_prior::get_cHessian_contribution" << endl;
+       ad_exit(1);
+     }
+     if (!ptr[i]->pMinv && !ptr[i]->SCMinv)
+     {
+       cerr << "ptr["<<i<<"]->pMinv = 0 in" 
+         " quadratic_prior::get_cHessian_contribution" << endl;
+       ad_exit(1);
+     }
+     if (!allocated(*(ptr[i]->pMinv))&& !allocated(*(ptr[i]->pMinv)))
+     {
+       cerr << "*ptr["<<i<<"] is unallocated in" 
+         " quadratic_prior::get_cHessian_contribution" << endl;
+       ad_exit(1);
+     }
+     */
+     ptr[i]->get_cHessian(dct,xsize,sparse_iterator,sparse_count);
+   }
+ }
 
+
 /**
  * Description not yet available.
  * \param
@@ -637,6 +911,29 @@
  * Description not yet available.
  * \param
  */
+ void quadratic_prior::get_cHessian_contribution_from_vHessian(
+   dcompressed_triplet * dct,int xsize,ivector& sparse_iterator,
+   int & sparse_count)
+ {
+   for (int i=0;i<num_quadratic_prior;i++)
+   {
+     int nv=df1b2quadratic_prior::get_ptr(i)->
+       get_num_active_parameters();
+     if (nv)
+     {
+       ptr[i]->get_cHessian_from_vHessian(dct,xsize,
+        sparse_iterator,sparse_count);
+     }
+     else
+     {
+       ptr[i]->get_cHessian_from_vHessian(dct,xsize,
+        sparse_iterator,sparse_count);
+       // NOT_IMPLEMENTED();
+       //  ptr[i]->get_cHessian(Hess,xsize);
+     }
+   }
+ }
+
  void quadratic_prior::get_cHessian_contribution_from_vHessian(dmatrix Hess,int xsize)
  {
    for (int i=0;i<num_quadratic_prior;i++)
@@ -657,17 +954,21 @@
  */
  void quadratic_prior::operator = (const dvar_matrix & _M)
  { 
-   dvariable lndet;
-   dvariable sgn;
+   dvariable vlndet;
+   dvariable vsgn;
    
    switch (quadratic_prior::old_style_flag)
    {
    case 0:
-     *objective_function_value::pobjfun+=0.5*(*pu)*(solve(_M,*pu,lndet,sgn));
-     *objective_function_value::pobjfun+=0.5*lndet;
-     //*objective_function_value::pobjfun+=0.5*(*pu)*(solve(_M,*pu));
-     //*objective_function_value::pobjfun+=0.5*ln_det(_M);
-     break;
+     {
+       /* XXXXXXXXXXXXXXXXXXXXX */
+       *objective_function_value::pobjfun
+         +=0.5*(*pu)*(solve(_M,*pu,vlndet,vsgn));
+       *objective_function_value::pobjfun+=0.5*vlndet;
+       //*objective_function_value::pobjfun+=0.5*(*pu)*(solve(_M,*pu));
+       //*objective_function_value::pobjfun+=0.5*ln_det(_M);
+       break;
+     }
    case 1:
      *objective_function_value::pobjfun+=(*pu)*(solve(_M,*pu));
      break;
@@ -753,22 +1054,299 @@
    }
  }
 
-/**
- * Description not yet available.
- * \param
- */
- void quadratic_prior::operator = (const dmatrix & _M)
+ void quadratic_prior::operator = (const dvar_compressed_triplet & _M)
  { 
+   ADUNCONST(dvar_compressed_triplet,M)
    dvariable lndet;
    dvariable sgn;
+   
+   switch (quadratic_prior::old_style_flag)
+   {
+   case 0:
+        NOT_IMPLEMENTED();
+     //*objective_function_value::pobjfun+=0.5*(*pu)*(solve(_M,*pu,lndet,sgn));
+     //*objective_function_value::pobjfun+=0.5*lndet;
+     //*objective_function_value::pobjfun+=0.5*(*pu)*(solve(_M,*pu));
+     //*objective_function_value::pobjfun+=0.5*ln_det(_M);
+     break;
+   case 1:
+        NOT_IMPLEMENTED();
+     //*objective_function_value::pobjfun+=(*pu)*(solve(_M,*pu));
+     break;
+   case 2:
+     *objective_function_value::pobjfun+=0.5*(*pu) * ( M * (*pu) );
+     break;
+   default:
+     cerr << "Illegal value for quadratic_prior::old_style_flag"
+          << endl;
+     ad_exit(1);
+   }
+   if (pMinv) 
+   {
+     delete pMinv;
+     pMinv=0;
+   }
+   if (dfpMinv) 
+   {
+     delete dfpMinv;
+     dfpMinv=0;
+   }
+   switch (quadratic_prior::old_style_flag)
+   {
+   case 0:
+   case 1:
+        NOT_IMPLEMENTED();
+    /*
+     if (laplace_approximation_calculator::where_are_we_flag==2) 
+     {
+       pMinv = new dmatrix(inv(value(_M)));
+       if (pMinv==0)
+       {
+         cerr << "Error allocating dmatrix" << endl;
+         ad_exit(1);
+       }
+     }
+     if (laplace_approximation_calculator::where_are_we_flag==3) 
+     {
+       dfpMinv = new dvar_matrix(inv(_M));
+       if (dfpMinv==0)
+       {
+         cerr << "Error allocating dvar_matrix" << endl;
+         ad_exit(1);
+       }
+     }
+    */
+     break;
+   case 2:
+     if (laplace_approximation_calculator::where_are_we_flag==2) 
+     {
+       break;
+        NOT_IMPLEMENTED();
+      /*
+       pMinv = new dmatrix(value(_M));
+       if (pMinv==0)
+       {
+         cerr << "Error allocating dmatrix" << endl;
+         ad_exit(1);
+       }
+      */
+     }
+     if (laplace_approximation_calculator::where_are_we_flag==3) 
+     {
+       int nv=
+         df1b2quadratic_prior::get_ptr(xmyindex)->get_num_active_parameters();
 
+       if (nv!=0)
+       {
+         if (S_dfpMinv)
+         {
+           delete S_dfpMinv;
+           S_dfpMinv=0;
+         }
+         S_dfpMinv = new dvar_compressed_triplet(_M);
+         if (S_dfpMinv==0)
+         {
+           cerr << "Error allocating dvar_compressed_matrix" << endl;
+           ad_exit(1);
+         }
+       }
+       else
+       {
+        break;
+        NOT_IMPLEMENTED();
+         /*
+         pMinv = new dmatrix(value(_M));
+         if (pMinv==0)
+         {
+           cerr << "Error allocating dmatrix" << endl;
+           ad_exit(1);
+         }
+         */
+       }
+     }
+     break;
+   default:
+     cerr << "Illegal value for quadratic_prior::old_style_flag"
+          << endl;
+     ad_exit(1);
+   }
+ }
+
+
+ static void quad_prod(void)
+ {
+   verify_identifier_string("P2");
+   dvar_vector_position u_pos=restore_dvar_vector_position();
+   verify_identifier_string("P3");
+   dvector_position v_pos=restore_dvector_position();
+   dvector v=restore_dvector_value(v_pos);
+   verify_identifier_string("P4");
+   dvector dftmp=v;
+   dftmp.save_dvector_derivatives(u_pos);
+ }
+
+ void quadratic_prior::operator = (const dcompressed_triplet & _CM)
+ { 
+   dvariable lndet;
+   dvariable sgn;
+   ADUNCONST(dcompressed_triplet,CM)
    
    switch (quadratic_prior::old_style_flag)
    {
    case 0:
-     cerr << " can't get here " << endl;
+     {
+       dvector v = solve(CM,value(*pu));
+       *objective_function_value::pobjfun+=0.5*(*pu)*v;
+
+     }
+     //*objective_function_value::pobjfun+=0.5*lndet;
+     //*objective_function_value::pobjfun+=0.5*(*pu)*(solve(_M,*pu));
+     //*objective_function_value::pobjfun+=0.5*ln_det(_M);
+     break;
+  /*
+   case 1:
+     *objective_function_value::pobjfun+=(*pu)*(solve(_M,*pu));
+     break;
+   */
+
+   case 2:
+   {
+     dvector v= CM*value(*pu);
+     double vv=0.5*value(*pu) * v;
+     *objective_function_value::pobjfun+=vv;
+     save_identifier_string("P4");
+     v.save_dvector_value();
+     v.save_dvector_position();
+     save_identifier_string("P3");
+     pu->save_dvar_vector_position();
+     save_identifier_string("P2");
+     gradient_structure::GRAD_STACK1->set_gradient_stack(quad_prod);
+     break;
+   }
+   default:
+     cerr << "Illegal value for quadratic_prior::old_style_flag"
+          << endl;
      ad_exit(1);
+   }
+   if (pMinv) 
+   {
+     delete pMinv;
+     pMinv=0;
+   }
+   if (dfpMinv) 
+   {
+     delete dfpMinv;
+     dfpMinv=0;
+   }
+   if (SCMinv) 
+   {
+     delete SCMinv;
+     SCMinv=0;
+   }
+   switch (quadratic_prior::old_style_flag)
+   {
+   case 0:
+   case 1:
+     if (laplace_approximation_calculator::where_are_we_flag==2) 
+     {
+       //pMinv = new dmatrix(inv(value(_M)));
+       if (pMinv==0)
+       {
+         cerr << "Error allocating dmatrix" << endl;
+         ad_exit(1);
+       }
+     }
+     if (laplace_approximation_calculator::where_are_we_flag==3) 
+     {
+       //dfpMinv = new dvar_matrix(inv(_M));
+       if (dfpMinv==0)
+       {
+         cerr << "Error allocating dvar_matrix" << endl;
+         ad_exit(1);
+       }
+     }
      break;
+   case 2:
+     if (laplace_approximation_calculator::where_are_we_flag==2) 
+     {
+       /*
+       pMinv = new dmatrix(value(_M));
+       if (pMinv==0)
+       {
+         cerr << "Error allocating dmatrix" << endl;
+         ad_exit(1);
+       }
+       */
+       SCMinv= new dcompressed_triplet(CM);
+       if (SCMinv==0)
+       {
+         cerr << "Error allocating dcompressed_triplet" << endl;
+         ad_exit(1);
+       }
+     }
+     if (laplace_approximation_calculator::where_are_we_flag==3) 
+     {
+       cout << "what do we do here? " << endl;
+       /*
+       int nv=df1b2quadratic_prior::get_ptr(xmyindex)->get_num_active_parameters();
+       if (nv!=0)
+       {
+         //dfpMinv = new dvar_matrix(_M);
+         if (dfpMinv==0)
+         {
+           cerr << "Error allocating dvar_matrix" << endl;
+           ad_exit(1);
+         }
+       }
+       else
+       {
+         //pMinv = new dmatrix(value(_M));
+         if (pMinv==0)
+         {
+           cerr << "Error allocating dmatrix" << endl;
+           ad_exit(1);
+         }
+       }
+       */
+     }
+     break;
+   default:
+     cerr << "Illegal value for quadratic_prior::old_style_flag"
+          << endl;
+     ad_exit(1);
+   }
+ }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+ void quadratic_prior::operator = (const dmatrix & _M)
+ { 
+   switch (quadratic_prior::old_style_flag)
+   {
+   case 0:
+     {
+       /* XXXXXXXXXXXXXXXXXXXXX */
+       if (indx==0)
+         indx=new ivector(pu->indexmin(),pu->indexmax());
+
+       dvector ccu=value(*pu);
+       dvector v=Lubksb(_M,*indx,ccu);
+       double vv=0.5*ccu * v;
+       *objective_function_value::pobjfun+=vv;
+       save_identifier_string("P4");
+       v.save_dvector_value();
+       v.save_dvector_position();
+       save_identifier_string("P3");
+       pu->save_dvar_vector_position();
+       save_identifier_string("P2");
+       gradient_structure::GRAD_STACK1->set_gradient_stack(quad_prod);
+       //*objective_function_value::pobjfun+=0.5*(*pu)*solve(_M,*pu,lndet,sgn);
+       //*objective_function_value::pobjfun+=0.5*lndet;
+       break;
+     }
+     break;
    case 1:
      cerr << " can't get here " << endl;
      ad_exit(1);
@@ -795,8 +1373,17 @@
    {
    case 0:
    case 1:
-     cerr << " can't get here " << endl;
-     ad_exit(1);
+     if (laplace_approximation_calculator::where_are_we_flag==2 ||
+       laplace_approximation_calculator::where_are_we_flag==3) 
+     {
+       pMinv = new dmatrix(inv_with_lu(_M,*indx,d));
+       if (pMinv==0)
+       {
+         cerr << "Error allocating dmatrix" << endl;
+         ad_exit(1);
+       }
+     }
+
      break;
    case 2:
      if (laplace_approximation_calculator::where_are_we_flag==2 ||
@@ -906,3 +1493,1191 @@
 { 
   quadratic_prior::operator = (M);
 }
+//****************************************************************
+//****************************************************************
+//****************************************************************
+//****************************************************************
+/*
+ * $Id$
+ *
+ * Author: David Fournier
+ * Copyright (c) 2008-2011 Regents of the University of California 
+ */
+/**
+ * \file
+ * Description not yet available.
+ */
+#include <df1b2fnl.h>
+//#include <df1b2fun.h>
+
+int sparse_quadratic_prior::in_qp_calculations=0; 
+
+sparse_quadratic_prior * sparse_quadratic_prior::ptr[100]; // this should be a resizeable array
+int sparse_quadratic_prior::num_sparse_quadratic_prior=0;
+const int sparse_quadratic_prior::max_num_sparse_quadratic_prior=100;
+
+/**
+ * Description not yet available.
+ * \param
+ */
+ void sparse_quadratic_prior::get_M_calculations(void)
+ {
+   for (int i=0;i<num_sparse_quadratic_prior;i++)
+   {
+     //if (ptr[i]->get_num_active_parameters()>0)
+     {
+       ptr[i]->get_cM();
+     }
+   }
+ }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+/*
+dvector evaluate_function_with_quadprior(const dvector& x,int usize,
+  function_minimizer * pfmin)
+{
+  int xsize=initial_params::nvarcalc(); 
+  dvector g(1,xsize);
+  gradcalc(0,g);
+  //double f=0.0;
+  independent_variables u(1,xsize);
+  u=x;
+  dvariable vf=0.0;
+  initial_params::reset(dvar_vector(u));
+  //vf=0.0;
+  dvar_matrix Hess_all(1,usize,1,usize);
+  *objective_function_value::pobjfun=0.0;
+  // so that dvar_matrix Hessian contributions are calculated
+  laplace_approximation_calculator::where_are_we_flag=3; 
+  pfmin->AD_uf_inner();
+  if ( sparse_quadratic_prior::get_num_sparse_quadratic_prior()>0)
+  {
+    sparse_quadratic_prior::get_M_calculations();
+  }
+  laplace_approximation_calculator::where_are_we_flag=0; 
+
+  *objective_function_value::pobjfun=0.0;
+  Hess_all=pfmin->lapprox->Hess;
+  for (int i=0;i<sparse_quadratic_prior::get_num_sparse_quadratic_prior();i++)
+  {
+    //Hess_all += sparse_quadratic_prior::get_ptr(i)->get_vHessian();
+    int nv=df1b2sparse_quadratic_prior::get_ptr(i)->get_num_active_parameters();
+    if (nv>0)
+      sparse_quadratic_prior::get_ptr(i)->get_vHessian(Hess_all,xsize);
+    else
+      sparse_quadratic_prior::get_ptr(i)->get_cHessian(Hess_all,xsize);
+  }
+  int sgn;
+  vf=0.5*ln_det(Hess_all,sgn);
+  gradcalc(xsize,g);
+  return g;
+}
+*/
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::add_to_list(void)
+  {
+    if (num_sparse_quadratic_prior>=max_num_sparse_quadratic_prior) ad_exit(1);
+    xmyindex=num_sparse_quadratic_prior;
+    ptr[num_sparse_quadratic_prior++]=this;
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  dvariable sparse_quadratic_prior::get_function(void) 
+  { 
+    return (*pu)*((*pMinv)*(*pu));
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  dvar_matrix sparse_quadratic_prior::get_Hessian(void) 
+  { 
+    return *pMinv;
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+
+  int sparse_quadratic_prior::get_offset(int xs)
+  {
+    //df1b2_init_vector * fpu=df1b2sparse_quadratic_prior::ptr[get_myindex()]->pu;
+    cerr << "Need to fix this" << endl;
+    ad_exit(1);
+    df1b2_init_vector * fpu=0;
+    int mmin=(*fpu)(fpu->indexmin()).get_ind_index();
+    return mmin-xs-1;
+  }
+  //dmatrix sparse_quadratic_prior::get_cHessian(void) 
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::get_cHessian(dmatrix H,int xsize) 
+  { 
+    int offset=get_offset(xsize);
+    int imin=pMinv->indexmin();
+    int imax=pMinv->indexmax();
+    if (offset==0)
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=(*pMinv)(i,j);
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*(*pMinv)(i,j);
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*(*pMinv)(i,j);
+         break;
+      default:
+         cerr << "Illegal value in switch statement" << endl;
+         ad_exit(1);
+      }
+    }
+    else
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=(*pMinv)(i,j);
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*(*pMinv)(i,j);
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*(*pMinv)(i,j);
+         break;
+      default:
+         cerr << "Illegal value in switch statement" << endl;
+         ad_exit(1);
+      }
+    }
+  }
+
+  void quadratic_prior::get_cHessian(dcompressed_triplet * dct,int xsize,
+    ivector& sparse_iterator,int& sparse_count)
+  { 
+    //int offset=get_offset(xsize);
+    //dct->initialize();
+    int offset=0;
+    int mmin=SCM->get_x().indexmin();
+    int mmax=SCM->get_x().indexmax();
+    for (int i=mmin;i<=mmax;i++)
+    {
+      sparse_count++;
+      dct->get_x()(sparse_iterator(sparse_count))+=SCM->get_x()(i);
+    }
+    //cout << norm2(make_sdmatrix(*dct)-2.0*make_sdmatrix(*SCM)) << endl;
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::get_cHessian(dvar_matrix H,int xsize) 
+  { 
+    int offset=get_offset(xsize);
+    int imin=pMinv->indexmin();
+    int imax=pMinv->indexmax();
+    if (offset==0)
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=(*pMinv)(i,j);
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*(*pMinv)(i,j);
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*(*pMinv)(i,j);
+         break;
+      default:
+         cerr << "Illegal value in switch statement" << endl;
+         ad_exit(1);
+      }
+    }
+    else
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=(*pMinv)(i,j);
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*(*pMinv)(i,j);
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*(*pMinv)(i,j);
+         break;
+      default:
+         cerr << "Illegal value in switch statement" << endl;
+         ad_exit(1);
+      }
+    }
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::get_vHessian(dvar_matrix H,int xsize) 
+  { 
+    int offset=get_offset(xsize);
+    if (dfpMinv==0)
+    {
+      cerr << "This can't happen" << endl;
+      ad_exit(1);
+    }
+    int imin=dfpMinv->indexmin();
+    int imax=dfpMinv->indexmax();
+    if (offset==0)
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        NOT_IMPLEMENTED();
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=(*dfpMinv)(i,j);
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*(*dfpMinv)(i,j);
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*(*dfpMinv)(i,j);
+         break;
+      default:
+         cerr << "Illegal valueinswitch statement" << endl;
+         ad_exit(1);
+      }
+    }
+    else
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=(*dfpMinv)(i,j);
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*(*dfpMinv)(i,j);
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*(*dfpMinv)(i,j);
+         break;
+      default:
+         cerr << "Illegal valueinswitch statement" << endl;
+         ad_exit(1);
+      }
+    }
+  }
+ /*
+  dvar_matrix sparse_quadratic_prior::get_vHessian(void) 
+  { 
+    return *dfpMinv;
+    //return value(*pMinv);
+  }
+ */
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::get_cHessian_from_vHessian(dmatrix H,int xs) 
+  { 
+    int offset=get_offset(xs);
+    int imin=dfpMinv->indexmin();
+    int imax=dfpMinv->indexmax();
+    if (offset==0)
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=value((*dfpMinv)(i,j));
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*value((*dfpMinv)(i,j));
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*value((*dfpMinv)(i,j));
+        break;
+         break;
+      default:
+         cerr << "Illegal valueinswitch statement" << endl;
+         ad_exit(1);
+      }
+    }
+    else
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=value((*dfpMinv)(i,j));
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*value((*dfpMinv)(i,j));
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*value((*dfpMinv)(i,j));
+         break;
+      default:
+         cerr << "Illegal valueinswitch statement" << endl;
+         ad_exit(1);
+      }
+    }
+    //return value(*dfpMinv);
+  }
+
+  void quadratic_prior::get_cHessian_from_vHessian
+    (dcompressed_triplet * dct ,int xs,ivector& sparse_iterator,
+     int & sparse_count ) 
+  { 
+    int offset=get_offset(xs);
+    //int imin=dfpMinv->indexmin();
+    //int imax=dfpMinv->indexmax();
+    if (offset==0)
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+        NOT_IMPLEMENTED();
+        /*
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=value((*dfpMinv)(i,j));
+        */
+        break;
+      case 1:
+        NOT_IMPLEMENTED();
+        /*
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(i,j)+=2.0*value((*dfpMinv)(i,j));
+        */
+        break;
+      case 2:
+        {
+          int mmin=S_dfpMinv->get_x().indexmin();
+          int mmax=S_dfpMinv->get_x().indexmax();
+          for (int i=mmin;i<=mmax;i++)
+          {
+            sparse_count++;
+            dct->get_x()(sparse_iterator(sparse_count))+=
+              value(S_dfpMinv->get_x()(i));
+          }
+        }
+        break;
+      default:
+         cerr << "Illegal valueinswitch statement" << endl;
+         ad_exit(1);
+      }
+    }
+    else
+    {
+      int i,j;
+      switch(old_style_flag)
+      {
+      case 0:
+      NOT_IMPLEMENTED();
+       /*
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=value((*dfpMinv)(i,j));
+        break;
+       */
+      case 1:
+      NOT_IMPLEMENTED();
+       /*
+        for (i=imin;i<=imax;i++)
+          for (j=imin;j<=imax;j++)
+            H(offset+i,offset+j)+=2.0*value((*dfpMinv)(i,j));
+        break;
+        */
+      case 2:
+        NOT_IMPLEMENTED();
+        {
+          int mmin=S_dfpMinv->get_x().indexmin();
+          int mmax=S_dfpMinv->get_x().indexmax();
+          for (int i=mmin;i<=mmax;i++)
+          {
+            sparse_count++;
+            dct->get_x()(sparse_iterator(sparse_count))+=
+              value(S_dfpMinv->get_x()(i));
+          }
+        }
+        break;
+      default:
+         cerr << "Illegal value in switch statement" << endl;
+         ad_exit(1);
+      }
+    }
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  dvar_vector sparse_quadratic_prior::get_gradient(void) 
+  { 
+    return ((*pMinv)*(*pu));
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::get_cgradient(dvector g,int xs) 
+  { 
+    int offset=get_offset(xs);
+    dvector tg=((*pMinv)*value(*pu));
+    int imin=pMinv->indexmin();
+    int imax=pMinv->indexmax();
+    if (offset==0)
+    {
+      int i;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          g(i)+=tg(i);
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          g(i)+=2.0*tg(i);
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          g(i)+=2.0*tg(i);
+        break;
+      default:
+        cerr << "Illegal valueinswitch statement" << endl;
+        ad_exit(1);
+      }
+    }
+    else
+    {
+      int i;
+      switch(old_style_flag)
+      {
+      case 0:
+        for (i=imin;i<=imax;i++)
+          g(offset+i)+=tg(i);
+        break;
+      case 1:
+        for (i=imin;i<=imax;i++)
+          g(offset+i)+=2.0*tg(i);
+        break;
+      case 2:
+        for (i=imin;i<=imax;i++)
+          g(offset+i)+=2.0*tg(i);
+        break;
+      default:
+        cerr << "Illegal valueinswitch statement" << endl;
+        ad_exit(1);
+      }
+    }
+    //return ((*pMinv)*value(*pu));
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  sparse_quadratic_prior::sparse_quadratic_prior(void)
+  {
+    CM=0;
+    pMinv=0; 
+    dfpMinv=0; 
+    pu=0; 
+    add_to_list();
+  } 
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  sparse_quadratic_prior::~sparse_quadratic_prior(void)
+  {
+    if (pMinv) delete pMinv;
+    pMinv=0; 
+    if (pu) delete pu;
+    pu=0; 
+    if (dfpMinv) delete pMinv;
+    dfpMinv=0; 
+    if (CM) delete CM;
+    CM=0;
+  } 
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::allocate( const dvar_vector & _u,const char * s) 
+  {
+    allocate(_u);
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::allocate(const dvar_vector & _u) 
+  {
+    if (!allocated(_u))
+    {
+      cerr << "You must put random effects vector before"
+       " quadtratic prior in the TPL file" << endl;
+      ad_exit(1);
+    }
+    pu = new dvar_vector((dvar_vector&)(_u));
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::allocate(const dvar_matrix & _M, 
+    const dvar_vector & _u,const char * s) 
+  {
+    allocate(_M,_u);
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+  void sparse_quadratic_prior::allocate(const dvar_matrix & _M, 
+    const dvar_vector & _u) 
+  {
+    pMinv =new dmatrix(value(inv(_M)));
+    pu = new dvar_vector((dvar_vector&)(_u));
+  }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+/*
+ dvariable sparse_quadratic_prior::get_sparse_quadratic_priors(void)
+ {
+   dvariable f=0.0;
+   for (int i=0;i<num_sparse_quadratic_prior;i++)
+   {
+     f+=ptr[i]->get_function();
+   }
+   return f;
+ }
+*/
+/**
+ * Description not yet available.
+ * \param
+ */
+
+ //  void sparse_quadratic_prior::get_cgradient_contribution(dvector g,int xs)
+ //  {
+ //    for (int i=0;i<num_sparse_quadratic_prior;i++)
+ //    {
+ //      ptr[i]->get_cgradient(g,xs);
+ //     /*
+ //      if (old_style_flag)
+ //      {
+ //        return ptr[i]->get_cgradient();
+ //      }
+ //      else
+ //      {
+ //        return ptr[i]->get_cgradient();
+ //      }
+ //     */
+ //    }
+ //    //return f;
+ //  }
+ // 
+/*
+ dvar_vector sparse_quadratic_prior::get_gradient_contribution(void)
+ {
+   for (int i=0;i<num_sparse_quadratic_prior;i++)
+   {
+     return ptr[i]->get_gradient();
+   }
+   //return f;
+ }
+*/
+
+/**
+ * Description not yet available.
+ * \param
+ */
+ void sparse_quadratic_prior::get_cHessian_contribution(dmatrix H,int xsize)
+ {
+   for (int i=0;i<num_sparse_quadratic_prior;i++)
+   {
+     if (!ptr[i])
+     {
+       cerr << "ptr["<<i<<"] = 0 in" 
+         " sparse_quadratic_prior::get_cHessian_contribution" << endl;
+       ad_exit(1);
+     }
+     if (!ptr[i]->pMinv)
+     {
+       cerr << "ptr["<<i<<"]->pMinv = 0 in" 
+         " sparse_quadratic_prior::get_cHessian_contribution" << endl;
+       ad_exit(1);
+     }
+     if (!allocated(*(ptr[i]->pMinv)))
+     {
+       cerr << "*ptr["<<i<<"] is unallocated in" 
+         " sparse_quadratic_prior::get_cHessian_contribution" << endl;
+       ad_exit(1);
+     }
+     ptr[i]->get_cHessian(H,xsize);
+    /*
+     if (old_style_flag)
+     {
+       return 2.0*ptr[i]->get_cHessian();
+     }
+     else
+     {
+       return ptr[i]->get_cHessian();
+     }
+    */
+   }
+   //return f;
+ }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+ void sparse_quadratic_prior::get_vHessian_contribution(dvar_matrix H,int xs)
+ {
+   for (int i=0;i<num_sparse_quadratic_prior;i++)
+   {
+     ptr[i]->get_vHessian(H,xs);
+    /*
+     if (old_style_flag)
+     {
+       return 2.0*ptr[i]->get_vHessian();
+     }
+     else
+     {
+       return ptr[i]->get_vHessian();
+     }
+    */
+   }
+   //return f;
+ }
+ /*
+ dvar_matrix sparse_quadratic_prior::get_Hessian_contribution(void)
+ {
+   for (int i=0;i<num_sparse_quadratic_prior;i++)
+   {
+     return ptr[i]->get_Hessian();
+   }
+   //return f;
+ }
+ */
+ 
+/**
+ * Description not yet available.
+ * \param
+ */
+/*
+ void sparse_quadratic_prior::get_cHessian_contribution_from_vHessian(dmatrix Hess,int xsize)
+ {
+   for (int i=0;i<num_sparse_quadratic_prior;i++)
+   {
+     int nv=df1b2sparse_quadratic_prior::get_ptr(i)->
+       get_num_active_parameters();
+     if (nv)
+       ptr[i]->get_cHessian_from_vHessian(Hess,xsize);
+     else
+       ptr[i]->get_cHessian(Hess,xsize);
+   }
+   //return f;
+ }
+*/
+/**
+ * Description not yet available.
+ * \param
+ */
+
+ void sparse_quadratic_prior::operator = (const dvar_matrix & _M)
+ { 
+   dvariable lndet;
+   dvariable sgn;
+   
+   switch (sparse_quadratic_prior::old_style_flag)
+   {
+   case 0:
+     *objective_function_value::pobjfun+=0.5*(*pu)*(solve(_M,*pu,lndet,sgn));
+     *objective_function_value::pobjfun+=0.5*lndet;
+     //*objective_function_value::pobjfun+=0.5*(*pu)*(solve(_M,*pu));
+     //*objective_function_value::pobjfun+=0.5*ln_det(_M);
+     break;
+   case 1:
+     *objective_function_value::pobjfun+=(*pu)*(solve(_M,*pu));
+     break;
+   case 2:
+     *objective_function_value::pobjfun+=(*pu) * ( _M * (*pu) );
+     break;
+   default:
+     cerr << "Illegal value for sparse_quadratic_prior::old_style_flag"
+          << endl;
+     ad_exit(1);
+   }
+   if (pMinv) 
+   {
+     delete pMinv;
+     pMinv=0;
+   }
+   if (dfpMinv) 
+   {
+     delete dfpMinv;
+     dfpMinv=0;
+   }
+   switch (sparse_quadratic_prior::old_style_flag)
+   {
+   case 0:
+   case 1:
+     if (laplace_approximation_calculator::where_are_we_flag==2) 
+     {
+       pMinv = new dmatrix(inv(value(_M)));
+       if (pMinv==0)
+       {
+         cerr << "Error allocating dmatrix" << endl;
+         ad_exit(1);
+       }
+     }
+     if (laplace_approximation_calculator::where_are_we_flag==3) 
+     {
+       dfpMinv = new dvar_matrix(inv(_M));
+       if (dfpMinv==0)
+       {
+         cerr << "Error allocating dvar_matrix" << endl;
+         ad_exit(1);
+       }
+     }
+     break;
+   case 2:
+     if (laplace_approximation_calculator::where_are_we_flag==2) 
+     {
+       pMinv = new dmatrix(value(_M));
+       if (pMinv==0)
+       {
+         cerr << "Error allocating dmatrix" << endl;
+         ad_exit(1);
+       }
+     }
+     if (laplace_approximation_calculator::where_are_we_flag==3) 
+     {
+       cerr << "Need to fix this" << endl;
+       ad_exit(1);
+       int nv=0;
+       //int nv=df1b2sparse_quadratic_prior::get_ptr(xmyindex)->get_num_active_parameters();
+       //if (nv==0)
+       if (nv!=0)
+       {
+         dfpMinv = new dvar_matrix(_M);
+         if (dfpMinv==0)
+         {
+           cerr << "Error allocating dvar_matrix" << endl;
+           ad_exit(1);
+         }
+       }
+       else
+       {
+         pMinv = new dmatrix(value(_M));
+         if (pMinv==0)
+         {
+           cerr << "Error allocating dmatrix" << endl;
+           ad_exit(1);
+         }
+       }
+     }
+     break;
+   default:
+     cerr << "Illegal value for sparse_quadratic_prior::old_style_flag"
+          << endl;
+     ad_exit(1);
+   }
+ }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+ void sparse_quadratic_prior::operator = (const dmatrix & _M)
+ { 
+   dvariable lndet;
+   dvariable sgn;
+
+   
+   switch (sparse_quadratic_prior::old_style_flag)
+   {
+   case 0:
+     cerr << " can't get here " << endl;
+     ad_exit(1);
+     break;
+   case 1:
+     cerr << " can't get here " << endl;
+     ad_exit(1);
+     break;
+   case 2:
+     *objective_function_value::pobjfun+=(*pu) * ( _M * (*pu) );
+     break;
+   default:
+     cerr << "Illegal value for sparse_quadratic_prior::old_style_flag"
+          << endl;
+     ad_exit(1);
+   }
+   if (pMinv) 
+   {
+     delete pMinv;
+     pMinv=0;
+   }
+   if (dfpMinv) 
+   {
+     delete dfpMinv;
+     dfpMinv=0;
+   }
+   switch (sparse_quadratic_prior::old_style_flag)
+   {
+   case 0:
+   case 1:
+     cerr << " can't get here " << endl;
+     ad_exit(1);
+     break;
+   case 2:
+     if (laplace_approximation_calculator::where_are_we_flag==2 ||
+       laplace_approximation_calculator::where_are_we_flag==3) 
+     {
+       pMinv = new dmatrix(_M);
+       if (pMinv==0)
+       {
+         cerr << "Error allocating dmatrix" << endl;
+         ad_exit(1);
+       }
+     }
+     break;
+   default:
+     cerr << "Illegal value for sparse_quadratic_prior::old_style_flag"
+          << endl;
+     ad_exit(1);
+   }
+ }
+
+/**
+ * Description not yet available.
+ * \param
+ */
+/*
+normal_sparse_quadratic_prior::normal_sparse_quadratic_prior(void) 
+{ 
+  set_old_style_flag();
+}
+*/
+/**
+ * Description not yet available.
+ * \param
+ */
+/*
+void normal_sparse_quadratic_prior::set_old_style_flag(void)
+{
+  old_style_flag=0;
+}
+*/
+/**
+ * Description not yet available.
+ * \param
+ */
+/*
+void normal_sparse_quadratic_prior::operator = (const dvar_matrix & M) 
+{ 
+  sparse_quadratic_prior::operator = (M);
+}
+*/
+
+/**
+ * Description not yet available.
+ * \param
+ */
+
+sparse_quadratic_re_penalty::sparse_quadratic_re_penalty(void) 
+{ 
+  set_old_style_flag();
+}
+
+/**
+ * Description not yet available.
+ * \param
+ */
+void sparse_quadratic_re_penalty::set_old_style_flag(void)
+{
+  old_style_flag=2;
+}
+
+/**
+ * Description not yet available.
+ * \param
+ */
+void sparse_quadratic_re_penalty::operator = (const dvar_matrix & M) 
+{ 
+  //sparse_quadratic_prior::operator = (M);
+  quadratic_prior::operator = (M);
+}
+/**
+ * Description not yet available.
+ * \param
+ */
+void sparse_quadratic_re_penalty::operator = (const dmatrix & M) 
+{ 
+  //sparse_quadratic_prior::operator = (M);
+  quadratic_prior::operator = (M);
+}
+
+void sparse_quadratic_re_penalty::operator = (const dcompressed_triplet & M) 
+{ 
+  //sparse_quadratic_prior::operator = (M);
+  quadratic_prior::operator = (M);
+}
+
+void sparse_quadratic_re_penalty::operator = 
+  (const dvar_compressed_triplet & M) 
+{ 
+  //sparse_quadratic_prior::operator = (M);
+  quadratic_prior::operator = (M);
+}
+
+/**
+ * Description not yet available.
+ * \param
+ //  */
+ // constant_quadratic_re_penalty::constant_quadratic_re_penalty(void) 
+ // { 
+ //   set_old_style_flag();
+ // }
+ // 
+ // /**
+ //  * Description not yet available.
+ //  * \param
+ //  */
+ // void constant_quadratic_re_penalty::set_old_style_flag(void)
+ // {
+ //   old_style_flag=2;
+ // }
+ // 
+ // /**
+ //  * Description not yet available.
+ //  * \param
+ //  */
+ // void constant_quadratic_re_penalty::operator = (const dmatrix & M) 
+ // { 
+ //   sparse_quadratic_prior::operator = (M);
+ // }
+
+/*
+dmatrix ludcmp(const dmatrix& _a,const ivector& _indx,
+  const double& _det,const double& sgn, const double& _d)
+{
+  const double TINY=1.e-60;
+  int i=0;
+  int imax=0;
+  int j=0;
+  int k=0;
+  int n=0;
+  double& d=(double&)_d;
+  double& det=(double&)_det;
+  double& sgn=(double&)_sgn;
+  dmatrix& a=(dmatrix&)_a;
+  ivector& indx=(ivector&)_indx;
+
+  n=a.colsize();
+  int lb=a.colmin();
+  int ub=a.colmax();
+
+  double big,dum,sum,temp;
+
+  dvector vv(lb,ub);
+
+
+  d=1.0;
+
+  for (i=lb;i<=ub;i++)
+  {
+    big=0.0;
+    for (j=lb;j<=ub;j++)
+    {
+      temp=fabs(a[i][j]);
+      if (temp > big)
+      {
+        big=temp;
+      }
+    }
+    if (big == 0.0) 
+    {
+      cerr << "Error in matrix inverse -- matrix singular in inv(dmatrix)\n";
+    }
+    vv[i]=1.0/big;
+  }
+
+
+
+  for (j=lb;j<=ub;j++)
+  {
+    for (i=lb;i<j;i++) 
+    {
+      sum=a[i][j];
+      for (k=lb;k<i;k++)
+      {
+        sum -= a[i][k]*a[k][j];
+      }
+      a[i][j]=sum;
+    }
+    big=0.0;
+    for (i=j;i<=ub;i++) 
+    {
+      sum=a[i][j];
+      for (k=lb;k<j;k++)
+      {
+        sum -= a[i][k]*a[k][j];
+      }
+      a[i][j]=sum;
+      dum=vv[i]*fabs(sum);
+      if ( dum >= big)
+      {
+        big=dum;
+        imax=i;
+      }
+    }
+    if (j != imax)
+    {
+      for (k=lb;k<=ub;k++)
+      {
+        dum=a[imax][k];
+        a[imax][k]=a[j][k];
+        a[j][k]=dum;
+      }
+      d = -d;
+      vv[imax]=vv[j];
+    }
+    indx[j]=imax;
+
+    if (a[j][j] == 0.0)
+    {
+      a[j][j]=TINY;
+    }
+
+    if (j != n)
+    {
+      dum=1.0/(a[j][j]);
+      for (i=j+1;i<=ub;i++)
+      {
+        a[i][j] *= dum;
+      }
+    }
+  }
+
+  double ln_det=0.0;
+   
+  if (d>.1) 
+  {
+    sgn=1;
+  }
+  else if (d<-0.1)
+  {
+    sgn=-1;
+  }
+  else
+  {
+    sgn=0;
+  }
+  for (int j=m1.rowmin();j<=m1.rowmax();j++)
+  {
+    if (a(j,j)>0)
+    {
+      ln_det+=log(a[j][j]);
+    }
+    else if (a(j,j)<0)
+    {
+      sgn=-sgn;
+      ln_det+=log(-a[j][j]);
+    }
+    else
+    {
+      sgn=0;
+    }
+  }
+
+  return a;
+}
+*/
Index: df1b2-separable/seddf1b2
===================================================================
--- df1b2-separable/seddf1b2	(revision 682)
+++ df1b2-separable/seddf1b2	(working copy)
@@ -4,6 +4,7 @@
 class df1b2_parameters : public df1b2_pre_parameters \
 { \
 public: \
+  virtual void * mycast(void) {return (void*)this;} \
   static df1b2_parameters * df1b2_parameters_ptr;\
   static df1b2_parameters * get_df1b2_parameters_ptr(void) \
   { \
@@ -38,6 +39,9 @@
  // void end_df1b2_funnel(void);
 # virtual void user_function(const init_df1b2vector& x,df1b2variable& f); \
 /df_normal_prior_/d
+/df_quadratic_prior_/d
+/df_sparse_normal_prior_/d
+/df_sparse_quadratic_prior_/d
 #s/df_normal_prior_/df1b2_normal_prior_/g
 s/param_init_bounded_dev_vector/df1b2_init_bounded_dev_vector/
 s/param_init_bounded_vector/df1b2_init_bounded_vector/
Index: df1b2-separable/seddf1b3
===================================================================
--- df1b2-separable/seddf1b3	(revision 682)
+++ df1b2-separable/seddf1b3	(working copy)
@@ -13,6 +13,8 @@
 # virtual void user_function(const init_df1b2vector& x,df1b2variable& f); \
 #/objective_function_value/d
 s/df_normal_prior_/df1b2_normal_prior_/p
+s/df_sparse_normal_prior_/df1b2_sparse_normal_prior_/p
+s/df_sparse_quadratic_prior_/df1b2_sparse_quadratic_prior_/p
 s/objective_function_value/re_objective_function_value/p
 s/quadratic_prior/df1b2quadratic_prior/g
 s/quadratic_re_penalty/df1b2quadratic_re_penalty/g
Index: df1b2-separable/seddf1b4
===================================================================
--- df1b2-separable/seddf1b4	(revision 682)
+++ df1b2-separable/seddf1b4	(working copy)
@@ -4,6 +4,7 @@
 s/dvar_matrix/df1b2matrix/g
 s/prevariable/df1b2variable/g
 s/dvar_vector/df1b2vector/g
+s/dvar_compressed_triplet/df1b2_compressed_triplet/g
 /^ *quadratic_re_penalty/p
 /^SEPFUN3/{
   s/df1b2variable/funnel_init_df1b2variable/g
Index: df1b2-separable/sedf1b2a
===================================================================
--- df1b2-separable/sedf1b2a	(revision 682)
+++ df1b2-separable/sedf1b2a	(working copy)
@@ -5,10 +5,13 @@
   s/ model_parameters::/ df1b2_pre_parameters::/
 }
 /void model_parameters::userfunction(void)/d
+s/\&model_parameters::/\&df1b2_parameters::/
 s/ model_parameters::/ df1b2_parameters::/
 s/dvariable/df1b2variable/g
 s/prevariable/df1b2variable/g
 s/dvar_vector/df1b2vector/g
+s/dvar_compressed_triplet/df1b2_compressed_triplet/g
+/ df1b2 Deletion Tag /d
 s/dvar_matrix/df1b2matrix/g
 s/dvar3_array/df1b23array/g
 
Index: df1b2-separable/sedf1b2c
===================================================================
--- df1b2-separable/sedf1b2c	(revision 682)
+++ df1b2-separable/sedf1b2c	(working copy)
@@ -9,5 +9,6 @@
 s/dvariable/df1b2variable/g
 s/prevariable/df1b2variable/g
 s/dvar_vector/df1b2vector/g
+s/dvar_compressed_triplet/df1b2_compressed_triplet/g
 s/dvar_matrix/df1b2matrix/g
 s/dvar3_array/df1b23array/g
Index: df1b2-separable/sedf1b2d
===================================================================
--- df1b2-separable/sedf1b2d	(revision 682)
+++ df1b2-separable/sedf1b2d	(working copy)
@@ -1,6 +1,7 @@
 s/dvariable/df1b2variable/g
 s/prevariable/df1b2variable/g
 s/dvar_vector/df1b2vector/g
+s/dvar_compressed_triplet/df1b2_compressed_triplet/g
 s/dvar_matrix/df1b2matrix/g
 s/dvar3_array/df1b23array/g
 /^SEPFUN3/d
Index: df1b2-separable/tpl2rem.lex
===================================================================
--- df1b2-separable/tpl2rem.lex	(revision 682)
+++ df1b2-separable/tpl2rem.lex	(working copy)
@@ -1,5899 +1,5696 @@
-%option noyywrap
-
-%{
-  #define   MAX_TMP_STRING 2000 
-  #define   MAX_USER_CLASSES  450
-  #define   MAX_USER_CLASSNAME_LENGTH  181
-  #define   MAX_PRIOR_CHECK  1000
-  #define   MAX_LIKE_CHECK  2000
-  #include <stdlib.h>
-  #include <string.h>
-  #include <stdio.h>
-  #if defined(_WIN32)
-  #include <io.h>  /* fopen */
-  #endif
-  char tmp_string[MAX_TMP_STRING];
-  char tmp_string1[MAX_TMP_STRING];
-  char tmp_string2[MAX_TMP_STRING];
-  char tmp_string3[MAX_TMP_STRING];
-  char tmp_string4[MAX_TMP_STRING];
-  char reference_statements[MAX_USER_CLASSES][MAX_USER_CLASSNAME_LENGTH];
-  char class_instances[MAX_USER_CLASSES][MAX_USER_CLASSNAME_LENGTH];
-  char outcommand[350];
-  char outcommand2[250];
-  char outcommand3[250];
-  char outcommand3a[250];
-  char outcommand3b[250];
-  char outcommand4[250];
-  char outcommand5[250];
-  char outcommand6[250];
-  char outcommand7[250];
-  char outcommand8[250];
-  char * dirpath;
-  char infile_name[1000];
-  char infile_root[1000];
-  char name_string[150];
-  char outfile_name[1000];
-  char headerfile_name[125];
-  char deffile_name[125];
-  char headerfile_name2[125];
-  int  verbosemode=0;
-  int  num_spargs=0;
-  int in_objective_function_value_flag=0;
-  int  pvmslaves_defined=0;
-  int  splus_debug_flag=0;
-  int  spnumber_flag=0;
-  int random_effects_flag=0;
-  int data_defined=0;
-  int in_define_data=0;
-  int need_prior_globals=0;
-  int debug_flag=0;
-  int makedll=0;
-  int makegaussdll=0;
-  int no_userclass=0;
-  int bound_flag=0;
-  int in_normal_prior_flag=0;
-  int num_user_classes=0;
-  int have_separable_function=0;
-  int final_defined=0;
-  int top_of_main_defined=0;
-  int globals_section_defined=0;
-  int in_define_parameters=0;
-  int talk_to_splus=0;
-  int initialization_defined=0;
-  int objective_function_defined=0;
-  int report_defined=0;
-  int preliminary_calcs_defined=0;
-  int between_phases_defined=0;
-  int needs_initialization=0;
-  int quadratic_prior_flag=0;
-  int quadratic_classprint_flag=0;
-  int errcopy=0;
-  int params_defined=0;
-  int runtime_defined=0;
-  int procedure_defined=0;
-  int in_procedure_def=0;
-  int class_append_flag=0;
-  int in_aux_proc=0;
-  int in_funnel_proc=0;
-  int nline=1;
-  int have_likeprof=0;
-  int num_paren=0;
-  int nchar=0;
-  int warn_unallocated=1;
-  int have_classcode_tmp=0;
-  
-  int priors_defined=0;
-  int prior_done_once=0;
-  int likelihood_defined=0;
-  int likelihood_done_once=0;
-  int procedure_done=0;
-  int likelihood_done=0;
-  int priors_done=0;
-  int prior_function_toggle=0;
-  char objective_function_name_string[MAX_TMP_STRING];
-  char prior_checker[MAX_PRIOR_CHECK][100];//container hold all parameters which being used for check the prior
-  int prior_counter=0; //index for prior_checker
-  int prior_found=0;
-  char likelihood_checker[MAX_LIKE_CHECK][100];
-  int likelihood_counter=0; //index for likelihood_checker
-  int likelihood_found=0;
-  
-  char *  conlist_ptr;
-  char conlist[6000];
-  char *  classlist_ptr;
-  char classlist[6000];
-  char *  arglist1_ptr;
-  char arglist1[4000];
-  char *  arglist_ptr;
-  char arglist[4000];
-  char uuu_xxx[80]={"Copyright (c) 2008-2012 Regents of the University of California"};
-  FILE * fdat=NULL;
-  FILE * fdat1=NULL;
-  FILE * htop=NULL;
-  FILE * fall=NULL;
-  FILE * fhead=NULL;
-  FILE * fglobals=NULL;
-  FILE * ftopmain=NULL;
-  FILE * fs=NULL;
-  FILE * fs1=NULL;
-  void write_getindex_stuff(char *str);
-  void initialize(char *);
-  char * before_part(char * d, char * s, char c);
-  char * before_partb(char * d, char * s, char c);
-  char * strict_after_part(char * d, char * s, char c);
-  char * after_part(char * d, char * s, char c);
-  char * after_partb(char * d, char * s, char c);
-  char * strip_leading_blanks(char * d, char * s);
-  char * strip_leading_blanks_and_tabs(char * d, char * s);
-  void check_random_effects_ordering(void);
-  int count_paren(int num_paren,char * yytext);
-  void add_references_to_user_classes(FILE * fall);  
-  void write_funnel_end(void);
-  void call_destructors_for_user_classes(FILE * fall); 
-  void marker(void);
-  void write_unallocated(const char *);
-  void print_quadratic_random_effect_penalty_class(char *text);
-  
-  void add_prior_to_objective(void);
-  void add_likelihood_to_objective(void);
-  void setup_for_prior_likelihood(void);
-  void trim(char * a); 
-  int prior_check(char * parameter, char * prior);   
-  
-%}
-
-filename \"[^\"]*\"
-
-filenamesingle \'[^\']*\'
-
-name [a-z_A-Z]+(->)?[a-z_A-Z0-9]*
-
-num_exp [a-z_A-Z0-9\+\-\*\/]+
-
-index ([a-z_A-Z]+(->)?[a-z_A-Z0-9]*)|([a-z_A-Z0-9\+\-\*\/]+)
-
-float_num_exp [a-z_A-Z0-9\.\+\-\*]+
-
-prior_name [ \t(a-z_A-Z]+(->)?[ \ta-z_A-Z0-9(),.-]*
-prior_def [ \t(a-z_A-Z0-9-]+(->)?[ \ta-z_A-Z0-9),.-]*
-
-%s DEFINE_DATA DEFINE_PARAMETERS DEFINE_PROCS IN_DATA_DEF IN_PARAM_DEF
-%s IN_NUMBER_DEF IN_SPNUMBER_DEF IN_VECTOR_DEF IN_VECTOR_VECTOR_DEF 
-%s IN_SPVECTOR_DEF 
-%s IN_MATRIX_DEF IN_TABLE_DEF IN_SPMATRIX_DEF IN_THREE_ARRAY_DEF IN_SPTHREE_ARRAY_DEF
-%s IN_NAMED_NUMBER_DEF IN_NAMED_VECTOR_DEF IN_NAMED_MATRIX_DEF
-%s IN_NAMED_THREE_ARRAY_DEF IN_NAMED_FOUR_ARRAY_DEF DEFINE_AUX_PROC
-%s INIT_BOUNDED_NUMBER_DEF INIT_BOUNDED_VECTOR_DEF IN_BOUNDED_MATRIX_DEF
-%s DEFINE_INITIALIZATION DEFINE_PRELIMINARY_CALCS INIT_BOUNDED_MATRIX_DEF
-%s CONTINUE_PROTOTYPE_DEF DEFINE_RUNTIME IN_FOUR_ARRAY_DEF IN_LOCAL_CALCS
-%s IN_GLOBALS_SECTION IN_TOP_SECTION INIT_BOUNDED_THREE_ARRAY_DEF 
-%s DEFINE_BETWEEN_PHASES IN_FIVE_ARRAY_DEF IN_SIX_ARRAY_DEF IN_SEVEN_ARRAY_DEF 
-%s IN_NAMED_FIVE_ARRAY_DEF IN_NAMED_SIX_ARRAY_DEF IN_NAMED_SEVEN_ARRAY_DEF 
-%s IN_SPBOUNDED_NUMBER_DEF INIT_SPBOUNDED_VECTOR_DEF IN_PVM_SLAVE_SECTION
-%s DEFINE_PRIORS DEFINE_LIKELIHOOD DEFINE_PROCEDURE IN_NUMBER_DEF2
-%%
-
-\/\/.*$         /* ignore trailing comments */ ;
-\/[\*]+.[\*]\/  /* ignore block comments */ ;
-\r    { ; }
-
-INITIALIZATION_SECTION  {
-
-  if (!data_defined)
-  {
-    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
-      " INITIALIZATION_SECTION \n");
-    exit(1);
-  }
-  if (params_defined)
-  {
-    fprintf(stderr,"Error -- INITIALIZATION_SECTION must be defined before"
-      " PARAMETER_SECTION for random effect model\n");
-    exit(1);
-  }
-  
-  if (initialization_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one INTIALIZATION SECTION allowed\n");
-    exit(1);
-  }
-  else
-  {
-    BEGIN DEFINE_INITIALIZATION;
-    initialization_defined=1;
-    fprintf(fall,"%s","}\n\nvoid model_parameters::initializationfunction(void)"
-      "\n{\n");
-  }
-                }
-
-REPORT_SECTION  {
-
-  in_aux_proc=0;
-  if (!data_defined)
-  {
-    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
-      " REPORT_SECTION \n");
-    exit(1);
-  }
-  if (!params_defined)
-  {
-    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
-      " REPORT_SECTION \n");
-    exit(1);
-  }
-  if (!preliminary_calcs_defined && runtime_defined)
-  {
-    fprintf(stderr,"%s","Error -- REPORT_SECTION must be defined before RUNTIME_SECTION \n");
-    exit(1);
-  }
-  if (final_defined)
-  {
-    fprintf(stderr,"%s","Error -- REPORT_SECTION must be defined before FINAL_SECTION\n");
-    exit(1);
-  }
-    
-  if (report_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one REPORT SECTION allowed\n");
-    exit(1);
-  }
-  else
-  {
-    BEGIN DEFINE_PROCS;
-    report_defined=1;
-    write_funnel_end();    
-    setup_for_prior_likelihood();    
-    fprintf(fall,"}\n");
-    //if (!preliminary_calcs_defined)
-    {
-      fclose(fall);
-      fall=fopen("xxalloc4.tmp","w+");
-      if (fall==NULL)
-      {
-        fprintf(stderr,"%s","Error trying to open file xxalloc4.tmp\n");
-      }
-    }
-    fprintf(fall,"%s","\nvoid model_parameters::report()"
-      "\n{\n");
-    fprintf(fall," adstring ad_tmp=initial_params::get_reportfile_name();\n");
-    fprintf(fall,"  ofstream report((char*)"
-                 "(adprogram_name + ad_tmp));\n");
-    fprintf(fall,"  if (!report)\n"
-                 "  {\n    cerr << \"error trying to open report file\" "
-                 " << adprogram_name << \".rep\";\n    return;\n  }\n");
-  }
-                }
-
-FINAL_SECTION  {
-
-  in_aux_proc=0;
-  if (!data_defined)
-  {
-    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
-      " FINAL_SECTION \n");
-    exit(1);
-  }
-  if (!params_defined)
-  {
-    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
-      " FINAL_SECTION \n");
-    exit(1);
-  }
-    
-  if (final_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one FINAL SECTION allowed\n");
-    exit(1);
-  }  
-  else
-  {
-    BEGIN DEFINE_PROCS;
-    final_defined=1;
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"%s","}\n\nvoid model_parameters::final_calcs()"
-      "\n{\n");
-  }
-                }
-
-
-RUNTIME_SECTION  {
-
-  in_aux_proc=0;
-  if (!data_defined)
-  {
-    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
-      " RUNTIME_SECTION \n");
-    exit(1);
-  }
-  if (!params_defined)
-  {
-    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
-      " RUNTIME_SECTION \n");
-    exit(1);
-  }
-  
-  if (runtime_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one REPORT SECTION allowed\n");
-    exit(1);
-  }
-  else
-  {
-    BEGIN DEFINE_RUNTIME;
-    runtime_defined=1;
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    fprintf(fall,"%s","}\n\nvoid model_parameters::set_runtime(void)"
-      "\n{\n");
-  }
-                }
-
-<DEFINE_RUNTIME>^" "*convergence_criteria" ".*$ { 
-
-    strip_leading_blanks(tmp_string1,yytext);
-    after_part(tmp_string2,tmp_string1,' ');  // get 10  in x  10
-    strip_leading_blanks(tmp_string1,tmp_string2);
-    fprintf(fall,"%s","  dvector temp(\"{"); 
-    fprintf(fall,"%s}\");\n", tmp_string1); 
-    fprintf(fall,"  convergence_criteria.allocate"
-      "(temp.indexmin(),temp.indexmax());\n" ); 
-    fprintf(fall,"  convergence_criteria=temp;\n");
-
-                                  }
-
-<DEFINE_RUNTIME>^" "*maximum_function_evaluations" ".*$ { 
-
-    strip_leading_blanks(tmp_string1,yytext);
-    after_part(tmp_string2,tmp_string1,' ');  // get 10  in x  10
-    strip_leading_blanks(tmp_string1,tmp_string2);
-    fprintf(fall,"%s","  dvector temp1(\"{"); 
-    fprintf(fall,"%s}\");\n", tmp_string1); 
-    fprintf(fall,"  maximum_function_evaluations.allocate"
-      "(temp1.indexmin(),temp1.indexmax());\n" ); 
-    fprintf(fall,"  maximum_function_evaluations=temp1;\n");
-
-                                  }
-
-
-PRELIMINARY_CALCULATIONS_SECTION  |
-PRELIMINARY_CALCS_SECTION  {
-
-#  if defined(ADMB_REDEMO)
-    printf("Error -- you can not use the PRELIMINARY_CALCS_SECTION"
-      "\n in the random effects model at present. Use LOCAL_CALCS instead\n");
-    exit(1);
-#  endif
-    //preliminary_calcs_defined=1;
-    //write_funnel_end();
-  if (!data_defined)
-  {
-    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
-      " PRELIMINARY_CALCS_SECTION \n");
-    exit(1);
-  }
-  if (!params_defined)
-  {
-    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
-      " PRELIMINARY_CALCS_SECTION\n");
-    exit(1);
-  }
-  
-  if (runtime_defined)
-  {
-    fprintf(stderr,"%s","Error -- PRELIMINARY_CALCS_SECTION must be defined before RUNTIME_SECTION \n");
-    exit(1);
-  }
-  
-  if (preliminary_calcs_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one PRELIMINARY_CALCS_SECTION allowed\n");
-    exit(1);
-  }
-  else
-  {
-    BEGIN DEFINE_PRELIMINARY_CALCS;
-    preliminary_calcs_defined=1;
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"}\n");
-    //if (!report_defined)
-    {
-      fclose(fall);
-      fall=fopen("xxalloc5.tmp","w+");
-      if (fall==NULL)
-      {
-        fprintf(stderr,"%s","Error trying to open file xxalloc5.tmp\n");
-      }
-    }
-    fprintf(fall,"%s","\nvoid model_parameters::preliminary_calculations(void) \n{\n");
-    fprintf(fall,"%s","\n  admaster_slave_variable_interface(*this);\n");
-  }
-                }
-
-<DEFINE_PRELIMINARY_CALCS>^" ".* {fprintf(fall,"%s\n",yytext);}
-
-BETWEEN_PHASES_SECTION {
-  if (report_defined)
-  {
-    fprintf(stderr,"%s","Error -- BETWEEN_PHASES_SECTION must be defined before REPORT SECTION\n");
-    exit(1);
-  }
-
-  if (between_phases_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one BETWEEN_PHASES_SECTION allowed\n");
-    exit(1);
-  }
-  else
-  {
-    BEGIN DEFINE_BETWEEN_PHASES;
-    between_phases_defined=1;
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"%s","}\n\nvoid model_parameters::between_phases_calculations(void)"
-      "\n{\n");
-    fprintf(fdat,"%s","  void between_phases_calculations(void);\n");
-  }
-                }
-
-<DEFINE_BETWEEN_PHASES>^" ".* {fprintf(fall,"%s\n",yytext);}
-
-
-<DEFINE_INITIALIZATION>{name}[ ]+{float_num_exp} {
-
-
-    before_part(tmp_string,yytext,' ');  // get x in x 10
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".set_initial_value(");
-    after_part(tmp_string1,yytext,' ');  // get 10  in x  10
-    strip_leading_blanks(tmp_string2,tmp_string1);
-    fprintf(fall,"%s);\n",tmp_string2);
-
-                            }
-
-SLAVE_SECTION  {
-
-  if (pvmslaves_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one pvm slave section allowed\n");
-    exit(1);
-  }
-  else
-  {
-    BEGIN IN_PVM_SLAVE_SECTION;
-    pvmslaves_defined=1;
-    fprintf(fdat,"  virtual imatrix get_slave_assignments(void);\n");
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"%s","}\n\nimatrix model_parameters::"
-      "get_slave_assignments(void)\n{\n");
-  }
-
-         }
-
-<IN_PVM_SLAVE_SECTION>^[ \t].*$ { fprintf(fall,"%s\n",yytext); }
-
-DATA_SECTION  {
-
-  if (data_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one data section allowed\n");
-    exit(1);
-  }
-  else
-  {
-    if(!data_defined) BEGIN DEFINE_DATA;
-    data_defined=1;
-    in_define_data=1;
-    if (makedll)
-    { 
-      fprintf(fall,"%s","model_data::model_data(int argc,char * argv[],dll_args& ad_dll) : "
-        "ad_comm(argc,argv)\n{\n");
-      fprintf(fdat,"%s","class dll_args;\n");
-    }  
-    else  
-    {
-        
-      fprintf(fall,"%s","model_data::model_data(int argc,char * argv[]) : "
-        "ad_comm(argc,argv)\n{\n");
-    }  
-    fprintf(fdat,"%s","#define SEPFUN1\n");
-    fprintf(fdat,"%s","#define SEPFUN3\n");
-    fprintf(fdat,"%s","#define SEPFUN4\n");
-
-    fprintf(fdat,"%s","class model_data : public ad_comm{\n"
-       "  public:\n");
-  }
-                }
-
-<DEFINE_DATA>^[ \t]*!!USER_CODE.*$ {
-    strip_leading_blanks_and_tabs(tmp_string1,yytext);
-    strcpy(tmp_string2,tmp_string1+11);
-    fprintf(fall,"%s\n",tmp_string2);
-    
-    }
-
-<DEFINE_DATA>^[ \t]*!!CLASS.*$ {              // start with !!CLASSbbclassname classinstance(xxx)
-    num_user_classes++;
-    strip_leading_blanks_and_tabs(tmp_string1,yytext);
-    strcpy(tmp_string2,tmp_string1+7);  // now bbclassname classinstance(xxx)
-    strip_leading_blanks(tmp_string1,tmp_string2); // now classname classinstance(xxx)
-    initialize(tmp_string);
-    before_part(tmp_string,tmp_string1,'('); // now classname classinstance in tmp_string
-    if (!strlen(tmp_string)) 
-    {
-      strcpy(tmp_string,tmp_string1);
-    }  
-    //fprintf(fdat,"%s;\n",tmp_string);
-    before_partb(tmp_string2,tmp_string,' '); // now classname in tmp_string2
-    
-    after_partb(tmp_string3,tmp_string,' ');  // now bbclassinstance in tmp_string3
-    strip_leading_blanks(tmp_string4,tmp_string3);// now classinstance in tmp_string4
-    fprintf(fdat,"  %s * ",tmp_string2);
-    fprintf(fdat,"  pad_%s;\n",tmp_string4);
-    
-    fprintf(fall,"  pad_%s = new ",tmp_string4);
-    fprintf(fall,"%s",tmp_string2);
-    initialize(tmp_string3);
-    after_partb(tmp_string3,tmp_string1,'(');  // now xxx) in tmp_string3
-    if (strlen(tmp_string3))
-    {
-      fprintf(fall,"(%s",tmp_string3);
-    } 
-    fprintf(fall,";\n");
-    strcpy(reference_statements[num_user_classes-1],tmp_string2);
-    strcat(reference_statements[num_user_classes-1],"& ");
-    strcat(reference_statements[num_user_classes-1],tmp_string4);
-    strcat(reference_statements[num_user_classes-1],"= *pad_");
-    strcat(reference_statements[num_user_classes-1],tmp_string4);
-    //strcat(reference_statements[num_user_classes-1],";");
-    strcpy(class_instances[num_user_classes-1],tmp_string4);
-    
-  }
-
-<DEFINE_DATA>^[ \t]*@@.*$ {              // start with !!CLASSbbclassname classinstance(xxx)
-    strip_leading_blanks_and_tabs(tmp_string1,yytext);
-    printf("ddd\n");
-    strcpy(tmp_string2,tmp_string1+2);  // now bbclassname classinstance(xxx)
-    strip_leading_blanks(tmp_string1,tmp_string2); // now classname classinstance(xxx)
-    initialize(tmp_string);
-    before_part(tmp_string,tmp_string1,'('); // now classname classinstance in tmp_string
-    if (!strlen(tmp_string)) 
-    {
-      strcpy(tmp_string,tmp_string1);
-    }  
-    //fprintf(fdat,"%s;\n",tmp_string);
-    before_partb(tmp_string2,tmp_string,' '); // now classname in tmp_string2
-    
-    after_partb(tmp_string3,tmp_string,' ');  // now bbclassinstance in tmp_string3
-    strip_leading_blanks(tmp_string4,tmp_string3);// now classinstance in tmp_string4
-    fprintf(fdat,"  %s ",tmp_string2);
-    fprintf(fdat,"  %s;\n",tmp_string4);
-    
-    fprintf(fall,"  %s * tmp_%s = new ",tmp_string2,tmp_string4);
-    fprintf(fall,"%s",tmp_string2);
-
-
-    initialize(tmp_string3);
-    after_partb(tmp_string3,tmp_string1,'(');  // now xxx) in tmp_string3
-    if (strlen(tmp_string3))
-    {
-      fprintf(fall,"(%s",tmp_string3);
-    } 
-    fprintf(fall,";\n");
-    fprintf(fall,"  memcpy(cbuf,(char*)(&%s),sizeof(%s));\n",
-      tmp_string4,tmp_string2);
-    fprintf(fall,"  memcpy((char*)(&%s),(char*)(tmp_%s),sizeof(%s));\n",
-      tmp_string4,tmp_string4,tmp_string2);
-    fprintf(fall,"  memcpy((char*)(tmp_%s),buf,sizeof(%s));\n",
-      tmp_string4,tmp_string2);
-    fprintf(fall,"  delete tmp_%s;\n",tmp_string4);
-    fprintf(fall,"  tmp_%s=NULL;\n",tmp_string4);
-
-    
-  }
-
-<DEFINE_DATA>^[ \t]*!!.*$ {
-    strip_leading_blanks_and_tabs(tmp_string1,yytext);
-    strcpy(tmp_string2,tmp_string1+2);
-    fprintf(fall,"%s\n",tmp_string2);
-    
-    }
-
-
-
-<DEFINE_DATA>^[ \t]*LOCAL_CALCULATIONS | 
-<DEFINE_DATA>^[ \t]*LOCAL_CALCS |
-<DEFINE_DATA>^[ \t]*LOC_CALCULATIONS | 
-<DEFINE_DATA>^[ \t]*LOC_CALCS  {
-
-    BEGIN IN_LOCAL_CALCS;
-
-        }
-
-<DEFINE_DATA>init_number {
-    likelihood_found=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  data_number ");
-                     }
-
-<DEFINE_DATA>init_adstring {
-
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  init_adstring ");
-                     }
-
-<DEFINE_DATA>init_line_adstring {
-
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  init_line_adstring ");
-                     }
-
-<DEFINE_DATA>init_int {
-    likelihood_found=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  data_int ");
-                     }
-		     
-<DEFINE_DATA>splus_number |
-<DEFINE_DATA>dll_init_number |
-<DEFINE_DATA>dll_number {
-    spnumber_flag=1;
-    BEGIN IN_SPNUMBER_DEF;
-    fprintf(fdat,"%s","  dll_data_number ");
-                     }
-
-<DEFINE_DATA>splus_int |
-<DEFINE_DATA>dll_init_int |
-<DEFINE_DATA>dll_int {
-
-    BEGIN IN_SPNUMBER_DEF;
-    fprintf(fdat,"%s","  dll_data_int ");
-                     }
-
-<DEFINE_DATA>splus_adstring |
-<DEFINE_DATA>dll_adstring {
-    spnumber_flag=2;
-
-    BEGIN IN_SPNUMBER_DEF;
-    fprintf(fdat,"%s","  dll_named_adstring ");
-                     }
-
-<DEFINE_DATA>splus_vector |
-<DEFINE_DATA>dll_init_vector |
-<DEFINE_DATA>dll_vector {
-    spnumber_flag=1;
-
-    BEGIN IN_SPVECTOR_DEF;
-    fprintf(fdat,"%s","  dll_data_vector ");
-                     }
-
-<DEFINE_DATA>init_vector {
-    likelihood_found=1;
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  data_vector ");
-                     }
-
-<DEFINE_DATA>init_ivector {
-    likelihood_found=1;
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  data_ivector ");
-                     }
-
-<DEFINE_DATA>splus_matrix |
-<DEFINE_DATA>dll_init_matrix |
-<DEFINE_DATA>dll_matrix {
-
-    spnumber_flag=1;
-    BEGIN IN_SPMATRIX_DEF;
-    fprintf(fdat,"%s","  dll_data_matrix ");
-                     }
-
-<DEFINE_DATA>splus_imatrix |
-<DEFINE_DATA>dll_init_imatrix |
-<DEFINE_DATA>dll_imatrix {
-
-    //spnumber_flag=1;
-    BEGIN IN_SPMATRIX_DEF;
-    fprintf(fdat,"%s","  dll_data_imatrix ");
-                     }
-
-<DEFINE_DATA>init_imatrix {
-    likelihood_found=1;
-    //spnumber_flag=1;
-    BEGIN IN_MATRIX_DEF;
-    fprintf(fdat,"%s","  data_imatrix ");
-                     }
-
-<DEFINE_DATA>splus_3darray |
-<DEFINE_DATA>dll_init_3darray |
-<DEFINE_DATA>dll_3darray {
-
-    spnumber_flag=1;
-    BEGIN IN_SPTHREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  dll_data_3array ");
-                     }
-
-<DEFINE_DATA>init_matrix {
-    likelihood_found=1;
-    BEGIN IN_MATRIX_DEF;
-    fprintf(fdat,"%s","  data_matrix ");
-                     }
-
-<DEFINE_DATA>init_table {
-    likelihood_found=1;
-    BEGIN IN_TABLE_DEF;
-    fprintf(fdat,"%s","  data_matrix ");
-                     }
-
-<DEFINE_DATA>init_3darray {
-    likelihood_found=1;
-    BEGIN IN_THREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  data_3array ");
-                     }
-
-
-<DEFINE_DATA>init_4darray {
-    likelihood_found=1;
-    BEGIN IN_FOUR_ARRAY_DEF;
-    fprintf(fdat,"%s","  data_4array ");
-                     }
-
-<DEFINE_DATA>init_5darray {
-    likelihood_found=1;
-    BEGIN IN_FIVE_ARRAY_DEF;
-    fprintf(fdat,"%s","  data_5array ");
-                     }
-
-
-<DEFINE_DATA>init_6darray {
-    likelihood_found=1;
-    BEGIN IN_SIX_ARRAY_DEF;
-    fprintf(fdat,"%s","  data_6array ");
-                     }
-
-
-<DEFINE_DATA>init_7darray {
-    likelihood_found=1;
-    BEGIN IN_SEVEN_ARRAY_DEF;
-    fprintf(fdat,"%s","  data_4array ");
-                     }
-
-
-<DEFINE_DATA>number {
-    likelihood_found=1;
-    BEGIN IN_NAMED_NUMBER_DEF;
-    fprintf(fdat,"%s","  double ");
-
-                     }
-
-<DEFINE_DATA>int {
-    likelihood_found=1;
-    BEGIN IN_NAMED_NUMBER_DEF;
-    fprintf(fdat,"%s","  int ");
-                     }
-
-<DEFINE_DATA>vector {
-    likelihood_found=1;
-    BEGIN IN_NAMED_VECTOR_DEF;
-    fprintf(fdat,"%s","  dvector ");
-                     }
-
-<DEFINE_DATA>ivector {
-    likelihood_found=1;
-    BEGIN IN_NAMED_VECTOR_DEF;
-    fprintf(fdat,"%s","  ivector ");
-                     }
-
-<DEFINE_DATA>matrix {
-    likelihood_found=1;
-    BEGIN IN_NAMED_MATRIX_DEF;
-    fprintf(fdat,"%s","  dmatrix ");
-                     }
-
-<DEFINE_DATA>imatrix {
-    likelihood_found=1;
-    BEGIN IN_NAMED_MATRIX_DEF;
-    fprintf(fdat,"%s","  imatrix ");
-                     }
-
-<DEFINE_DATA>3darray {
-    likelihood_found=1;
-    BEGIN IN_NAMED_THREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  d3_array ");
-                     }
-
-<DEFINE_DATA>4darray {
-    likelihood_found=1;
-    BEGIN IN_NAMED_FOUR_ARRAY_DEF;
-    fprintf(fdat,"%s","  d4_array ");
-                     }
-
-<DEFINE_DATA>5darray {
-    likelihood_found=1;
-    BEGIN IN_NAMED_FIVE_ARRAY_DEF;
-    fprintf(fdat,"%s","  d5_array ");
-                     }
-
-<DEFINE_DATA>6darray {
-    likelihood_found=1;
-    BEGIN IN_NAMED_FIVE_ARRAY_DEF;
-    fprintf(fdat,"%s","  d6_array ");
-                     }
-
-<DEFINE_DATA>7darray {
-    likelihood_found=1;
-    BEGIN IN_NAMED_FIVE_ARRAY_DEF;
-    fprintf(fdat,"%s","  d7_array ");
-                     }
-
-<IN_LOCAL_CALCS>^[ \t]END_CALCS | 
-<IN_LOCAL_CALCS>^[ \t]END_CALCULATIONS {
-
-    if (in_define_data) BEGIN DEFINE_DATA;
-    if (in_define_parameters) BEGIN DEFINE_PARAMETERS;
-      
-                  }
-
-<IN_LOCAL_CALCS>^[ \t][ \t].*$       {
-    fprintf(fall,"%s\n",yytext);
-          }
-
-<DEFINE_PARAMETERS>^[ \t]*!!CLASS.*$ {              // start with !!CLASSbbclassname classinstance(xxx)
-    num_user_classes++;
-    strip_leading_blanks_and_tabs(tmp_string1,yytext);
-    strcpy(tmp_string2,tmp_string1+7);  // now bbclassname classinstance(xxx)
-    strip_leading_blanks(tmp_string1,tmp_string2); // now classname classinstance(xxx)
-    initialize(tmp_string);
-    before_part(tmp_string,tmp_string1,'('); // now classname classinstance in tmp_string
-    if (!strlen(tmp_string)) 
-    {
-      strcpy(tmp_string,tmp_string1);
-    }  
-    //fprintf(fdat,"%s;\n",tmp_string);
-    before_partb(tmp_string2,tmp_string,' '); // now classname in tmp_string2
-    
-    after_partb(tmp_string3,tmp_string,' ');  // now bbclassinstance in tmp_string3
-    strip_leading_blanks(tmp_string4,tmp_string3);// now classinstance in tmp_string4
-    fprintf(fdat,"  %s * ",tmp_string2);
-    fprintf(fdat,"  pad_%s;\n",tmp_string4);
-    
-    fprintf(fall,"  pad_%s = new ",tmp_string4);
-    fprintf(fall,"%s",tmp_string2);
-    initialize(tmp_string3);
-    after_partb(tmp_string3,tmp_string1,'(');  // now xxx) in tmp_string3
-    if (strlen(tmp_string3))
-    {
-      fprintf(fall,"(%s",tmp_string3);
-    } 
-    fprintf(fall,";\n");
-    strcpy(reference_statements[num_user_classes-1],tmp_string2);
-    strcat(reference_statements[num_user_classes-1],"& ");
-    strcat(reference_statements[num_user_classes-1],tmp_string4);
-    strcat(reference_statements[num_user_classes-1],"= *pad_");
-    strcat(reference_statements[num_user_classes-1],tmp_string4);
-    //strcat(reference_statements[num_user_classes-1],";");
-    strcpy(class_instances[num_user_classes-1],tmp_string4);
-    
-  }
-
-<DEFINE_PARAMETERS>^[ \t]*!!USER_CODE.*$ {
-    strip_leading_blanks_and_tabs(tmp_string1,yytext);
-    strcpy(tmp_string2,tmp_string1+11);
-    fprintf(fall,"%s\n",tmp_string2);
-    
-    }
-
-<DEFINE_PARAMETERS>^[ \t]*!!.*$ {
-    strip_leading_blanks_and_tabs(tmp_string1,yytext);
-    strcpy(tmp_string2,tmp_string1+2);
-    fprintf(fall,"%s\n",tmp_string2);
-    
-    }
-
-<DEFINE_PARAMETERS>^[ \t]*LOCAL_CALCULATIONS | 
-<DEFINE_PARAMETERS>^[ \t]*LOCAL_CALCS |
-<DEFINE_PARAMETERS>^[ \t]*LOC_CALCULATIONS | 
-<DEFINE_PARAMETERS>^[ \t]*LOC_CALCS  {
-
-    BEGIN IN_LOCAL_CALCS;
-
-        }
-
-<DEFINE_PARAMETERS>number {
-
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  param_number ");
-    needs_initialization=1;
-                    }
-
-<DEFINE_PARAMETERS>objective_function_value {
-
-    in_objective_function_value_flag=1;
-    if(objective_function_defined++)
-    {
-      fprintf(stderr,"%s %d %s","Error in line",nline,"\n");
-      fprintf(stderr,"only one instance of objective_function_value" 
-                     " may be declared\n");
-      exit(1);
-    }
-    BEGIN IN_NUMBER_DEF2;
-    fprintf(fdat,"%s","  param_number prior_function_value;\n");
-    fprintf(fdat,"%s","  param_number likelihood_function_value;\n");    
-    fprintf(fdat,"%s","  objective_function_value ");
-                     }
-
-<DEFINE_PARAMETERS>sdreport_number {
-
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  param_stddev_number ");
-                     }
-
-<DEFINE_PARAMETERS>likeprof_number {
-
-    have_likeprof=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  param_likeprof_number ");
-                     }
-
-<DEFINE_PARAMETERS>init_int {
-	prior_found=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  param_init_int ");
-                     }
-
-<DEFINE_PARAMETERS>equality_constraint_vector {
-
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  equality_constraint_vector ");
-    needs_initialization=1;
-                     }
-<DEFINE_PARAMETERS>inequality_constraint_vector {
-
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  inequality_constraint_vector ");
-    needs_initialization=1;
-                     }
-
-<DEFINE_PARAMETERS>vector {
-
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  param_vector ");
-    needs_initialization=1;
-                     }
-
-<DEFINE_PARAMETERS>constant_quadratic_penalty {
-
-    BEGIN IN_NUMBER_DEF;
-    //BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  constant_quadratic_re_penalty ");
-    //needs_initialization=1;
-      quadratic_prior_flag=1;
-                     }
-
-<DEFINE_PARAMETERS>quadratic_penalty {
-
-    BEGIN IN_NUMBER_DEF;
-    //BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  df_normal_prior_");
-    //needs_initialization=1;
-      quadratic_classprint_flag=3;
-      quadratic_prior_flag=1;
-                     }
-
-<DEFINE_PARAMETERS>normal_prior |
-<DEFINE_PARAMETERS>gaussian_prior {
-
-    BEGIN IN_NUMBER_DEF;
-    //BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  df_normal_prior_");
-    //needs_initialization=1;
-      quadratic_prior_flag=1;
-      quadratic_classprint_flag=2;
-      need_prior_globals=1;
-                     }
-
-<DEFINE_PARAMETERS>quadratic_prior {
-
-    BEGIN IN_NUMBER_DEF;
-    //BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  quadratic_prior ");
-    //needs_initialization=1;
-      quadratic_prior_flag=1;
-                     }
-
-<DEFINE_PARAMETERS>sdreport_vector {
-
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  param_stddev_vector ");
-                     }
-
-<DEFINE_PARAMETERS>matrix {
-
-    BEGIN IN_MATRIX_DEF;
-    fprintf(fdat,"%s","  param_matrix ");
-    needs_initialization=1;
-                     }
-
-
-<DEFINE_PARAMETERS>sdreport_matrix {
-
-    BEGIN IN_MATRIX_DEF;
-    fprintf(fdat,"%s","  param_stddev_matrix ");
-                     }
-
-<DEFINE_PARAMETERS>3darray {
-
-    BEGIN IN_THREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_3array ");
-    needs_initialization=1;
-                     }
-
-
-<DEFINE_PARAMETERS>4darray {
-
-    BEGIN IN_FOUR_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_4array ");
-    needs_initialization=1;
-                     }
-
-<DEFINE_PARAMETERS>5darray {
-
-    BEGIN IN_FIVE_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_5array ");
-    needs_initialization=1;
-                     }
-
-<DEFINE_PARAMETERS>6darray {
-
-    BEGIN IN_SIX_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_6array ");
-    needs_initialization=1;
-                     }
-
-<DEFINE_PARAMETERS>7darray {
-
-    BEGIN IN_SEVEN_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_7array ");
-    needs_initialization=1;
-                     }
-
-
-<DEFINE_PARAMETERS>SPinit_number {
-
-    check_random_effects_ordering();
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPparam_init_number ");
-                     }
-
-<DEFINE_PARAMETERS>SPinit_bounded_number {
-
-    check_random_effects_ordering();
-    talk_to_splus=1;
-    BEGIN INIT_BOUNDED_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPparam_init_bounded_number ");
-                     }
-
-<DEFINE_PARAMETERS>SPinit_vector {
-
-    check_random_effects_ordering();
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPparam_init_vector ");
-                     }
-
-
-<DEFINE_PARAMETERS>SPinit_bounded_vector {
-
-    check_random_effects_ordering();
-    talk_to_splus=1;
-    BEGIN INIT_BOUNDED_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPparam_init_bounded_vector ");
-                     }
-
-<DEFINE_PARAMETERS>SPinit_matrix {
-
-    check_random_effects_ordering();
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPparam_init_matrix ");
-                     }
-
-<DEFINE_PARAMETERS>SPinit_bounded_matrix {
-
-    check_random_effects_ordering();
-    talk_to_splus=1;
-    BEGIN INIT_BOUNDED_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPparam_init_bounded_matrix ");
-                     }
-
-<DEFINE_PARAMETERS>SPinit_3darray {
-
-    check_random_effects_ordering();
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPparam_init_3array ");
-                     }
-
-<DEFINE_PARAMETERS>SPinit_bounded_3darray {
-
-    check_random_effects_ordering();
-    talk_to_splus=1;
-    BEGIN INIT_BOUNDED_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPparam_init_bounded_d3array ");
-                     }
-
-
-<DEFINE_DATA>SPinit_number {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPdata_number ");
-                     }
-
-<DEFINE_DATA>SPinit_int {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPdata_int ");
-                     }
-
-<DEFINE_DATA>SPinit_vector {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPdata_vector ");
-                     }
-
-<DEFINE_DATA>SPinit_ivector {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPdata_ivector ");
-                     }
-
-<DEFINE_DATA>SPinit_matrix {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPdata_matrix ");
-                     }
-
-<DEFINE_DATA>SPinit_imatrix {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPdata_imatrix ");
-                     }
-
-<DEFINE_DATA>SPinit_3darray {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPdata_3array ");
-                     }
-
-<DEFINE_DATA>SPinit_4darray {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPdata_4array ");
-                     }
-<DEFINE_DATA>SPnumber {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPnamed_number ");
-                     }
-
-<DEFINE_DATA>SPint {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPnamed_int ");
-                     }
-
-<DEFINE_DATA>SPvector {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPnamed_dvector ");
-                     }
-
-<DEFINE_DATA>SPivector {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPnamed_ivector ");
-                     }
-
-<DEFINE_DATA>SPmatrix {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPnamed_dmatrix ");
-                     }
-
-
-<DEFINE_PARAMETERS>splus_init_number |
-<DEFINE_PARAMETERS>dll_init_number {
-    check_random_effects_ordering();
-    spnumber_flag=1;
-    BEGIN IN_SPNUMBER_DEF;
-    fprintf(fdat,"%s","  dll_param_init_number ");
-                     }
-
-
-
-<DEFINE_PARAMETERS>splus_init_bounded_number |
-<DEFINE_PARAMETERS>dll_init_bounded_number {
-    check_random_effects_ordering();
-    spnumber_flag=1;
-    BEGIN IN_SPBOUNDED_NUMBER_DEF;
-    fprintf(fdat,"%s","  dll_param_init_bounded_number ");
-                     }
-
-
-<DEFINE_PARAMETERS>splus_number |
-<DEFINE_PARAMETERS>dll_number {
-    check_random_effects_ordering();
-    spnumber_flag=1;
-    BEGIN IN_SPNUMBER_DEF;
-    fprintf(fdat,"%s","  dll_param_number ");
-                     }
-
-<DEFINE_PARAMETERS>init_number {
-    check_random_effects_ordering();
-	prior_found=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  param_init_number ");
-                     }
-
-<DEFINE_PARAMETERS>init_number_vector {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  param_init_number_vector ");
-                     }
-
-<DEFINE_PARAMETERS>init_bounded_number {
-    prior_found=1;
-    check_random_effects_ordering();
-    BEGIN INIT_BOUNDED_NUMBER_DEF;
-    fprintf(fdat,"%s","  param_init_bounded_number ");
-                     }
-
-<DEFINE_PARAMETERS>init_bounded_number_vector {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN INIT_BOUNDED_VECTOR_DEF;
-    fprintf(fdat,"%s","  param_init_bounded_number_vector ");
-                     }
-
-<DEFINE_PARAMETERS>splus_init_vector |
-<DEFINE_PARAMETERS>dll_init_vector {
-
-    check_random_effects_ordering();
-    spnumber_flag=1;
-    BEGIN IN_SPVECTOR_DEF;
-    fprintf(fdat,"%s","  dll_param_init_vector ");
-                     }
-
-<DEFINE_PARAMETERS>splus_vector |
-<DEFINE_PARAMETERS>dll_vector {
-
-    check_random_effects_ordering();
-    spnumber_flag=1;
-    BEGIN IN_SPVECTOR_DEF;
-    fprintf(fdat,"%s","  dll_param_vector ");
-                     }
-
-<DEFINE_PARAMETERS>init_vector {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  param_init_vector ");
-                     }
-
-<DEFINE_PARAMETERS>random_effects_vector {
-	prior_found=1;
-    random_effects_flag=1;
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  random_effects_vector ");
-                     }
-
-<DEFINE_PARAMETERS>dll_random_effects_vector {
-
-    spnumber_flag=1;
-    random_effects_flag=1;
-    BEGIN IN_SPVECTOR_DEF;
-    fprintf(fdat,"%s","  dll_param_vector ");
-                     }
-
-
-
-
-
-
-<DEFINE_PARAMETERS>random_effects_bounded_vector {
-	prior_found=1;
-    random_effects_flag=1;
-    BEGIN INIT_BOUNDED_VECTOR_DEF;
-    fprintf(fdat,"%s","  random_effects_bounded_vector ");
-                     }
-
-<DEFINE_PARAMETERS>init_vector_vector {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN IN_MATRIX_DEF;
-    fprintf(fdat,"%s","  param_init_vector_vector ");
-                     }
-
-<DEFINE_PARAMETERS>init_bounded_dev_vector {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN INIT_BOUNDED_VECTOR_DEF;
-    fprintf(fdat,"%s","  param_init_bounded_dev_vector ");
-                     }
-
-<DEFINE_PARAMETERS>init_bounded_vector {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN INIT_BOUNDED_VECTOR_DEF;
-    fprintf(fdat,"%s","  param_init_bounded_vector ");
-                     }
-
-<DEFINE_PARAMETERS>init_bounded_vector_vector {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN INIT_BOUNDED_MATRIX_DEF;
-    fprintf(fdat,"%s","  param_init_bounded_vector_vector ");
-                     }
-
-<DEFINE_PARAMETERS>splus_init_bounded_vector |
-<DEFINE_PARAMETERS>dll_init_bounded_vector {
-
-    check_random_effects_ordering();
-    spnumber_flag=1;
-    BEGIN INIT_SPBOUNDED_VECTOR_DEF;
-    fprintf(fdat,"%s","  dll_param_init_bounded_vector ");
-                     }
-
-<DEFINE_PARAMETERS>splus_matrix |
-<DEFINE_PARAMETERS>dll_matrix {
-
-    spnumber_flag=1;
-    BEGIN IN_SPMATRIX_DEF;
-    fprintf(fdat,"%s","  dll_param_matrix ");
-                     }
-
-<DEFINE_PARAMETERS>splus_init_matrix |
-<DEFINE_PARAMETERS>dll_init_matrix {
-
-    check_random_effects_ordering();
-    spnumber_flag=1;
-    BEGIN IN_SPMATRIX_DEF;
-    fprintf(fdat,"%s","  dll_param_init_matrix ");
-                     }
-
-<DEFINE_PARAMETERS>init_matrix {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN IN_MATRIX_DEF;
-    fprintf(fdat,"%s","  param_init_matrix ");
-                     }
-
-<DEFINE_PARAMETERS>random_effects_matrix {
-	prior_found=1;
-    random_effects_flag=1;
-    BEGIN IN_MATRIX_DEF;
-    fprintf(fdat,"%s","  random_effects_matrix ");
-                     }
-
-<DEFINE_PARAMETERS>random_effects_bounded_matrix {
-	prior_found=1;
-    random_effects_flag=1;
-    BEGIN INIT_BOUNDED_MATRIX_DEF;
-    fprintf(fdat,"%s","  random_effects_bounded_matrix ");
-                     }
-
-<DEFINE_PARAMETERS>init_matrix_vector {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN IN_THREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_init_matrix_vector ");
-                     }
-
-<DEFINE_PARAMETERS>init_bounded_matrix {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN INIT_BOUNDED_MATRIX_DEF;
-    fprintf(fdat,"%s","  param_init_bounded_matrix ");
-                     }
-
-<DEFINE_PARAMETERS>init_bounded_matrix_vector {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN INIT_BOUNDED_THREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_init_bounded_matrix_vector ");
-                     }
-
-<DEFINE_PARAMETERS>splus_init_3darray |
-<DEFINE_PARAMETERS>dll_init_3darray {
-
-    spnumber_flag=1;
-    BEGIN IN_SPTHREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  dll_param_init_d3array ");
-                     }
-
-<DEFINE_PARAMETERS>splus_3darray |
-<DEFINE_PARAMETERS>dll_3darray {
-
-    spnumber_flag=1;
-    BEGIN IN_SPTHREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  dll_param_d3array ");
-                     }
-
-<DEFINE_PARAMETERS>init_3darray {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN IN_THREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_init_d3array ");
-                     }
-
-<DEFINE_PARAMETERS>init_4darray {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN IN_FOUR_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_init_4array ");
-                     }
-
-<DEFINE_PARAMETERS>init_5darray {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN IN_FIVE_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_init_5array ");
-                     }
-
-<DEFINE_PARAMETERS>init_bounded_3darray {
-	prior_found=1;
-    check_random_effects_ordering();
-    BEGIN INIT_BOUNDED_THREE_ARRAY_DEF;
-    fprintf(fdat,"%s","  param_init_bounded_d3array ");
-                     }
-
-
-<DEFINE_PARAMETERS>SPnumber {
-
-    talk_to_splus=1;
-    BEGIN IN_NUMBER_DEF;
-    fprintf(fdat,"%s","  SPnamed_dvariable ");
-                     }
-
-<DEFINE_PARAMETERS>SPvector {
-
-    talk_to_splus=1;
-    BEGIN IN_VECTOR_DEF;
-    fprintf(fdat,"%s","  SPnamed_dvar_vector ");
-                     }
-
-<DEFINE_PARAMETERS>SPmatrix {
-
-    talk_to_splus=1;
-    BEGIN IN_MATRIX_DEF;
-    fprintf(fdat,"%s","  SPnamed_dvar_matrix ");
-                     }
-
-<IN_SPNUMBER_DEF>{name} {
-    num_spargs++;
-    if (spnumber_flag==1)
-    {
-      strcpy(name_string,"double *");
-    }  
-    else if (spnumber_flag==2)
-    {
-      strcpy(name_string,"char **");
-    }  
-    else
-    {
-      strcpy(name_string,"int *");
-    }  
-    spnumber_flag=0;
-    
-    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,yytext);
-    classlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(conlist_ptr,",%s(_%s)",yytext,yytext);
-    else
-      nchar=sprintf(conlist_ptr," %s(_%s)",yytext,yytext);
-    conlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist_ptr,",%s_%s",name_string,yytext);
-    else
-      nchar=sprintf(arglist_ptr,"%s_%s",name_string,yytext);
-    arglist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist1_ptr,",_%s",yytext);
-    else
-      nchar=sprintf(arglist1_ptr,"_%s",yytext);
-    arglist1_ptr+=nchar;
-    
-    fprintf(fdat,"%s",yytext);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"  %s",yytext);
-    fprintf(fall,".allocate(ad_dll.%s,\"%s\");\n",yytext,yytext);
-
-    if (needs_initialization)
-    {
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"  %s",yytext);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      printf("IN_SP_NUMBER_DEF %s\n",yytext);
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_SPNUMBER_DEF>({name}\({num_exp}\)) {
-
-    num_spargs++;
-    if (spnumber_flag==1)
-    {
-      strcpy(name_string,"double *");
-    }  
-    else if (spnumber_flag==2)
-    {
-      strcpy(name_string,"char **");
-    }  
-    else
-    {
-      strcpy(name_string,"int *");
-    }  
-    spnumber_flag=0;
-    
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
-    classlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
-    else
-      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
-    conlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
-    else
-      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
-    arglist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
-    else
-      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
-    arglist1_ptr+=nchar;
-    
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    marker();
-    fprintf(fall,"%s",".allocate(ad_dll.");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    strict_after_part(tmp_string3,tmp_string2,'(');  // get x in x(1,4)
-    fprintf(fall,"%s,%s,\"%s\")",tmp_string,tmp_string3,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-
-                            }
-
-
-<IN_NUMBER_DEF>{name} {
-
-    if (quadratic_classprint_flag)
-    {
-      fprintf(fdat,"%s ",yytext);
-     /*
-      fprintf(fdat,"public:\n  void evaluate_%s(void);\nprivate:\n",yytext);
-     */
-      print_quadratic_random_effect_penalty_class(yytext);
-    }
-    else
-    {
-      fprintf(fdat," ");
-    }
-
-    fprintf(fdat,"%s",yytext);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"  %s",yytext);
-    fprintf(fall,".allocate(\"%s\");",yytext);
-    if (in_objective_function_value_flag)
-    {
-      fprintf(fall,"  /* ADOBJECTIVEFUNCTION */");
-        in_objective_function_value_flag=0;
-    }
-    fprintf(fall,"\n");
-
-    if (needs_initialization)
-    {
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"  %s",yytext);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",yytext);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      //printf("IN_NUMBER_DEF %s\n",yytext);
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",yytext);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NUMBER_DEF2>{name} {
-
-    if (quadratic_classprint_flag)
-    {
-      fprintf(fdat,"%s ",yytext);
-     /*
-      fprintf(fdat,"public:\n  void evaluate_%s(void);\nprivate:\n",yytext);
-     */
-      print_quadratic_random_effect_penalty_class(yytext);
-    }
-    else
-    {
-      fprintf(fdat," ");
-    }
-
-    fprintf(fdat,"%s",yytext);
-    fprintf(fdat,"%s",";\n");
-    
-    strcpy(objective_function_name_string,yytext);  // get objective function name
-    fprintf(fall,"%s","  prior_function_value.allocate(\"prior_function_value\");\n");
-    fprintf(fall,"%s","  likelihood_function_value.allocate(\"likelihood_function_value\");\n");
-    
-    fprintf(fall,"  %s",yytext);
-    fprintf(fall,".allocate(\"%s\");",yytext);
-    if (in_objective_function_value_flag)
-    {
-      fprintf(fall,"  /* ADOBJECTIVEFUNCTION */");
-        in_objective_function_value_flag=0;
-    }
-    fprintf(fall,"\n");
-
-    if (needs_initialization)
-    {
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"  %s",yytext);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      //printf("IN_NUMBER_DEF %s\n",yytext);
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-                            
-                            
-                            
-<IN_NAMED_NUMBER_DEF>{name} {
-
-    fprintf(fdat,"%s",yytext);
-    fprintf(fdat,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",yytext);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NUMBER_DEF>({name}\({num_exp}\)) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    if (quadratic_classprint_flag)
-    {
-      fprintf(fdat,"%s ",tmp_string);
-      fprintf(fdat," ");
-      fprintf(fdat,"%s;\n",tmp_string);
-     /*
-      fprintf(fdat,"public:\n  void evaluate_%s(void);\nprivate:\n",tmp_string);
-     */
-      print_quadratic_random_effect_penalty_class(tmp_string);
-    }
-    else
-    {
-      fprintf(fdat," ");
-      fprintf(fdat,"%s;\n",tmp_string);
-    }
-
-
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    /*fprintf(fdat,"%s",";\n");*/
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-
-                            }
-
-
-<INIT_BOUNDED_NUMBER_DEF>({name}\({float_num_exp},{float_num_exp},{num_exp}\)) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-
-                            }
-
-
-
-<IN_SPBOUNDED_NUMBER_DEF>({name}\({float_num_exp},{float_num_exp},{num_exp}\)) |
-<IN_SPBOUNDED_NUMBER_DEF>({name}\({float_num_exp},{float_num_exp}\)) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    //fprintf(fall,"%s",".allocate");
-    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
-    
-
-    num_spargs++;
-    if (spnumber_flag==1)
-    {
-      strcpy(name_string,"double *");
-    }  
-    else if (spnumber_flag==2)
-    {
-      strcpy(name_string,"char **");
-    }  
-    else
-    {
-      strcpy(name_string,"int *");
-    }  
-    spnumber_flag=0;
-    
-    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
-    classlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
-    else
-      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
-    conlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
-    else
-      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
-    arglist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
-    else
-      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
-    arglist1_ptr+=nchar;
-    
-    
-    
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-
-                            }
-
-
-
-
-
-
-
-<INIT_BOUNDED_NUMBER_DEF>({name}\({float_num_exp},{float_num_exp}\)) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-
-                            }
-
-
-<IN_VECTOR_DEF>{name}\({num_exp},{num_exp}\) |
-<IN_VECTOR_DEF>{name}\({num_exp},{name}\) |
-<IN_VECTOR_DEF>{name}\({name},{num_exp}\) |
-<IN_VECTOR_DEF>{name}\({name},{name}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";");
-    if (quadratic_prior_flag)
-    {
-      fprintf(fdat,"   /* deleteXquadraticXprior */ ");
-      fprintf(fall,"   /* deleteXquadraticXprior */ ");
-      quadratic_prior_flag=0;
-    }
-    fprintf(fdat,"%s","\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_VECTOR_DEF>{name} {
-
-    strcpy(tmp_string,yytext);  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    //after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    //before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"(\"%s\")",tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      /*
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      */
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_VECTOR_DEF>{name}\({num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_SPVECTOR_DEF>{name}\({num_exp},{num_exp}\) |
-<IN_SPVECTOR_DEF>{name}\({num_exp},{num_exp},{num_exp}\) {
-
-    //fprintf(fall,".allocate(ad_dll.%s,\"%s\");\n",yytext,yytext);
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    //fprintf(fall,"%s",".allocate");
-    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
-    
-    
-// ****************************************************************
-
-    num_spargs++;
-    if (spnumber_flag==1)
-    {
-      strcpy(name_string,"double *");
-    }  
-    else if (spnumber_flag==2)
-    {
-      strcpy(name_string,"char **");
-    }  
-    else
-    {
-      strcpy(name_string,"int *");
-    }  
-    spnumber_flag=0;
-    
-    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
-    classlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
-    else
-      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
-    conlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
-    else
-      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
-    arglist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
-    else
-      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
-    arglist1_ptr+=nchar;
-    
-// ****************************************************************
-    
-    
-    
-    
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<INIT_SPBOUNDED_VECTOR_DEF>{name}\({num_exp},{num_exp},{float_num_exp},{float_num_exp}\) |
-<INIT_SPBOUNDED_VECTOR_DEF>{name}\({num_exp},{num_exp},{float_num_exp},{float_num_exp},{num_exp}\) {
-
-    //fprintf(fall,".allocate(ad_dll.%s,\"%s\");\n",yytext,yytext);
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    //fprintf(fall,"%s",".allocate");
-    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
-    
-    
-// ****************************************************************
-
-    num_spargs++;
-    if (spnumber_flag==1)
-    {
-      strcpy(name_string,"double *");
-    }  
-    else if (spnumber_flag==2)
-    {
-      strcpy(name_string,"char **");
-    }  
-    else
-    {
-      strcpy(name_string,"int *");
-    }  
-    spnumber_flag=0;
-    
-    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
-    classlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
-    else
-      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
-    conlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
-    else
-      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
-    arglist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
-    else
-      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
-    arglist1_ptr+=nchar;
-    
-// ****************************************************************
-    
-    
-    
-    
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-<IN_NAMED_VECTOR_DEF>{name}\({num_exp},{num_exp}\) |
-<IN_NAMED_VECTOR_DEF>{name}\({num_exp},{name}\) |
-<IN_NAMED_VECTOR_DEF>{name}\({name},{num_exp}\) |
-<IN_NAMED_VECTOR_DEF>{name}\({name},{name}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-<IN_NAMED_VECTOR_DEF>{name} {
-
-    if (warn_unallocated) write_unallocated("vector()");
-    strcpy(tmp_string,yytext);  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate()");
-    //fprintf(fall,"(\"%s\")",tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-<INIT_BOUNDED_VECTOR_DEF>{name}\({num_exp},{num_exp},{float_num_exp},{float_num_exp}\)    {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-<INIT_BOUNDED_VECTOR_DEF>{name}\({num_exp},{num_exp},{float_num_exp},{float_num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) |
-<IN_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_MATRIX_DEF>{name}\({num_exp},{num_exp}\) {
-
-    if (warn_unallocated) write_unallocated("matrix(ix,iy)");
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      /*
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      */
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_MATRIX_DEF>{name} {
-
-    if (warn_unallocated) write_unallocated("matrix()");
-    strcpy(tmp_string,yytext);  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    fprintf(fall,"(\"%s\")",tmp_string);
-    //before_part(tmp_string2,tmp_string1,')');
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      /*
-      XXXX
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-      */
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-<IN_TABLE_DEF>{name}\({filename}\) {
-
-    before_part(tmp_string,yytext,'(');  // get A in A("mat.tab")
- 
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fdat,"%s",";\n");
- 
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,".allocate(0,-1,0,-1,\"%s\");\n",tmp_string);
-    after_part(tmp_string1,yytext,'\"');
-    fprintf(fall,"  dmatrix %s_tmp((adstring)%s;\n",tmp_string,tmp_string1);
-    fprintf(fall,"  %s = %s_tmp;\n",tmp_string,tmp_string);
-    if (needs_initialization)
-    {
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_TABLE_DEF>{name}\({filenamesingle}\) {
-    fprintf(stderr,"%s %d %s","Error in line",nline,"while reading (use double instead of single quotes)\n");
-    exit(1);
-                            }
-
-<IN_TABLE_DEF>{name} {
-    fprintf(fdat,"%s",yytext);
-    fprintf(fdat,"%s",";\n");
- 
-    fprintf(fall,"  %s",yytext);
-    fprintf(fall,".allocate(0,-1,0,-1,\"%s\");\n",yytext);
-    fprintf(fall,"  adstring datname;\n");
-    fprintf(fall,"  if(option_match(argc,argv,\"-ind\") > -1){ \n");
-    fprintf(fall,"    datname = argv[option_match(argc,argv,\"-ind\") + 1];\n");
-    fprintf(fall,"  }else{\n");
-    fprintf(fall,"    datname = \"%s.dat\";\n",infile_root);
-    fprintf(fall,"  }\n");
-    fprintf(fall,"  dmatrix %s_tmp(datname);\n",yytext);
-    fprintf(fall,"  %s = %s_tmp;\n",yytext,yytext);
-
-    if (needs_initialization)
-    {
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",yytext);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-<IN_TABLE_DEF>{name}\({name}\) {
-    before_part(tmp_string,yytext,'(');  // get A in A(str1)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fdat,"%s",";\n");
- 
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,".allocate(0,-1,0,-1,\"%s\");\n",tmp_string);
-
-    strict_after_part(tmp_string1, yytext,'(');
-    fprintf(fall,"  dmatrix %s_tmp((adstring)%s;\n",tmp_string,tmp_string1);
-    fprintf(fall,"  %s = %s_tmp;\n",tmp_string,tmp_string);
-    if (needs_initialization)
-    {
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-
-
-<IN_SPMATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) |
-<IN_SPMATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    //fprintf(fall,"%s",".allocate");
-    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-// ****************************************************************
-
-    num_spargs++;
-    if (spnumber_flag==1)
-    {
-      strcpy(name_string,"double *");
-    }  
-    else if (spnumber_flag==2)
-    {
-      strcpy(name_string,"char **");
-    }  
-    else
-    {
-      strcpy(name_string,"int *");
-    }  
-    spnumber_flag=0;
-    
-    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
-    classlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
-    else
-      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
-    conlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
-    else
-      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
-    arglist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
-    else
-      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
-    arglist1_ptr+=nchar;
-    
-// ****************************************************************
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-<IN_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) |
-<IN_THREE_ARRAY_DEF>{name}\({index},{index},{index},{index},{index},{index},{index}\) |
-<IN_THREE_ARRAY_DEF>{name}\({index},{index},{index},{index},{index},{index}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) |
-<IN_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp}\) {
-
-    if (warn_unallocated) write_unallocated("3darray(ix,iy)");
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      /*
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      */
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_THREE_ARRAY_DEF>{name} {
-
-    if (warn_unallocated) write_unallocated("3darray()");
-    strcpy(tmp_string,yytext);  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    //after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    //before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"(\"%s\")",tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      /*
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      */
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_SPTHREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) |
-<IN_SPTHREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    //fprintf(fall,"%s",".allocate");
-    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-// ****************************************************************
-
-    num_spargs++;
-    if (spnumber_flag==1)
-    {
-      strcpy(name_string,"double *");
-    }  
-    else if (spnumber_flag==2)
-    {
-      strcpy(name_string,"char **");
-    }  
-    else
-    {
-      strcpy(name_string,"int *");
-    }  
-    spnumber_flag=0;
-    
-    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
-    classlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
-    else
-      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
-    conlist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
-    else
-      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
-    arglist_ptr+=nchar;
-    
-    if (num_spargs>1)
-      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
-    else
-      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
-    arglist1_ptr+=nchar;
-    
-// ****************************************************************
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) |
-<IN_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) |
-<IN_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      /*
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      */
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_FOUR_ARRAY_DEF>{name} {
-
-    strcpy(tmp_string,yytext);  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    //after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    //before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"(\"%s\")",tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      /*
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      */
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_FIVE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_SIX_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_SEVEN_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (needs_initialization)
-    {
-      before_part(tmp_string,yytext,'('); 
-      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
-      fprintf(fall,"    %s",tmp_string);
-      fprintf(fall,".initialize();\n");
-      fprintf(fall,"  #endif\n");
-      needs_initialization=0;
-    }
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-
-<IN_NAMED_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_MATRIX_DEF>{name}\({num_exp},{num_exp}\) {
-    if (warn_unallocated) write_unallocated("matrix(i1,i2)");
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_MATRIX_DEF>{name} {
-    if (warn_unallocated) write_unallocated("matrix()");
-
-    strcpy(tmp_string,yytext);  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate()");
-    //after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    //before_part(tmp_string2,tmp_string1,')');
-    //fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<INIT_BOUNDED_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{float_num_exp},{float_num_exp}\)    {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-			    }
-
-
-<INIT_BOUNDED_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{float_num_exp},{float_num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<INIT_BOUNDED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{float_num_exp},{float_num_exp}\)    {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-			    }
-
-
-<INIT_BOUNDED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{float_num_exp},{float_num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      if(prior_found) {
-        if(prior_counter<MAX_PRIOR_CHECK) sprintf(prior_checker[prior_counter++],"%s",tmp_string);
-        prior_found=0;
-      }
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) |
-<IN_NAMED_THREE_ARRAY_DEF>{name}\({num_exp},{name},{num_exp},{num_exp},{num_exp},{num_exp}\) |
-<IN_NAMED_THREE_ARRAY_DEF>{name}\({index},{index},{index},{index},{index},{index}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) {
-    if (warn_unallocated) write_unallocated("3darray(i1,i2,j1,j2)");
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp}\) {
-    if (warn_unallocated) write_unallocated("3darray(i1,i2)");
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_THREE_ARRAY_DEF>{name} {
-    if (warn_unallocated) write_unallocated("3darray()");
-
-    strcpy(tmp_string,yytext);  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_FIVE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_SIX_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-<IN_NAMED_SEVEN_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
-
-    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
-    fprintf(fdat,"%s",tmp_string);
-    fprintf(fall,"  %s",tmp_string);
-    fprintf(fall,"%s",".allocate");
-    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
-    before_part(tmp_string2,tmp_string1,')');
-    fprintf(fall,"%s)",tmp_string2);
-    fprintf(fdat,"%s",";\n");
-    fprintf(fall,"%s",";\n");
-    if (!params_defined)
-    {
-      if(likelihood_found) {
-        if(likelihood_counter<MAX_LIKE_CHECK) sprintf(likelihood_checker[likelihood_counter++],"%s",tmp_string);
-        likelihood_found=0;
-      }
-      BEGIN DEFINE_DATA;
-    }
-    else
-    {
-      BEGIN DEFINE_PARAMETERS;
-    }
-                            }
-
-
-<DEFINE_PRIORS>{prior_name}[ \t]*[~][ \t]*{prior_def} {    //for priors_section 
-    before_part(tmp_string,yytext,'~');  // get x in x~10, parameter name
-    strict_after_part(tmp_string1,yytext,'~');  // get 10  in x~10
-    before_part(tmp_string2,tmp_string1,'(');   //function name
-    strict_after_part(tmp_string3,tmp_string1,'(');  //function input arg.   
-    //printf("%s\n %s \t %s \t %s \t %s",yytext,tmp_string,tmp_string1,tmp_string2,tmp_string3);
-    
-    trim(tmp_string2); //function name
-    //strcpy(tmp_string4,"prior_");
-    //strcat(tmp_string4,tmp_string2); //define prior_** in priors.cpp file, should be neg.log.likelihood.form
-    trim(tmp_string); trim(tmp_string3);
-   
-    int i=0; //check if the prior variable from init_ parameter section
-    while(prior_check(prior_checker[i],tmp_string)!=0){
-      //printf(" idx %d tot %d, prior %s, parameter %s\n",i,prior_counter, tmp_string,prior_checker[i]);    
-      if(i == (prior_counter-1)){//still not found for the last one
-        printf("Warning: Prior ( %s ) is not defined on a parameter\n",tmp_string);
-        break;
-      }
-      i++;
-    }
-    
-    if(prior_function_toggle==0) 
-    { //left side of ~ go to first argument in function argu. list
-      fprintf(fall,"  tmp__prior=%s(%s,%s ;\n",tmp_string2,tmp_string,tmp_string3);
-      fprintf(fall,"  prior_function_value+=tmp__prior;\n ");
-      fprintf(fall,"%s%s%s","  ",objective_function_name_string,"+=tmp__prior"); 
-    }
-    else
-    { //left side of ~ go to the last argument in function argu. list
-      before_partb(tmp_string4,tmp_string3,')'); 
-      fprintf(fall,"  tmp__prior=%s(%s,%s);\n",tmp_string2,tmp_string4,tmp_string);
-      fprintf(fall,"  prior_function_value+=tmp__prior;\n ");
-      fprintf(fall,"%s%s%s","  ",objective_function_name_string,"+=tmp__prior"); 
-    }
-                   }
-                   
-
-
-<DEFINE_LIKELIHOOD>{prior_name}[ \t]*[~][ \t]*{prior_def} { //for likelihood_section   
-    before_part(tmp_string,yytext,'~');  // get x in x~10, parameter name
-    strict_after_part(tmp_string1,yytext,'~');  // get 10  in x~10
-    before_part(tmp_string2,tmp_string1,'(');   //function name
-    strict_after_part(tmp_string3,tmp_string1,'(');  //function input arg.
-    
-    trim(tmp_string2); //function name
-    //strcat(like_str,tmp_string2); //define like_** in priors.cpp file, should be neg.log.likelihood.form
-    trim(tmp_string); trim(tmp_string3);
-  
-    int i=0; //check if the likelihood variable from data section
-    while(prior_check(likelihood_checker[i],tmp_string)!=0){
-      //printf(" idx %d tot %d, %s, %s\n",i,likelihood_counter, tmp_string,likelihood_checker[i]);    
-      if(i == (likelihood_counter-1)){//still not found for the last one
-        printf("Warning: likelihood ( %s ) is not defined on a data_section variable\n",tmp_string);
-        break;
-      }
-      i++;
-    }
-   
-    if(prior_function_toggle==0) 
-    { //left side of ~ go to first argument in function argu. list
-      fprintf(fall,"  tmp__like=%s(%s,%s ;\n",tmp_string2,tmp_string,tmp_string3);
-      fprintf(fall,"  likelihood_function_value+=tmp__like;\n ");
-      fprintf(fall,"%s%s%s","  ",objective_function_name_string,"+=tmp__like"); 
-    }
-    else
-    { //left side of ~ go to the last argument in function argu. list
-      before_partb(tmp_string4,tmp_string3,')'); 
-      fprintf(fall,"  tmp__like=%s(%s,%s);\n",tmp_string2,tmp_string4,tmp_string);
-      fprintf(fall,"  likelihood_function_value+=tmp__like;\n ");
-      fprintf(fall,"%s%s%s","  ",objective_function_name_string,"+=tmp__like"); 
-    }
-                   }
-
-
-<DEFINE_PROCEDURE>{prior_name}[ \t]*[~][ \t]*{prior_def} {    //for procedure_section 
-    before_part(tmp_string,yytext,'~');  // get x in x~10, parameter name
-    strict_after_part(tmp_string1,yytext,'~');  // get 10  in x~10
-    before_part(tmp_string2,tmp_string1,'(');   //function name
-    strict_after_part(tmp_string3,tmp_string1,'(');  //function input arg.   
-    
-    trim(tmp_string2);  //function name, should be neg.log.likelihood.form
-    trim(tmp_string); trim(tmp_string3);
-    if(prior_function_toggle==0) 
-    { //left side of ~ go to first argument in function argu. list
-      fprintf(fall,"  %s +=%s(%s,%s",objective_function_name_string,tmp_string2,tmp_string,tmp_string3);
-    }
-    else
-    { //left side of ~ go to the last argument in function argu. list
-      before_partb(tmp_string4,tmp_string3,')'); 
-      fprintf(fall,"  %s +=%s(%s,%s)",objective_function_name_string,tmp_string2,tmp_string4,tmp_string);
-    }
-                   }
-                   
-                   
-
-
-; {
-  if(priors_defined && (!priors_done)){
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_PRIORS;
-  }
-  if(likelihood_defined && (!likelihood_done)){
-   	if(priors_defined) priors_done=1; //turn off prior
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_LIKELIHOOD;
-  }
-  /*
-  if(procedure_defined && (!procedure_done)){
-   	if(priors_defined) priors_done=1;
-   	if(likelihood_defined) likelihood_done=1;
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_PROCEDURE;
-  }
-  */
-  //;             /* ignore semi colons */ ;
-  }
-  
-
-[ \t]+ {
-  if(priors_defined && (!priors_done)){
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_PRIORS;
-  }
-  if(likelihood_defined && (!likelihood_done)){
-   	priors_done=1;
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_LIKELIHOOD;
-  }
-  /*
-  if(procedure_defined && (!procedure_done)){
-   	priors_done=1;likelihood_done=1;
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_PROCEDURE;
-  }
-  */
-  //[ \t]+        /* ignore blanks */  ;
-  }
-
-
-\n { 
-  if(priors_defined && (!priors_done)){
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_PRIORS;
-  }
-  if(likelihood_defined && (!likelihood_done)){
-   	priors_done=1;
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_LIKELIHOOD;
-  }
-  /*
-  if(procedure_defined && (!procedure_done)){
-   	priors_done=1;likelihood_done=1;
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_PROCEDURE;
-  }
-  */
-  nline++; 			
-  }
-  
-  
-  
-. {
-  if(priors_defined && (!priors_done)){
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_PRIORS;
-  }
-  else if(likelihood_defined && (!likelihood_done)){
-   	priors_done=1;
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_LIKELIHOOD;
-  }
-  /*
-  else if(procedure_defined && (!procedure_done)){
-   	priors_done=1;likelihood_done=1;
-   	fprintf(fall,"%s",yytext); 
-	BEGIN DEFINE_PROCEDURE;
-  }
-  */
-  else{
-	fprintf(stderr,"%s %d %s","Error in line",nline,"while reading\n");
-	fprintf(stderr,"%s\n",yytext);
-	exit(1);
-  }
-  }
-
-
-
-
-PARAMETER_SECTION {
-    if (!data_defined)
-    {
-      fprintf(stderr,"Error DATA_SECTION must be defined before"
-        " PARAMETER SECTION\n");
-      exit(1);
-    }
-    if(!params_defined) BEGIN DEFINE_PARAMETERS;
-    in_define_data=0;
-    in_define_parameters=1;
-    params_defined=1;
-
-    fprintf(fdat,"  ~model_data();\n");
-    if (makedll)
-      fprintf(fdat,"  model_data(int argc,char * argv[],dll_args&);\n  friend class model_parameters;\n");
-    else  
-      fprintf(fdat,"  model_data(int argc,char * argv[]);\n  friend class model_parameters;\n");
-    fprintf(fdat,"%s","};\n\nclass model_parameters : "
-      "public model_data ,"
-      "\n  public function_minimizer\n{\n");
-    fprintf(fdat,"%s","public:\n");
-    fprintf(fdat,"%s","  friend class df1b2_pre_parameters;\n"); //add by liu
-    fprintf(fdat,"%s","  friend class df1b2_parameters;\n");  //add by liu
-
-    fprintf(fdat,"  static model_parameters * model_parameters_ptr;\n"
-      "  static model_parameters * get_model_parameters_ptr(void)\n"
-      "  {\n"
-      "    return model_parameters_ptr;\n"
-      "  }\n");
-
-    fprintf(fdat,"  ~model_parameters();\n");
-//    fprintf(fdat,"%s","  void admaster_slave_variable_interface(void);\n");
-    fprintf(fdat,"%s","  void preliminary_calculations(void);\n"); 
-    fprintf(fdat,"%s","  void set_runtime(void);\n"); 
-    fprintf(fdat,"%s","  virtual void * mycast(void) {return (void*)this;}\n");
-
-    fprintf(fdat,"%s", "  static int mc_phase(void)\n"
-      "  {\n    return initial_params::mc_phase;\n  }\n");
-      
-    fprintf(fdat,"%s", "  static int mceval_phase(void)\n"
-      "  {\n    return initial_params::mceval_phase;\n  }\n");
-      
-    fprintf(fdat,"%s", "  static int sd_phase(void)\n"
-      "  {\n    return initial_params::sd_phase;\n  }\n");
- 
-   fprintf(fdat,"%s", "  static int current_phase(void)\n"
-      "  {\n    return initial_params::current_phase;\n  }\n");
-    fprintf(fdat,"%s", "  static int last_phase(void)\n"
-      "  {\n    return (initial_params::current_phase\n"
-      "      >=initial_params::max_number_phases);\n  }\n");
-   fprintf(fdat,"%s", "  static prevariable current_feval(void)\n"
-      "  {\n    return *objective_function_value::pobjfun;\n  }\n");
-
-   /*
-    if (random_effects_flag)
-    {
-
-      fprintf(fdat,"%s", "  void AD_uf_inner(const dvector& x,"
-        "const dvar_vector& u);\n"
-        "  void AD_uf_outer(const dvar_vector& x,"
-        "const dvar_vector& u);\n");
-    }
-    */
-
-    fprintf(fdat,"%s","private:\n");
-    fprintf(fdat,"%s", "  ivector integer_control_flags;\n");
-    fprintf(fdat,"%s", "  void begin_df1b2_funnel(void);\n");
-    fprintf(fdat,"%s", "  void end_df1b2_funnel(void);\n");
-  
-    fprintf(fdat,"%s", "  dvector double_control_flags;\n");
-    fclose(fdat);
-    fdat=fopen("tfile2","w+");
-    if (fdat==NULL)
-    {
-      fprintf(stderr,"Error trying to open file tfile2\n");
-    }
-    
-    if (makedll)
-    {
-      fprintf(fall,"%s","}\n\nmodel_parameters::model_parameters"
-        "(int sz,int argc,char * argv[], dll_args& ad_dll) : "
-        "\n model_data(argc,argv,ad_dll) , function_minimizer(sz)\n{\n");
-  //        "\n ad_comm(argc,argv), model_data(ad_dll) , function_minimizer(sz)\n{\n");
-    }
-    else	
-    {
-      fprintf(fall,"%s","}\n\nmodel_parameters::model_parameters"
-        "(int sz,int argc,char * argv[]) : "
-        "\n model_data(argc,argv) , function_minimizer(sz)\n{\n");
-    }
-    fprintf(fall,"%s", "  model_parameters_ptr=this;\n");
-    fprintf(fall,"%s", "  initializationfunction();\n");
-    fclose(fall);
-    fall=fopen("xxalloc2.tmp","w+");
-    if (fall==NULL)
-    {
-      fprintf(stderr,"%s","Error trying to open file xxalloc2.tmp\n");
-    }
-
-                  }
-
-PROCEDURE_SECTION {
-
-    /* int i; */
-
-    if (!data_defined)
-    {
-      fprintf(stderr,"Error -- DATA_SECTION must be defined before"
-        " PROCEDURE SECTION\n OR PARAMETER SECTION\n");
-      exit(1);
-    }
-    if (!params_defined)
-    {
-      fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
-        " PROCEDURE SECTION\n");
-      exit(1);
-    }
-    
-    if (!objective_function_defined)
-    {
-      fprintf(stderr,"Error -- You must define an object of type objective"
-        "_function_value in the\nPARAMETER SECTION"
-        "and assign the approriate value to it in the\nPROCEDURE_SECTION");
-      exit(1);
-    }
-    BEGIN DEFINE_PROCS;
-    //BEGIN DEFINE_PROCEDURE;
-    procedure_defined=1;
-    in_procedure_def=1;
-    in_define_parameters=0;
-
-    fclose(fdat);
-    fdat=fopen("tfile3","w+");
-    if (fdat==NULL)
-    {
-      fprintf(stderr,"Error trying to open file tfile3\n");
-    }
-
-    if (makedll)
-    {
-      fprintf(fdat,"public:\n  virtual void userfunction(void);\n"
-        "  virtual void report(void);\n" // define this to get a report
-        "  virtual void final_calcs(void);\n" 
-        "  model_parameters(int sz,int argc, char * argv[],"
-        " dll_args& ad_dll);\n");
-    }
-    else	
-    {
-      fprintf(fdat,"public:\n  virtual void userfunction(void);\n"
-        "  virtual void report(void);\n" // define this to get a report
-        "  virtual void final_calcs(void);\n" 
-        "  model_parameters(int sz,int argc, char * argv[]);\n");
-    }    
-    if(!initialization_defined)
-    {
-      fprintf(fdat,"  virtual void initializationfunction(void){}\n");
-    }
-    else  
-    {
-      fprintf(fdat,"  virtual void initializationfunction(void);\n");
-    }
-
-    if (random_effects_flag)
-    {
-
-      fprintf(fdat,"%s", "  virtual void AD_uf_inner(void){pre_userfunction();}\n"
-        "  virtual void AD_uf_outer(void){pre_userfunction();}\n"
-        /*"  virtual void user_function(const init_df1b2vector& x,"
-        "df1b2variable& f){;}\n" */
-        "  virtual void user_function(void){;}\n"
-        "  virtual void allocate(void){;}\n");
-    }
-    fclose(fdat);
-    fdat=fopen("tfile4","w+");
-    if (fdat==NULL)
-    {
-      fprintf(stderr,"Error trying to open file tfile\n");
-    }
-
-   /* fprintf(fdat,"%s","};\n");*/
-    fprintf(fall,"%s","}\n");
-    fclose(fall);
-    fall=fopen("xxalloc3.tmp","w+");
-    if (fall==NULL)
-    {
-      fprintf(stderr,"%s","Error trying to open file xxalloc3.tmp\n");
-    }
-    fprintf(fall,"%s","void model_parameters::userfunction(void)"
-      "\n{\n");
-    fprintf(fall,"  %s%s",objective_function_name_string," =0.0;\n");
-    add_references_to_user_classes(fall);  
-                  }
-
-
-PRIORS_SECTION |
-PRIOR_SECTION {
-  if (!data_defined)
-  {
-    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
-      " PRIORS_SECTION \n");
-    exit(1);
-  }
-  if (!params_defined)
-  {
-    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
-      " PRIORS_SECTION \n");
-    exit(1);
-  }
-  if (preliminary_calcs_defined)
-  {
-    fprintf(stderr,"%s","Error -- PRIORS_SECTION must be defined before PRELIMINARY_CALCS_SECTION\n");
-    exit(1);
-  }    
-  if (likelihood_defined)
-  {
-    fprintf(stderr,"%s","Error -- PRIORS_SECTION must be defined before"
-      " LIKELIHOOD_SECTION \n");
-	  exit(1);
-  } 
-  if (procedure_defined)
-  {
-    fprintf(stderr,"Error -- PRIOR_SECTION must be defined before"
-      " PROCEDURE_SECTION \n");
-    exit(1);
-  }
-  if (priors_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one PRIORS_SECTION allowed\n");
-    exit(1);
-  }  
-  else
-  {
-    BEGIN DEFINE_PRIORS; 
-    priors_defined=1; 
-    
-    /* //don't know why the following block not working, add by liu
-    fprintf(fall,"%s","}\n");
-    fclose(fall);
-    fall=fopen("xxalloc3.tmp","w+");
-    if (fall==NULL)
-    {
-      fprintf(stderr,"%s","Error trying to open file xxalloc2.tmp\n");
-    }
-    fprintf(fall,"%s","\nvoid model_parameters::priorsfunction(void)" "\n{\n");
-    */  
-     
-    fprintf(fall,"%s","}\n\nvoid model_parameters::priorsfunction(void)" "\n{\n");
-    fprintf(fall,"%s","  prior_function_value=0.0;\n");
-    fprintf(fall,"%s","  dvariable tmp__prior=0.0;\n");
-  }
-  }
-
-
-
-LIKELIHOODS_SECTION |
-LIKELIHOOD_SECTION {
-  if (!data_defined)
-  {
-    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
-      " PRIORS_SECTION \n");
-    exit(1);
-  }
-  if (!params_defined)
-  {
-    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
-      " PRIORS_SECTION \n");
-    exit(1);
-  }
-  if (preliminary_calcs_defined)
-  {
-    fprintf(stderr,"%s","Error -- LIKELIHOOD_SECTION must be defined before PRELIMINARY_CALCS_SECTION\n");
-    exit(1);
-  }    
-  if (procedure_defined)
-  {
-    fprintf(stderr,"Error -- LIKELIHOOD_SECTION must be defined before"
-      " PROCEDURE_SECTION \n");
-    exit(1);
-  }
-  if (likelihood_defined)
-  {
-    fprintf(stderr,"%s","Error -- only one LIKELIHOOD_SECTION allowed\n");
-    exit(1);
-  }  
-  else
-  {	
-    BEGIN DEFINE_LIKELIHOOD;
-    likelihood_defined=1;
-    
-    /* //don't know why the following block not working, add by liu
-    fprintf(fall,"%s","}\n");
-    fclose(fall);
-    fall=fopen("xxalloc3.tmp","w+");
-    if (fall==NULL)
-    {
-      fprintf(stderr,"%s","Error trying to open file xxalloc2.tmp\n");
-    }
-    fprintf(fall,"%s","\nvoid model_parameters::likelihoodfunction(void)" "\n{\n");
-    */
-    
-    fprintf(fall,"%s","}\n\nvoid model_parameters::likelihoodfunction(void)" "\n{\n");
-    fprintf(fall,"%s","  likelihood_function_value=0.0;\n");
-    fprintf(fall,"%s","  dvariable tmp__like=0.0;\n");
-  }
-  }
-
-
-
-
-
-FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
-    if (!in_procedure_def)
-    {
-      fprintf(stderr,"Error -- FUNCTION must be used within the"
-        " PROCEDURE SECTION\n");
-      exit(1);
-    }
-
-    after_part(tmp_string1,yytext,' ');  // get function name
-    strip_leading_blanks(tmp_string2,tmp_string1); 
-    before_part(tmp_string3,tmp_string2,' '); 
-    after_part(tmp_string4,tmp_string2,' ');  // get function name
-    strip_leading_blanks(tmp_string1,tmp_string4); 
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"}\n\n%s ",tmp_string3);
-    fprintf(fall,"model_parameters::%s\n{\n",tmp_string1);
-    fprintf(fdat," %s %s;\n",tmp_string3,tmp_string1);
-    add_references_to_user_classes(fall); 
-    in_aux_proc=1;
-    BEGIN DEFINE_PROCS;
-                              }
-
-
-
-SEPARABLE_FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
-    if (!in_procedure_def)
-    {
-      fprintf(stderr,"Error -- SEPARABLE_FUNCTION must be used within the"
-        " PROCEDURE SECTION\n");
-      exit(1);
-    }
-
-    after_part(tmp_string1,yytext,' ');  // get function name
-    strip_leading_blanks(tmp_string2,tmp_string1); 
-    before_part(tmp_string3,tmp_string2,' '); 
-    after_part(tmp_string4,tmp_string2,' ');  // get function name
-    strip_leading_blanks(tmp_string1,tmp_string4); 
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"}\n\n%s SEPFUN1  ",tmp_string3);
-    fprintf(fall,"model_parameters::%s\n{\n  "
-      "begin_df1b2_funnel();\n" ,tmp_string1);
-    fprintf(fdat,"SEPFUN3 %s %s;\n",tmp_string3,tmp_string1);
-    add_references_to_user_classes(fall); 
-    in_aux_proc=1;
-    in_funnel_proc=1;
-    have_separable_function=1;
-    BEGIN DEFINE_PROCS;
-                              }
-
-
-NESTED_FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
-    if (!in_procedure_def)
-    {
-      fprintf(stderr,"Error -- NESTED_SEPARABLE_FUNCTION must be used"
-        " within the PROCEDURE SECTION\n");
-      exit(1);
-    }
-
-    printf(" %s \n",yytext);
-    after_part(tmp_string1,yytext,' ');  // get function name
-    strip_leading_blanks(tmp_string2,tmp_string1); 
-    before_part(tmp_string3,tmp_string2,' '); 
-    after_part(tmp_string4,tmp_string2,' ');  // get function name
-    strip_leading_blanks(tmp_string1,tmp_string4); 
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"}\n\n%s SEPFUN4  ",tmp_string3);
-    fprintf(fall,"model_parameters::%s\n{\n  "
-      "lapprox->begin_separable_call_stuff();\n" ,tmp_string1);
-  
-    //fprintf(fall,"model_parameters::%s\n{\n  ",tmp_string1);
-    //fprintf(fdat,"SEPFUN3 %s %s;\n",tmp_string3,tmp_string1);
-    fprintf(fdat,"SEPFUN4 %s %s;\n",tmp_string3,tmp_string1);
-    //fprintf(fall," PPPPPP\n");
-    write_getindex_stuff(tmp_string1);
-    add_references_to_user_classes(fall); 
-    in_aux_proc=1;
-    in_funnel_proc=2;
-    have_separable_function=1;
-    BEGIN DEFINE_PROCS;
-                              }
-
-
-NORMAL_PRIOR_FUNCTION[ ]*{name}[ ]*{name}\(.*\) |
-QUADRATIC_PENALTY_FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
-    if (!in_procedure_def)
-    {
-      fprintf(stderr,"Error -- FUNCTION must be used within the"
-        " PROCEDURE SECTION\n");
-      exit(1);
-    }
-
-    after_part(tmp_string1,yytext,' ');  // get function name
-    strip_leading_blanks(tmp_string2,tmp_string1); 
-    before_part(tmp_string3,tmp_string2,' '); 
-    after_part(tmp_string4,tmp_string2,' ');  // get function name
-    strip_leading_blanks(tmp_string1,tmp_string4); 
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"}\n\n%s SEPFUN1  ",tmp_string3);
-    fprintf(fall,"model_parameters::%s\n{\n  "
-      "begin_df1b2_funnel();\n" ,tmp_string1);
-    fprintf(fdat,"SEPFUN3 %s %s;\n",tmp_string3,tmp_string1);
-    add_references_to_user_classes(fall); 
-    in_aux_proc=1;
-    in_funnel_proc=1;
-    //have_separable_function=1;
-    in_normal_prior_flag=1;
-    BEGIN DEFINE_PROCS;
-                              }
-
-QUADPRIOR_FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
-    if (!in_procedure_def)
-    {
-      fprintf(stderr,"Error -- FUNCTION must be used within the"
-        " PROCEDURE SECTION\n");
-      exit(1);
-    }
-
-    after_part(tmp_string1,yytext,' ');  // get function name
-    strip_leading_blanks(tmp_string2,tmp_string1); 
-    before_part(tmp_string3,tmp_string2,' '); 
-    after_part(tmp_string4,tmp_string2,' ');  // get function name
-    strip_leading_blanks(tmp_string1,tmp_string4); 
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"}\n\n%s SEPFUN1  ",tmp_string3);
-    fprintf(fall,"model_parameters::%s\n{\n"
-      "  setup_quadprior_calcs();\n"
-      "  begin_df1b2_funnel();\n" ,tmp_string1);
-    fprintf(fdat,"SEPFUN3 %s %s;\n",tmp_string3,tmp_string1);
-    add_references_to_user_classes(fall); 
-    in_aux_proc=1;
-    in_funnel_proc=1;
-    have_separable_function=1;
-    BEGIN DEFINE_PROCS;
-                              }
-
-
-FUNCTION[ ]*{name} {
-    if (!in_procedure_def)
-    {
-      fprintf(stderr,"Error -- FUNCTION must be used within the"
-        " PROCEDURE SECTION\n");
-      exit(1);
-    }
-
-    after_partb(tmp_string1,yytext,' ');  // get function name
-    write_funnel_end();
-    setup_for_prior_likelihood();    
-    
-    fprintf(fall,"}\n\nvoid model_parameters::%s(void)\n{\n",tmp_string1);
-    fprintf(fdat,"  void %s(void);\n",tmp_string1);
-    
-    add_references_to_user_classes(fall); 
-    
-    in_aux_proc=1;
-    BEGIN DEFINE_PROCS;
-   /*  BEGIN DEFINE_AUX_PROC; */
-                              }
-
-FUNCTION_DECLARATION[ ]*{name}[ ]*{name}\(.*\) |
-[ ]FUNCTION_DECLARATION[ ]*{name}[ ]*{name}\(.*\) {
-    if (!in_procedure_def)
-    {
-      fprintf(stderr,"Error -- FUNCTION_DECLARATION  must be used within the"
-        " PROCEDURE SECTION\n");
-      exit(1);
-    }
-
-    after_part(tmp_string1,yytext,' ');  // get function name
-    strip_leading_blanks(tmp_string2,tmp_string1); 
-    before_part(tmp_string3,tmp_string2,' '); 
-    after_part(tmp_string4,tmp_string2,' ');  // get function name
-    strip_leading_blanks(tmp_string1,tmp_string4); 
-    //fprintf(fall,"}\n\n%s ",tmp_string3);
-    //fprintf(fall,"model_parameters::%s\n{\n",tmp_string1);
-    fprintf(fdat," %s %s;\n",tmp_string3,tmp_string1);
-    add_references_to_user_classes(fall); 
-    in_aux_proc=1;
-    BEGIN DEFINE_PROCS;
-                              }
-
-
-FUNCTION_DECLARATION[ ]*{name} |
-[ ]FUNCTION_DECLARATION[ ]*{name} {
-    if (!in_procedure_def)
-    {
-      fprintf(stderr,"Error -- FUNCTION_DECLARATION must be used within the"
-        " PROCEDURE SECTION\n");
-      exit(1);
-    }
-
-    after_partb(tmp_string1,yytext,' ');  // get function name
-    //fprintf(fall,"}\n\nvoid model_parameters::%s(void)\n{\n",tmp_string1);
-    fprintf(fdat,"  void %s(void);\n",tmp_string1);
-    
-    add_references_to_user_classes(fall); 
-    
-    in_aux_proc=1;
-    BEGIN DEFINE_PROCS;
-   /*  BEGIN DEFINE_AUX_PROC; */
-                              }
-
-
-<DEFINE_PROCS>^[ \t].*$ { 
-   fprintf(fall,"%s\n",yytext); 
-           }
-
-
-
-<DEFINE_AUX_PROC>^\ +{name}\ +{name}\(.*$       {
-
-   fprintf(fall,"  %s\n",yytext);
-   num_paren=count_paren(num_paren,yytext); 
-   printf("in define_aux_procs num_paren = %d\n",num_paren);
-   if (num_paren==0)
-   {
-     fprintf(fhead,"%s;\n\n",yytext);
-     BEGIN DEFINE_PROCS;
-   }
-   else
-   {
-     fprintf(fhead,"%s\n",yytext);
-     BEGIN CONTINUE_PROTOTYPE_DEF;
-   }  
-                              }
-
-
-<CONTINUE_PROTOTYPE_DEF>^\ .*$       {
-
-   fprintf(fall,"  %s\n",yytext);
-   num_paren=count_paren(num_paren,yytext); 
-   printf("in continue_prorotoype_def num_paren = %d\n",num_paren);
-   if (num_paren==0)
-   {
-     fprintf(fhead,"%s;\n\n",yytext);
-     BEGIN DEFINE_PROCS;
-   }
-   else
-   {
-     fprintf(fhead,"%s\n",yytext);
-   }  
-                              }
-
-
-GLOBALS_SECTION {
-  
-    if (globals_section_defined) {
-      fprintf(stderr,"Error -- there is more than 1 GLOBALS_SECTION\n");
-      exit(1);
-    }
-    globals_section_defined=1;
-    BEGIN IN_GLOBALS_SECTION;
-    /*fglobals=fopen("xxglobal.tmp","w+");*/
-    if (fglobals==NULL)
-    {
-      fprintf(stderr,"%s","Error trying to open file xxglobal.tmp\n");
-    }
-
-                }
-
-<IN_GLOBALS_SECTION>^[ \t].*$ { 
-
-        fprintf(fglobals,"%s\n",yytext);
-
-                              }
-
-TOP_OF_MAIN_SECTION {
-  
-    *arglist_ptr='\0';
-    if (top_of_main_defined) {
-      fprintf(stderr,"Error -- there is more than 1 TOP_OF_MAIN_SECTION\n");
-      exit(1);
-    }
-    top_of_main_defined=1;
-    BEGIN IN_TOP_SECTION;
-    ftopmain=fopen("xxtopm.tmp","w+");
-    if (ftopmain==NULL)
-    {
-      fprintf(stderr,"%s","Error trying to open file xxtopmn.tmp\n");
-      exit(1);
-    }
-    if (need_prior_globals==1)
-    {
-      //fprintf(ftopmain,"  df1b2_parameters * df1b2_parameters::df1b2_parameters_ptr=0;\n");
-      //fprintf(ftopmain,"  model_parameters * model_parameters::model_parameters_ptr=0;\n");
-      need_prior_globals=0;
-    }
-    fprintf(ftopmain,"  long int arrmblsize=0;\n");
-    if (makedll) fprintf(ftopmain,"extern \"C\" {\n");
-    if (splus_debug_flag)
-    {
-      if (!makegaussdll)
-        fprintf(ftopmain,"\nvoid ");
-      else
-        fprintf(ftopmain,"\nint ");
-
-      fprintf(ftopmain,"%s",infile_root);
-      if (!makegaussdll)
-        fprintf(ftopmain,"(%s,char ** dll_options);\n\n",arglist);
-      else
-        fprintf(ftopmain,"(%s,char * dll_options);\n\n",arglist);
-      
-      fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
-      fprintf(ftopmain,"  %s",infile_root);
-      fprintf(ftopmain,"    ad_set_new_handler();\n");
-      if (bound_flag) fprintf(ftopmain,"    ad_exit=&ad_boundf;\n");
-      fprintf(ftopmain,"(%s,dll_options);\n}\n",arglist1);
-    }   
-    if (!splus_debug_flag)
-    {
-      if (makedll)
-      {
-        fprintf(ftopmain,"\n#if !defined(__MSVC32__)"
-           "\n#  define __declspec(x)"
-           "\n#endif\n");
-
-        fprintf(ftopmain,"\n#if !defined(__BORLANDC__)"
-           "\n#  define _export"
-           "\n#else"
-           "\n#  define _export __stdcall"
-           "\n#endif\n");
-        if (!makegaussdll)
-          fprintf(ftopmain,"\n__declspec(dllexport) void _export ");
-        else
-          fprintf(ftopmain,"\n__declspec(dllexport) int _export ");
-      }
-      else
-      {	
-        fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
-        fprintf(ftopmain,"  ad_set_new_handler();\n");
-        if (bound_flag) fprintf(ftopmain,"  ad_exit=&ad_boundf;\n");
-      }	
-    }	
-    else
-    {
-      fprintf(ftopmain,"\nvoid ");
-    }	
-    if (makedll)
-    {
-      fprintf(ftopmain,"%s",infile_root);
-      if (num_spargs)
-      {
-        if (!makegaussdll)
-          fprintf(ftopmain,"(%s,char ** dll_options)\n{\n",arglist);
-        else
-          fprintf(ftopmain,"(%s,char * dll_options)\n{\n",arglist);
-      }
-      else  
-      {
-        if (!makegaussdll)
-          fprintf(ftopmain,"(%schar ** dll_options)\n{\n",arglist);
-        else
-          fprintf(ftopmain,"(%schar * dll_options)\n{\n",arglist);
-      }
-    }	
-
-                }
-
-<IN_TOP_SECTION>^[ \t].*$ { 
-
-        fprintf(ftopmain,"%s\n",yytext);
-
-                              }
-
-
-<<EOF>>           {
-       
-    if (!data_defined)
-    {
-      fprintf(stderr,"Error -- Reached end-of-file without the DATA_SECTION"
-        " being defined\n");
-      exit(1);
-    }
-    if (!params_defined)
-    {
-      fprintf(stderr,"Error -- Reached end-of-file without the PARAMETER_SECTION"
-        " being defined\n");
-      exit(1);
-    }
-    if (!procedure_defined)
-    {
-      fprintf(stderr,"Error -- Reached end-of-file without the"
-        " PROCEDURE_SECTION being defined\n");
-      exit(1);
-    }
-    write_funnel_end();
-    setup_for_prior_likelihood(); 
-    //if (!in_aux_proc)
-    //if (in_aux_proc)
-    {
-     // fprintf(fall,"}\n");
-    }
-
-    fprintf(fall,"}\n");
-    fclose(fall);
-    fall=fopen("xxalloc6.tmp","w+");
-    if (fall==NULL)
-    {
-      fprintf(stderr,"%s","Error trying to open file xxalloc6.tmp\n");
-    }
-    if (!preliminary_calcs_defined)
-    {
-      fprintf(fall,"\nvoid model_parameters::preliminary_calculations(void)"
-        "{");
-      fprintf(fall,"%s","\n  admaster_slave_variable_interface(*this);\n  }\n");
-    }
-
-    fprintf(fall,"\nmodel_data::~model_data()\n"
-      "{");
-    fprintf(fall,"}\n");
-    fprintf(fall,"\nmodel_parameters::~model_parameters()\n"
-      "{");
-    call_destructors_for_user_classes(fall); 
-
-    if (!report_defined)
-    {
-      fprintf(fall,"}\n");
-      fprintf(fall,"\nvoid model_parameters::report(void)"
-        "{");
-    }
-
-    if (!final_defined)
-    {
-      fprintf(fall,"}\n");
-      fprintf(fall,"\nvoid model_parameters::final_calcs(void)"
-        "{");
-    }
-
-    if (!runtime_defined)
-    {
-      fprintf(fall,"}\n");
-      fprintf(fall,"%s","\nvoid model_parameters::set_runtime(void)"
-        "{");
-    }
-
-    fprintf(fall,"}\n");
-    fprintf(fall,"\n#ifdef _BORLANDC_\n"
-                 "  extern unsigned _stklen=10000U;\n#endif\n\n");
-    fprintf(fall,"\n#ifdef __ZTC__\n"
-                 "  extern unsigned int _stack=10000U;\n#endif\n\n");
-
-    if (!ftopmain)
-    {
-      ftopmain=fopen("xxtopm.tmp","w+");
-      if (ftopmain==NULL)
-      {
-        fprintf(stderr,"%s","Error trying to open file xxtopmn.tmp\n");
-        exit(1);
-      }
-      fprintf(ftopmain,"  long int arrmblsize=0;\n");
-      // **********************************************************************
-      // **********************************************************************
-      if (makedll)
-      {
-        fprintf(ftopmain,"extern \"C\" {\n");
-        //fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
-        if (splus_debug_flag)
-        {
-          if (!makegaussdll)
-            fprintf(ftopmain,"\nvoid ");
-          else
-            fprintf(ftopmain,"\nint ");
-
-          fprintf(ftopmain,"%s",infile_root);
-          if (!makegaussdll)
-            fprintf(ftopmain,"(%s,char ** dll_options);\n\n",arglist);
-          else
-            fprintf(ftopmain,"(%s,char * dll_options);\n\n",arglist);
-        
-          fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
-          fprintf(ftopmain,"  ad_set_new_handler();\n");
-          if (bound_flag) fprintf(ftopmain,"  ad_exit=&ad_boundf;\n");
-          fprintf(ftopmain,"  %s",infile_root);
-          fprintf(ftopmain,"(%s,dll_options);\n}\n",arglist1);
-        }   
-        if (!splus_debug_flag)
-        {
-          fprintf(ftopmain,"\n#if !defined(__MSVC32__)"
-            "\n#  define __declspec(x)"
-            "\n#endif\n");
-      
-          fprintf(ftopmain,"\n#if !defined(__BORLANDC__)"
-            "\n#  define _export"
-           "\n#else"
-           "\n#  define _export __stdcall"
-            "\n#endif\n");
-	    
-          if (!makegaussdll)
-            fprintf(ftopmain,"\n__declspec(dllexport) void _export ");
-          else
-            fprintf(ftopmain,"\n__declspec(dllexport) int _export ");
-        }	
-        else
-        {
-          if (!makegaussdll)
-            fprintf(ftopmain,"\nvoid ");
-          else
-            fprintf(ftopmain,"\nint ");
-        }	
-        fprintf(ftopmain,"%s",infile_root);
-        if (num_spargs)
-        {
-          if (!makegaussdll)
-            fprintf(ftopmain,"(%s,char ** dll_options)\n{\n",arglist);
-          else
-            fprintf(ftopmain,"(%s,char * dll_options)\n{\n",arglist);
-        }
-        else  
-        {
-          if (!makegaussdll)
-            fprintf(ftopmain,"(%schar ** dll_options)\n{\n",arglist);
-          else
-            fprintf(ftopmain,"(%schar * dll_options)\n{\n",arglist);
-        }
-
-      }
-      else
-      {
-        fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
-        fprintf(ftopmain,"  ad_set_new_handler();\n");
-        if (bound_flag) fprintf(ftopmain,"  ad_exit=&ad_boundf;\n");
-      }	
-      // **********************************************************************
-      // **********************************************************************
-
-    }
-    if (talk_to_splus)
-    {
-      fprintf(ftopmain,"  DDEspclient ddesc;\n");
-    }
-    
-    if (makedll)
-    {
-      if (makegaussdll)
-      {
-        fprintf(ftopmain,"  AD_gaussflag=1;\n");
-      }
-      fprintf(ftopmain,"  int argc=1;\n");
-      fprintf(ftopmain,"  char **argv=0;\n");
-      fprintf(ftopmain,"  try {\n");
-    
-      if (!makegaussdll)
-      {
-        fprintf(ftopmain,"    argv=parse_dll_options(\"%s\",argc,"
-          "*dll_options);\n",infile_root);
-      }
-      else
-      {
-        fprintf(ftopmain,"    argv=parse_dll_options(\"%s\",argc,"
-          "dll_options);\n", infile_root);
-      }
-      fprintf(ftopmain,"    do_dll_housekeeping(argc,argv);\n");
-      //fprintf(ftopmain,"    strcpy(argv[0],\"%s\");\n",infile_root);
-      //fprintf(ftopmain,"    strcat(argv[0],\".exe\");\n");
-    
-      if (num_spargs)
-        fprintf(ftopmain,"    dll_args ad_dll(%s);\n",arglist1);
-      else  
-        fprintf(ftopmain,"    dll_args ad_dll;\n");
-    }	
-    fprintf(ftopmain,"    gradient_structure::set_NO_DERIVATIVES();\n");
-    // **********************************************************************
-    // **********************************************************************
-    
-    if (makedll)
-    {
-      fprintf(ftopmain,"    gradient_structure::set_YES_SAVE_VARIABLES_VALUES();\n"
-        "  #if defined(__GNUDOS__) || defined(DOS386) || defined(__DPMI32__) "
-        " || \\\n"
-        "     defined(__MSVC32__)\n"
-        "      if (!arrmblsize) arrmblsize=150000;\n"
-        "  #else\n"
-        "      if (!arrmblsize) arrmblsize=25000;\n"
-        "  #endif\n");
-
-      if (!random_effects_flag)
-      {
-        fprintf(ftopmain,"    model_parameters mp(arrmblsize,argc,argv,ad_dll);\n"
-          "    mp.iprint=10;\n");
-      }
-      else
-      {
-        fprintf(ftopmain,"    df1b2variable::noallocate=1;\n");
-        fprintf(ftopmain,"    df1b2_parameters mp(arrmblsize,argc,argv,ad_dll);\n"
-          "    mp.iprint=10;\n");
-      }
-      
-    }	
-    else
-    {
-      fprintf(ftopmain,"    gradient_structure::set_YES_SAVE_VARIABLES_VALUES();\n"
-        "  #if defined(__GNUDOS__) || defined(DOS386) || defined(__DPMI32__) "
-        " || \\\n"
-        "     defined(__MSVC32__)\n"
-        "      if (!arrmblsize) arrmblsize=150000;\n"
-        "  #else\n"
-        "      if (!arrmblsize) arrmblsize=25000;\n"
-        "  #endif\n");
-      if (!random_effects_flag)
-      {
-       fprintf(ftopmain,"    model_parameters mp(arrmblsize,argc,argv);\n"
-         "    mp.iprint=10;\n");
-      }
-      else
-      {
-       fprintf(ftopmain,"    df1b2variable::noallocate=1;\n");
-       fprintf(ftopmain,"    df1b2_parameters mp(arrmblsize,argc,argv);\n"
-         "    mp.iprint=10;\n");
-      }
-    }	
-    
-
-     if (random_effects_flag)
-     {
-       fprintf(ftopmain,"%s",
-         "\n    function_minimizer::random_effects_flag=1;\n");
-       fprintf(ftopmain,"    df1b2variable::noallocate=0;\n");
-     }
-
-     fprintf(ftopmain,"    mp.preliminary_calculations();\n");
-
-     if (have_separable_function)
-       fprintf(ftopmain,"    initial_df1b2params::separable_flag=1;\n");
-#if defined(NET_DEMO)
-     fprintf(ftopmain,"    mp.computationsx(argc,argv);\n");
-#else
-     fprintf(ftopmain,"    mp.computations(argc,argv);\n");
-#endif
-
-    fprintf(htop,"#include <admodel.h>\n\n");
-    if (random_effects_flag)
-    {
-      fprintf(htop,"#include <df1b2fun.h>\n\n");
-      fprintf(htop,"#include <adrndeff.h>\n\n");
-    }
-
-    if (bound_flag)
-    {
-      fprintf(htop,"  extern \"C\"  {\n");
-      fprintf(htop,"    void ad_boundf(int i);\n  }\n");
-    }
-      
-    
-    if (talk_to_splus)
-    {
-      fprintf(htop,"#include <adsplus.h>\n\n");
-    }
-
-    if (makedll)
-    {
-      // make a definition file
-      FILE * fd=0;
-      char deffile_name[125];
-      strcpy(deffile_name,infile_root);
-      strcat(deffile_name,".def");
-      fd=fopen("deffile_name","w");
-      if (!fd)
-      {
-        fprintf(stderr,"Error opining file %s\n",deffile_name);
-      }
-      else
-      {
-        fprintf(fd,"LIBRARY %s\n",infile_root);
-        fprintf(fd,"EXPORTS\n     %s\n",infile_root);
-      }
-    }
-      
-
-    if (makedll)
-    {
-      fprintf(ftopmain,"    ad_make_code_reentrant();\n");
-      fprintf(ftopmain,"  }\n");
-    
-      fprintf(ftopmain,"  catch (spdll_exception spe){ \n");
-      fprintf(ftopmain,"    if (ad_printf && spe.e) (*ad_printf)"
-        " (\"abnormal exit from newtest\\n\");\n");
-      fprintf(ftopmain,"  }\n");
-      fprintf(ftopmain,"  cleanup_argv(argc,&argv);\n");
-      if (makegaussdll) fprintf(ftopmain,"  return 0;\n");
-      fprintf(ftopmain,"}\n");
-      fprintf(ftopmain,"}\n");
-      fprintf(fdat,"%s","};\n");
-      *conlist_ptr='\0';
-      *arglist1_ptr='\0';
-      *classlist_ptr='\0';
-      fprintf(fdat1,"\nclass dll_args\n{\npublic:\n%s",classlist);
-      if (num_spargs)
-        fprintf(fdat1,"\n dll_args(%s) : %s{}\n",arglist,conlist);
-      else  
-        fprintf(fdat1,"\n dll_args()  {}\n");
-      fprintf(fdat1,"\n};\n");
-    }  
-    else
-    {
-      fprintf(ftopmain,"    return 0;\n}\n");
-      fprintf(fdat,"\n};\n");
-    }
-    if (fdat1)
-    {
-      fclose(fdat1);
-      fdat1=0;
-    }
-    //fprintf(fdat,"\n};\n");
-    if (bound_flag)
-    {
-      fprintf(ftopmain,"\nextern \"C\"  {\n");
-      fprintf(ftopmain,"  void ad_boundf(int i)\n  {\n");
-      fprintf(ftopmain,"    /* so we can stop here */\n");
-      fprintf(ftopmain,"    exit(i);\n  }\n}\n");
-    }
-      
-    fclose(fhead);
-    fclose(htop);
-    fclose(fglobals);
-    fclose(ftopmain);
-    fclose(fdat);
-    fclose(fall);
-
-#if defined(_WIN32)
-    strcpy(outcommand,"copy xxglobal.tmp + xxhtop.tmp + header.tmp "
-     "+ xxalloc1.tmp + xxalloc2.tmp + xxalloc3.tmp");
-    if (report_defined)
-    {
-      strcat(outcommand," + xxalloc4.tmp ");
-    }
-    if (preliminary_calcs_defined)
-    {
-      strcat(outcommand," + xxalloc5.tmp ");
-    } 
-    strcat(outcommand, " + xxtopm.tmp + xxalloc6.tmp ");
-  
-    strcpy(outcommand2,"copy tfile1 + tfile2 + tfile3 +tfile4 ");
-
-
-    strcpy(outcommand3a,"sed -n -f ");
-    strcat(outcommand3a,dirpath);
-    if (makedll==0)
-      strcat(outcommand3a,"seddf1b3 tfile2 >> ");
-    else
-      strcat(outcommand3a,"seddf1b3dll tfile2 >> ");
-
-    strcpy(outcommand3b,"sed -n -f ");
-    strcat(outcommand3b,dirpath);
-    strcat(outcommand3b,"seddf1b4 tfile4 >> ");
-
-       
-    strcpy(outcommand3,"sed -f ");
-    strcat(outcommand3,dirpath);
-    if (makedll==0)
-      strcat(outcommand3,"seddf1b2 tfile2 >> ");
-    else
-      strcat(outcommand3,"seddf1b2dll tfile2 >> ");
-
-    // !!!!! DF may 1 03 Is this right?
-    // this
-    // strcpy(outcommand6,"cat tfile4 >> ");
-    // changed to
-    strcpy(outcommand6,"sed -f ");
-    strcat(outcommand6,dirpath);
-    strcat(outcommand6,"sedf1b2d tfile4 >> ");
-
-
-    strcpy(outcommand4,"sed -f ");
-    strcat(outcommand4,dirpath);
-    strcat(outcommand4,"sedf1b2a xxalloc3.tmp >> ");
-
-    strcpy(outcommand5,"sed -f ");
-    strcat(outcommand5,dirpath);
-    strcat(outcommand5,"sedf1b2c xxalloc2.tmp >> ");
-    strcpy(outcommand8,"sed -e \"  \"  tfile5 >> ");
-
-#else
-    strcpy(outcommand,"cat xxglobal.tmp   xxhtop.tmp   header.tmp "
-     "  xxalloc1.tmp   xxalloc2.tmp   xxalloc3.tmp ");
-    if (report_defined)
-    {
-      strcat(outcommand," xxalloc4.tmp");
-    }
-    if (preliminary_calcs_defined)
-    {
-      strcat(outcommand," xxalloc5.tmp");
-    } 
-    strcat(outcommand, "  xxtopm.tmp    xxalloc6.tmp > ");
-
-    strcpy(outcommand2,"cat tfile1  tfile2 tfile3 tfile4 > ");
-
-    strcpy(outcommand3a,"sed -n -f ");
-    strcat(outcommand3a,dirpath);
-    if (makedll==0)
-      strcat(outcommand3a,"seddf1b3 tfile2 >> ");
-    else
-      strcat(outcommand3a,"seddf1b3dll tfile2 >> ");
-
-    strcpy(outcommand3b,"sed -n -f ");
-    strcat(outcommand3b,dirpath);
-    strcat(outcommand3b,"seddf1b4 tfile4 >> ");
-
-    strcpy(outcommand3,"sed -f ");
-    strcat(outcommand3,dirpath);
-    if (makedll==0)
-      strcat(outcommand3,"seddf1b2 tfile2 >> ");
-    else
-      strcat(outcommand3,"seddf1b2dll tfile2 >> ");
-
-    // !!!!! DF may 1 03 Is this right?
-    // this
-    // strcpy(outcommand6,"cat tfile4 >> ");
-    // changed to
-    strcpy(outcommand6,"sed -f ");
-    strcat(outcommand6,dirpath);
-    strcat(outcommand6,"sedf1b2d tfile4 >> ");
-
-
-    strcpy(outcommand4,"sed -f ");
-    strcat(outcommand4,dirpath);
-    strcat(outcommand4,"sedf1b2a xxalloc3.tmp >> ");
-
-    strcpy(outcommand5,"sed -f ");
-    strcat(outcommand5,dirpath);
-    strcat(outcommand5,"sedf1b2c xxalloc2.tmp >> ");
-    
-    strcpy(outcommand8,"sed -e \"  \"  tfile5 >> ");
-    
-    //strcpy(outcommand,"cat xxglobal.tmp xxhtop.tmp header.tmp 
-    //  xxalloc1.tmp xxalloc2.tmp xxalloc3.tmp xxalloc4.tmp xxalloc6.tmp " 
-    //  " xxtopm.tmp > ");
-#endif
-    // strcpy(outcommand,"copy xxdata.tmp + header.tmp + xxalloc.tmp ");
-    strcat(outcommand,outfile_name);
-    if (verbosemode)
-      printf("\n%s\n",outcommand);
-    errcopy=system(outcommand);
-    if (errcopy)
-    {
-      fprintf(stderr,"Error executing command %s\n",
-        outcommand);
-    }
-    strcat(outcommand2,headerfile_name);
-
-    if (verbosemode)
-      printf("\n%s\n",outcommand2);
-    errcopy=system(outcommand2);
-    if (errcopy)
-    {
-      fprintf(stderr,"Error executing command %s\n",
-        outcommand2);
-    }
-
-    if (random_effects_flag)
-    {
-      strcpy(outcommand7, " sed -e \" \" ");
-      strcat(outcommand7,headerfile_name); 
-      strcat(outcommand7," >>  classdef.tmp"); 
-      if (verbosemode)
-        printf("\n%s\n",outcommand7);
-      errcopy=system(outcommand7);
-      if (errcopy)
-      {
-        fprintf(stderr,"Error executing command %s\n",
-          outcommand7);
-      }
-    }
-
-    if (random_effects_flag)
-    {
-      strcpy(outcommand7, " sed -e \" \" ");
-      strcat(outcommand7," classdef.tmp > "); 
-      strcat(outcommand7,headerfile_name); 
-      if (verbosemode)
-        printf("\n%s\n",outcommand7);
-      errcopy=system(outcommand7);
-      if (errcopy)
-      {
-        fprintf(stderr,"Error executing command %s\n",
-          outcommand7);
-      }
-    }
-
-    if (random_effects_flag  && have_classcode_tmp)
-    {
-      strcpy(outcommand7, " sed -e \" \" ");
-      strcat(outcommand7," classcode.tmp >> "); 
-      strcat(outcommand7,outfile_name); 
-      if (verbosemode)
-        printf("\n%s\n",outcommand7);
-      errcopy=system(outcommand7);
-      if (errcopy)
-      {
-        fprintf(stderr,"Error executing command %s\n",
-          outcommand7);
-      }
-    }
-
-    strcat(outcommand3a,headerfile_name);
-    if (verbosemode)
-      printf("\n%s\n",outcommand3a);
-    errcopy=system(outcommand3a);
-    if (errcopy)
-    {
-      fprintf(stderr,"Error executing command %s\n",
-        outcommand3a);
-    }
-
-    strcat(outcommand3b,headerfile_name);
-    if (verbosemode)
-      printf("\n%s\n",outcommand3b);
-    errcopy=system(outcommand3b);
-    if (errcopy)
-    {
-      fprintf(stderr,"Error executing command %s\n",
-        outcommand3b);
-    }
-
-    strcat(outcommand3,headerfile_name);
-    if (verbosemode)
-      printf("\n%s\n",outcommand3);
-    errcopy=system(outcommand3);
-    if (errcopy)
-    {
-      fprintf(stderr,"Error executing command %s\n",
-        outcommand3);
-    }
-
-    strcat(outcommand6,headerfile_name);
-    if (verbosemode)
-      printf("\n%s\n",outcommand6);
-    errcopy=system(outcommand6);
-    if (errcopy)
-    {
-      fprintf(stderr,"Error executing command %s\n",
-        outcommand6);
-    }
-    strcat(outcommand4,outfile_name);
-    if (verbosemode)
-      printf("\n%s\n",outcommand4);
-    errcopy=system(outcommand4);
-    if (errcopy)
-    {
-      fprintf(stderr,"Error executing command %s\n",
-        outcommand4);
-    }
-    
-    strcat(outcommand5,outfile_name);
-    if (verbosemode)
-      printf("\n%s\n",outcommand5);
-    errcopy=system(outcommand5);
-    if (errcopy)
-    {
-      fprintf(stderr,"Error executing command %s\n",
-        outcommand5);
-    }
-  
-    if (makedll) 
-    {
-      strcat(outcommand8,headerfile_name);
-      if (verbosemode)
-        printf("\n%s\n",outcommand8);
-      errcopy=system(outcommand8);
-      if (errcopy)
-      {
-        fprintf(stderr,"Error executing command %s\n",
-          outcommand8);
-      }
-    }
-    if (!errcopy)
-    {	
-        unlink("classdef.tmp");
-        unlink("xxdata.tmp");
-        unlink("xxhtop.tmp");
-        unlink("xxhtopm.tmp");
-        unlink("xxglobal.tmp");
-        unlink("xxtopm.tmp");
-        unlink("xxalloc.tmp");
-        unlink("xxalloc1.tmp");
-        unlink("xxalloc2.tmp");
-        unlink("xxalloc3.tmp");
-        unlink("xxalloc4.tmp");
-        unlink("xxalloc5.tmp");
-        unlink("xxalloc6.tmp");
-        unlink("header.tmp");
-        unlink("tfile1");
-        unlink("tfile2");
-        unlink("tfile3");
-        unlink("tfile4");
-        if (makedll) 
-        {
-          unlink("tfile5");
-        }
-        
-    }
-    else
-    {
-      fprintf(stderr,"Error trying to create output file %s\n",
-        outfile_name);
-    }
-    if (!random_effects_flag)
-    {
-      fprintf(stderr,"%s"," WARNING !!! No random effects vector defined "
-        "in this TPL file\n");
-    }
-    
-    exit(0);
-                  }
-
-
-%%
-
-int check_for_blanks(const char * s)
-{
-  int bflag=0;
-  int i;
-  for (i=0;i<strlen(s);i++)
-  {
-    if (s[i]==' ')
-    {
-      bflag=1;
-      break;
-    }
-  }
-  return bflag;
-}
-
-int option_match(int argc,char * argv[], char * string);
-
-unsigned _stklen = 16000;
-char * get_directory_name(const char * s)
-{
-  char * path;
-  char quote[]="\"";
-  int bflag=0;
-  int len;
-  int i,j;
-  char * path1=getenv("ADMB_HOME");
-  /* char sed_file_separator='/'; */
-#if defined(WIN32)
-  char file_separator='\\';
-  char file_separator_string[]="\\";
-#else
-  char file_separator='/';
-  char file_separator_string[]="/";
-#endif
-  if (path1==0)
-  {
-    printf("ADMB_HOME environment string is not set\n");
-    exit(1);
-    len=strlen(s);
-    for (i=1;i<=len;i++)
-    {
-      if (s[len-i]==file_separator) break;
-    }
-    path = (char*) malloc(sizeof(char*)*(len-i+2));
-    for (j=0;j<=len-i;j++)
-    {
-      path[j]=s[j];
-    }
-    path[len-i+1]=0;
-  }
-  else
-  {
-    bflag=check_for_blanks(path1);
-    len=strlen(path1);
-    if (path1[len-1]==file_separator) 
-    {
-      path = (char*) malloc(sizeof(char*)*(len+9));
-      if (bflag==0)
-      {
-        strcpy(path,path1);
-      }
-      else
-      {
-        strcpy(path,quote);
-        strcat(path,path1);
-        strcat(path,file_separator_string);
-        strcat(path,quote);
-        len+=2;
-      }
-      
-      strcat(path,"bin");
-      path[len+4]=file_separator;
-      path[len+5]=0;
-    }
-    else
-    {
-      path = (char*) malloc(sizeof(char*)*(len+9));
-      if (bflag==0)
-      {
-        strcpy(path,path1);
-      }
-      else
-      {
-        strcpy(path,quote);
-        strcat(path,path1);
-        strcat(path,quote);
-        len+=2;
-      }
-      path[len]=file_separator;
-      path[len+1]=0;
-      strcat(path,"bin");
-      path[len+4]=file_separator;
-      path[len+5]=0;
-    }
-  } 
-  return path;
-}
-
-void check_random_effects_ordering(void)
-{
-  if (random_effects_flag==1)
-  {
-    fprintf(stderr,"Error in PARAMETER_SECTION at line");
-    fprintf(stderr," %d \n",nline);
-    fprintf(stderr,"Random effects objects must be declared after all other"
-       " initial objects.\n");
-    exit(1);
-  }
-}
-  
-int main(int argc, char * argv[])
-{
-  FILE * f1=NULL;
-  int ioff=argc-1;
-  int on=0;
-  dirpath= get_directory_name(argv[0]);
-  if (verbosemode)
-    printf(" dirpath = %s\n",dirpath);
-  //printf(" PATH= %s\n",getenv("PATH"));
-  //if ( (on=option_match(argc,argv,"-bounds"))>-1)
-  {
-    bound_flag=1;
-  }  
-  if ( (on=option_match(argc,argv,"-v"))>-1)
-  {
-    verbosemode=1;
-  }  
-  if ( (on=option_match(argc,argv,"-dll"))>-1)
-  {
-    makedll=1;
-  }  
-  if ( (on=option_match(argc,argv,"-gaussdll"))>-1)
-  {
-    makedll=1;
-    makegaussdll=1;
-  }  
-  if ( (on=option_match(argc,argv,"-debug"))>-1)
-  {
-    splus_debug_flag=1;
-  }  
-  if ( (on=option_match(argc,argv,"-no_pad"))>-1)
-  {
-    no_userclass=1;
-  }  
-  if (argc>1)
-  {
-    strcpy(infile_name,argv[ioff]);
-    strcpy(deffile_name,argv[ioff]);
-    strcpy(infile_root,infile_name);
-    strcpy(outfile_name,argv[ioff]);
-    strcpy(headerfile_name,argv[ioff]);
-    strcpy(headerfile_name2,argv[ioff]);
-    strcat(infile_name,".tpl");
-    strcat(outfile_name,".cpp");
-    strcat(headerfile_name,".htp");
-    strcat(deffile_name,".def");
-    strcat(headerfile_name2,"2.htp");
-    if (debug_flag) fprintf(stderr,"Trying to open file %s for input\n", infile_name);
-    yyin=fopen(infile_name,"r");
-    if (!yyin)
-    {
-      fprintf(stderr,"Error trying to open input file %s\n",
-        infile_name);
-      exit(1);
-    }
-    if (debug_flag) fprintf(stderr,"Opened file %s for input\n", infile_name);
-    if (makedll) 
-    {
-      strcpy(tmp_string1,argv[ioff]);
-      strcat(tmp_string1,".def");
-      f1=fopen(tmp_string1,"w");
-      fprintf(f1,"LIBRARY %s\n\n",argv[ioff]);
-      fprintf(f1,"EXPORTS\n");
-      fprintf(f1,"\t%s\n",argv[ioff]);
-      fclose(f1);
-      f1=NULL;
-    }  
-  }
-  else
-  {
-    strcpy(infile_name,"admodel.tpl");
-    strcpy(outfile_name,"admodel.cpp");
-    if (debug_flag) fprintf(stderr,"Trying to open file %s for input\n", infile_name);
-    yyin=fopen(infile_name,"r");
-    if (!yyin)
-    {
-      fprintf(stderr,"Error trying to open default input file %s\n",
-        infile_name);
-      exit(1);
-    }
-    if (debug_flag) fprintf(stderr,"Opened file %s for input\n", infile_name);
-  }
-  conlist_ptr=&(conlist[0]);
-  classlist_ptr=&(classlist[0]);
-  arglist_ptr=&(arglist[0]);
-  arglist1_ptr=&(arglist1[0]);
-
-
-  htop=fopen("xxhtop.tmp","w+");
-  if (htop==NULL)
-  {
-    fprintf(stderr,"Error trying to open file %s\n","xxhtop.tmp");
-  }
-  fglobals=fopen("xxglobal.tmp","w+");
-  if (fglobals==NULL)
-  {
-    fprintf(stderr,"Error trying to open file %s\n","xxglobal.tmp");
-  }
-  //fdat=fopen(headerfile_name,"w+");
-  fdat=fopen("tfile1","w+");
-  if (fdat==NULL)
-  {
-    fprintf(stderr,"Error trying to open file tfile1\n");
-  }
-  if (makedll)
-  {
-    fdat1=fopen("tfile5","w+");
-    if (fdat1==NULL)
-    {
-      fprintf(stderr,"Error trying to open file tfile1\n");
-    }
-  }
-  fall=fopen("xxalloc1.tmp","w+");
-  if (fall==NULL)
-  {
-    fprintf(stderr,"%s","Error trying to open file xxalloc1.tmp\n");
-  }
-  fprintf(fall,"#include <%s>\n\n",headerfile_name);
-  fprintf(fall,"  df1b2_parameters * df1b2_parameters::df1b2_parameters_ptr=0;\n");
-  fprintf(fall,"  model_parameters * model_parameters::model_parameters_ptr=0;\n");
-  fhead=fopen("header.tmp","w+");
-  if (fhead==NULL)
-  {
-    fprintf(stderr,"%s","Error trying to open file header.tmp\n");
-  }
-  yylex();
-  if (fs)
-  {
-    fclose(fs);
-    fs=0;
-  }
-  return 0;
-}
-
-char * before_part(char * d, char * s, char c)
-{
-  int ipos=0;
-  int i=0;
-  int iflag=0;
-  if (strlen(s) > MAX_TMP_STRING)
-  {
-    fprintf(stderr,"%s","string passed to before_part is too long\n");
-    exit(1);
-  }
-  for (i=0;i<strlen(s);i++)
-  {
-    if (s[i]==c)
-    {
-      ipos=i;
-      iflag=1;
-      break;
-    }
-  }
-  if (ipos)
-  {
-    for (i=0;i<ipos;i++)
-    {
-      d[i]=s[i];
-    }
-    d[ipos]='\0';
-  }
-  return d;
-}
-
-char * before_partb(char * d, char * s, char c)
-{
-  int ipos=0;
-  int i=0;
-  int iflag=0;
-  if (strlen(s) > MAX_TMP_STRING)
-  {
-    fprintf(stderr,"%s","string passed to before_part is too long\n");
-    exit(1);
-  }
-  for (i=strlen(s)-1;i>=1;i--)
-  {
-    if (s[i]==c)
-    {
-      ipos=i;
-      iflag=1;
-      break;
-    }
-  }
-  if (ipos)
-  {
-    for (i=0;i<ipos;i++)
-    {
-      d[i]=s[i];
-    }
-    d[ipos]='\0';
-  }
-  return d;
-}
-
-char * after_part(char * d, char * s, char c)
-{
-  int ipos=0;
-  int i=0;
-  int iflag=0;
-  if (strlen(s) > MAX_TMP_STRING)
-  {
-    fprintf(stderr,"%s","string passed to before_part is too long\n");
-    exit(1);
-  }
-  for (i=0;i<strlen(s);i++)
-  {
-    if (s[i]==c)
-    {
-      ipos=i;
-      iflag=1;
-      break;
-    }
-  }
-  if(iflag)
-  {
-    for (i=ipos;i<strlen(s);i++)
-    {
-      d[i-ipos]=s[i];
-    }
-    d[strlen(s)-ipos]='\0';
-  }
-  return d;
-}
-
-char * strict_after_part(char * d, char * s, char c)
-{
-  int ipos=0;
-  int i=0;
-  int iflag=0;
-  if (strlen(s) > MAX_TMP_STRING)
-  {
-    fprintf(stderr,"%s","string passed to before_part is too long\n");
-    exit(1);
-  }
-  for (i=0;i<strlen(s);i++)
-  {
-    if (s[i]==c)
-    {
-      ipos=i;
-      iflag=1;
-      break;
-    }
-  }
-  if(iflag)
-  {
-    for (i=ipos+1;i<strlen(s);i++)
-    {
-      d[i-ipos-1]=s[i];
-    }
-    d[strlen(s)-ipos-1]='\0';
-  }
-  return d;
-}
-char * after_partb(char * d, char * s, char c)
-{
-  int ipos=0;
-  int i=0;
-  int iflag=0;
-  if (strlen(s) > MAX_TMP_STRING)
-  {
-    fprintf(stderr,"%s","string passed to before_part is too long\n");
-    exit(1);
-  }
-  for (i=strlen(s)-1;i>=0;i--)
-  {
-    if (s[i]==c)
-    {
-      ipos=i+1;
-      iflag=1;
-      break;
-    }
-  }
-  if(iflag)
-  {
-    for (i=ipos;i<strlen(s);i++)
-    {
-      d[i-ipos]=s[i];
-    }
-    d[strlen(s)-ipos]='\0';
-  }
-  else
-  {
-    d[0]='\0';
-  }  
-  return d;
-}
-
-char * strip_leading_blanks(char * d, char * s)
-{
-  int start_flag=0;
-  int j=0;
-  int i=0;
-  if (strlen(s) > MAX_TMP_STRING)
-  {
-    fprintf(stderr,"%s","string passed to before_part is too long\n");
-    exit(1);
-  }
-  for (i=0;i<strlen(s);i++)
-  {
-    if (!start_flag)
-    {
-      if (s[i]!=' ')
-      {
-        start_flag=1;
-        d[j++]=s[i];
-      }
-    }
-    else
-    {
-      d[j++]=s[i];
-    }
-  }
-  d[j]='\0';
-  return d;
-}
-
-char * strip_leading_blanks_and_tabs(char * d, char * s)
-{
-  int start_flag=0;
-  int j=0;
-  int i=0;
-  if (strlen(s) > MAX_TMP_STRING)
-  {
-    fprintf(stderr,"%s","string passed to before_part is too long\n");
-    exit(1);
-  }
-  for (i=0;i<strlen(s);i++)
-  {
-    if (!start_flag)
-    {
-      if (s[i]!=' ' && s[i]!='\t')
-      {
-        start_flag=1;
-        d[j++]=s[i];
-      }
-    }
-    else
-    {
-      d[j++]=s[i];
-    }
-  }
-  d[j]='\0';
-  return d;
-}
-
-int count_paren(int num_paren,char * yytext)
-{
-  int i;
-  for (i=0;i<=strlen(yytext);i++)
-  {
-    if (yytext[i]=='(')
-    {
-      num_paren++;
-    } 
-    if (yytext[i]==')')
-    {
-      num_paren--;
-    } 
-  }
-  return num_paren;
-}
-
-void add_references_to_user_classes(FILE * fall)  
-{
-  int i;
-  if (!no_userclass)
-  {
-    if (num_user_classes)
-    {
-      for (i=0;i<=num_user_classes-1;i++)
-        fprintf(fall,"  %s;\n",reference_statements[i]);
-    }
-  }
-}
-
-void call_destructors_for_user_classes(FILE * fall)  
-{
-  int i;
-  if (num_user_classes)
-  {
-    fprintf(fall,"\n");
-    for (i=0;i<=num_user_classes-1;i++)
-    {
-      fprintf(fall,"  delete pad_%s;\n",class_instances[i]);
-      fprintf(fall,"  pad_%s = NULL;\n",class_instances[i]);
-    }
-  }
-}
-void initialize(char *s)
-{
-  s[0]='\0';
-}  
-
-void marker(void){;}
-
- void write_funnel_end(void)
- {
-   switch (in_funnel_proc)
-   {
-   case 0:
-     break;
-   case 1:
-     fprintf(fall,"  end_df1b2_funnel();\n");
-     break;
-   case 2:
-     fprintf(fall,"  lapprox->end_separable_call_stuff();\n");
-     break;
-   default:
-      fprintf(stderr,"illegal value for in_funnel_proc\n");
-      exit(1);
-   }
-   in_funnel_proc=0;
- }
-
- int option_match(int argc,char * argv[], char * string)
- {
-   int rval=-1;
-   int i=0;
-   for (i=0;i<argc;i++)
-   {
-     if (!strcmp(argv[i],string))
-     {
-       rval=i;
-       break;
-     }
-   }
-   return rval;
- }
-
- void write_unallocated(const char * t)
- {
-   fprintf(stderr,"warning -- creating unallocated %s at line %d\n",t,
-     nline);
- }
-void  get_next_argument(char * buffer,char * arg)
-{
-  int ii;
-  int len;
-  char * tptr;
-  char * ptr;
-  char * argend;
-  char * argbegin;
-  arg[0]='\0';
-  len=strlen(buffer);
-  if (len==0)
-    return;
-  ptr=buffer+len-1;
-  while(*ptr == ' ')
-  {
-    if (ptr<=buffer) break;
-    ptr--;
-  }   
-  argend=ptr;
-  while(*ptr !=' ' && *ptr != '&')
-  {
-    if (ptr<=buffer) break;
-    ptr--;
-  }   
-  argbegin=ptr+1;
-  ii=0;
-  for (tptr=argbegin;tptr<=argend;tptr++)
-  {
-    arg[ii++]=*tptr;
-    if (ii>1000)
-    {
-      printf("Overflow error in get_next_argument\n");
-      exit(1);
-    }
-  } 
-  arg[ii]='\0';
-  while(*ptr !=',' && *ptr != '(')
-  {
-    if (ptr<=buffer) break;
-    ptr--;
-  }   
-  *ptr='\0';
-}
-void write_getindex_stuff(char *str)
-{
-  int icount;
-  /* char * argptr; */
-  int paren_level=0;
-  char * last_paren;
-  char * first_paren;
-  char buffer[10001];
-  char function_arg[1001];
-  printf(" %s \n",str);
-  first_paren=strchr(str,'(');
-  if (first_paren==0)
-  {
-    printf("Error in write_getindex_stuff\n");
-    exit(1);
-  }
-  strncpy(buffer,first_paren+1,10000);
-  last_paren=strrchr(buffer,')');
-  if (last_paren==0)
-  {
-    printf("Error in write_getindex_stuff\n");
-    exit(1);
-  }
-  else
-  {
-    *(last_paren)='\0';
-    paren_level=1;
-  }
-  do
-  {
-    get_next_argument(buffer,&(function_arg[0]));
-    if (strlen(function_arg)==0) break;
-    fprintf(fall,"  ADMB_getcallindex(%s);\n",function_arg);
-    icount++;
-  }
-  while(1);
-  // XNESTED
-}
-
-void print_quadratic_random_effect_penalty_class(char *text)
-{
-  if (class_append_flag==0)
-  {
-    if(fs==0) 
-    {
-      fs=fopen("classdef.tmp","w+");
-    }
-  
-    if(fs1==0) 
-    {
-      fs1=fopen("classcode.tmp","w+");
-      have_classcode_tmp=1;
-    }
-  } 
-  else
-  {
-    if(fs==0) 
-    {
-      fs=fopen("classdef.tmp","a+");
-    }
-  
-    if(fs1==0) 
-    {
-      fs1=fopen("classcode.tmp","a+");
-      have_classcode_tmp=1;
-    }
-  } 
-
-  if (quadratic_classprint_flag==1)
-  {
-    fprintf(fs,"AAA\n");
-   
-    fprintf(fs,"\nclass df1b2quadratic_re_penalty_%s : "
-      "public df1b2quadratic_re_penalty\n" 
-    "{\n"
-    "public:\n"
-    "  void get_Lxu(dmatrix& M);\n"
-    "  void get_cM(void);\n"
-    "  void operator = (const df1b2matrix & M)\n"
-    "  {\n"
-    "    df1b2quadratic_re_penalty::operator = (M);\n"
-    "  }\n"
-    "};\n",text);
-    fprintf(fs,"\nclass quadratic_re_penalty_%s : "
-      "public quadratic_re_penalty\n" 
-    "{\n"
-    "public:\n"
-    "  void get_cM(void);\n"
-    "  void operator = (const dvar_matrix & M)\n"
-    "  {\n"
-    "    quadratic_re_penalty::operator = (M);\n"
-    "  }\n"
-    "};\n",text);
-  }
-  if (quadratic_classprint_flag==2)
-  {
-    if (in_normal_prior_flag==1)
-    {
-      fprintf(fs,"\nclass df1b2_normal_prior_%s : ",text);
-      //in_normal_prior_flag=0;
-    }
-    else
-    {
-      fprintf(fs,"\nclass df1b2_normal_prior_%s : ",text);
-      //fprintf(fs,"\nclass df1b2quadratic_re_penalty_%s : ",text);
-    }
-    fprintf(fs,"public df1b2quadratic_re_penalty\n" 
-    "{\n"
-    "public:\n"
-    "  void get_Lxu(dmatrix& M);\n"
-    "  df1b2_normal_prior_%s(){old_style_flag=0;}\n"
-    "  void get_cM(void);\n"
-    "  void operator = (const df1b2matrix & M)\n"
-    "  {\n"
-    "    df1b2quadratic_re_penalty::operator = (M);\n"
-    "  }\n"
-    "};\n",text);
-    fprintf(fs,"\nclass df_normal_prior_%s : "
-      "public quadratic_re_penalty\n" 
-    "{\n"
-    "public:\n"
-    "  df_normal_prior_%s(){old_style_flag=0;}\n"
-    "  void get_cM(void);\n"
-    "  void operator = (const dvar_matrix & M)\n"
-    "  {\n"
-    "    quadratic_re_penalty::operator = (M);\n"
-    "  }\n"
-    "};\n",text,text);
-
-
-    /*
-     fprintf(fs1,"\nvoid df1b2quadratic_re_penalty_%s::get_Lxu(dmatrix& LXU)\n"
-    */
-    fprintf(fs1,"\nvoid df1b2_normal_prior_%s::get_Lxu(dmatrix& LXU)\n"
-    "{\n"
-     "  df1b2_parameters * mp=\n"
-     "    df1b2_parameters::get_df1b2_parameters_ptr();\n"
-     "  mp->evaluate_M();\n"
-     "  int rmin=Lxu->indexmin();\n"
-     "  int rmax=Lxu->indexmin();\n"
-     "  int cmin=1;\n"
-     "  int cmax=(*Lxu)(rmin).indexmax();\n"
-     "  if (cmax != LXU.indexmax())\n"
-     "  {\n"
-     "    cerr << \"Shape error in get_Lxu\" << endl;\n"
-     "    ad_exit(1);\n"
-     "  }\n"
-     "  \n"
-     "  for (int i=rmin;i<=rmax;i++)\n"
-     "  {\n"
-     "    int row = (int)((*Lxu)(i,0));\n"
-     "    for (int j=cmin;j<=cmax;j++)\n"
-     "    {\n"
-     "      LXU(j,row)+=(*Lxu)(i,j);\n"
-     "    }\n"
-     "  }\n"
-     "}\n",text);
-     fprintf(fs1,"\nvoid df_normal_prior_%s::get_cM(void)\n"
-     "{\n"
-     "  model_parameters * mp=\n"
-     "    model_parameters::get_model_parameters_ptr();\n"
-     "  mp->evaluate_M();\n"
-     "}\n",text);      
-  }
-  
-  if (quadratic_classprint_flag==3)
-  {
-    if (in_normal_prior_flag==1)
-    {
-      fprintf(fs,"\nclass df1b2_normal_prior_%s : ",text);
-      //in_normal_prior_flag=0;
-    }
-    else
-    {
-      fprintf(fs,"\nclass df1b2_normal_prior_%s : ",text);
-      //fprintf(fs,"\nclass df1b2quadratic_re_penalty_%s : ",text);
-    }
-    fprintf(fs,"public df1b2quadratic_re_penalty\n" 
-    "{\n"
-    "public:\n"
-    "  void get_Lxu(dmatrix& M);\n"
-    "  df1b2_normal_prior_%s(){old_style_flag=2;}\n"
-    "  void get_cM(void);\n"
-    "  void operator = (const df1b2matrix & M)\n"
-    "  {\n"
-    "    df1b2quadratic_re_penalty::operator = (M);\n"
-    "  }\n"
-    "};\n",text);
-    fprintf(fs,"\nclass df_normal_prior_%s : "
-      "public quadratic_re_penalty\n" 
-    "{\n"
-    "public:\n"
-    "  df_normal_prior_%s(){old_style_flag=2;}\n"
-    "  void get_cM(void);\n"
-    "  void operator = (const dvar_matrix & M)\n"
-    "  {\n"
-    "    quadratic_re_penalty::operator = (M);\n"
-    "  }\n"
-    "};\n",text,text);
-
-
-    /*
-     fprintf(fs1,"\nvoid df1b2quadratic_re_penalty_%s::get_Lxu(dmatrix& LXU)\n"
-    */
-    fprintf(fs1,"\nvoid df1b2_normal_prior_%s::get_Lxu(dmatrix& LXU)\n"
-    "{\n"
-     "  df1b2_parameters * mp=\n"
-     "    df1b2_parameters::get_df1b2_parameters_ptr();\n"
-     "  mp->evaluate_M();\n"
-     "  int rmin=Lxu->indexmin();\n"
-     "  int rmax=Lxu->indexmin();\n"
-     "  int cmin=1;\n"
-     "  int cmax=(*Lxu)(rmin).indexmax();\n"
-     "  if (cmax != LXU.indexmax())\n"
-     "  {\n"
-     "    cerr << \"Shape error in get_Lxu\" << endl;\n"
-     "    ad_exit(1);\n"
-     "  }\n"
-     "  \n"
-     "  for (int i=rmin;i<=rmax;i++)\n"
-     "  {\n"
-     "    int row=(*Lxu)(i,0);\n"
-     "    for (int j=cmin;j<=cmax;j++)\n"
-     "    {\n"
-     "      LXU(j,row)+=(*Lxu)(i,j);\n"
-     "    }\n"
-     "  }\n"
-     "}\n",text);
-     fprintf(fs1,"\nvoid df_normal_prior_%s::get_cM(void)\n"
-     "{\n"
-     "  model_parameters * mp=\n"
-     "    model_parameters::get_model_parameters_ptr();\n"
-     "  mp->evaluate_M();\n"
-     "}\n",text);      
-  }
-  
-  quadratic_classprint_flag=0;
- 
-  if (fs)
-  {
-    fclose(fs);
-  }
-  fs=0;
-  if (fs1)
-  {
-    fclose(fs1);
-  }
-  fs1=0;
-  class_append_flag=1;
-}
-
-
-
-
-  /* add prior to userfunctions from procedure_section, 
-  */
-  void add_prior_to_objective(void)
-  {  	
-	  prior_done_once=1;priors_done=1;
-	  procedure_done=1;
-	  fprintf(fdat,"  void priorsfunction(void);\n");  //add to .htp file
-	  //fprintf(fall,"%s","  prior_function_value=0.0;\n");
-      fprintf(fall,"%s","  priorsfunction();\n");
-      //fprintf(fall,"%s%s%s","  ",objective_function_name_string,"+=prior_function_value;\n");          
-  }
-
-
-
-  /* add likelihood function value to userfunctions from procedure_section, 
-  */
-  void add_likelihood_to_objective(void)
-  {  	
-	  likelihood_done_once=1;likelihood_done=1;
-	  procedure_done=1;
-	  fprintf(fdat,"  void likelihoodfunction(void);\n");  //add to .htp file
-	  //fprintf(fall,"%s","  likelihood_function_value=0.0;\n");
-      fprintf(fall,"%s","  likelihoodfunction();\n");
-      //fprintf(fall,"%s%s%s","  ",objective_function_name_string,"+=likelihood_function_value;\n");          
-  }
-
-
-
-  /* reset some control variable for prior and likelihood section, this will be repeated on multiple other sections, 
-  * so we organize them as a function 
-  */
-  void setup_for_prior_likelihood(void)
-  { 	
-	if(priors_defined) priors_done=1; 
-	if(likelihood_defined) likelihood_done=1;
-	if((procedure_defined)&&(!priors_defined)&&(!likelihood_defined)) procedure_done=1;
-	if((procedure_defined)&&(priors_defined)&&(!prior_done_once)) add_prior_to_objective();
-	if((procedure_defined)&&(likelihood_defined)&&(!likelihood_done_once)) add_likelihood_to_objective();
-  }
-
-
- /* strip off the leading and trailing spaces from an input string, call it by trim(istring),
-    istring still use the same memory address, but the values being changed due to removed spaces, 
-    used to compare the function name for prior_section
- */
- void trim(char * a)
- { 
-	  size_t walker = strlen ( a );
-    //printf ( "Before: |%s|\n\n", a );
-
-    /* Trim trailing spaces */
-    while ( walker > 0 && isspace ( a[walker - 1] ) )
-      --walker;
-    a[walker] = '\0';
- 
-    //printf ( "Trailing: |%s|\n\n", a );
-
-    /* Trim leading spaces */
-    walker = strspn ( a, " \t\n\v" );
-    memmove ( a, a + walker, strlen ( a + walker ) + 1 );
- }
-
-
-
- /* check the prior from parameter lists or not, if found it, return 0, ow return 1
-    not care about the position, 
-    it looks complicate because the prior has wider pattern than parameter,
-    such as for parameter a, we may get -log(a), or a(i) for its prior, so we need to tell if 
-    this prior come from parameter a, 
- */
- int prior_check(char * parameter, char * prior)
- {
-   if(strlen(parameter)==strlen(prior)) 
-     return strcmp(parameter,prior); //0 is founded
-   else if (strlen(parameter)<strlen(prior))
-   {
-     int i=0;
-     int j=0;
-     int cnt=0;
-     int start_flag=0;
-     for(i=0;i<strlen(prior);i++)
-     {
-       //printf("%d,%s,%s\n",i,parameter, prior);
-       if(prior[i]==parameter[j]) { //found match
-         cnt++; 
-         if(i==0) start_flag=1;         
-         if(cnt<strlen(parameter)) j++;
-         //printf("* i=%d, cnt=%d, j=%d , flag=%d \n",i,cnt, j,start_flag);
-         if(i==(strlen(prior)-1) && cnt==strlen(parameter) && start_flag)//only return for the last found match
-           return 0; //found it            
-       }
-       else{ //not match
-         if(cnt==strlen(parameter)) {//take care for special character for not matched one
-           if(!isalnum(prior[i]) && start_flag)  return 0; //found it
-         }
-         if(!isalnum(prior[i])) start_flag=1;
-         else start_flag=0;
-         cnt=0;j=0; 
-         //printf("** i=%d, cnt=%d, j=%d , flag=%d \n",i,cnt, j,start_flag);
-       }
-       if(i==(strlen(prior)-1) && cnt<strlen(parameter)) return 1; //until the end still not found
-     } //end for loop
-   }
-   else return 1; //not found
- }
+%option noyywrap
+
+%{
+  #define   MAX_TMP_STRING 2000 
+  #define   MAX_USER_CLASSES  450
+  #define   MAX_USER_CLASSNAME_LENGTH  181
+  #include <stdlib.h>
+  #include <string.h>
+  #include <stdio.h>
+  #if defined(_WIN32)
+  #include <io.h>  /* fopen */
+  #endif
+  char tmp_string[MAX_TMP_STRING];
+  char tmp_string1[MAX_TMP_STRING];
+  char tmp_string2[MAX_TMP_STRING];
+  char tmp_string3[MAX_TMP_STRING];
+  char tmp_string4[MAX_TMP_STRING];
+  char reference_statements[MAX_USER_CLASSES][MAX_USER_CLASSNAME_LENGTH];
+  char class_instances[MAX_USER_CLASSES][MAX_USER_CLASSNAME_LENGTH];
+  char outcommand[350];
+  char outcommand2[250];
+  char outcommand3[250];
+  char outcommand3a[250];
+  char outcommand3b[250];
+  char outcommand4[250];
+  char outcommand5[250];
+  char outcommand6[250];
+  char outcommand7[250];
+  char outcommand8[250];
+  char * dirpath;
+  char seddirpath[101];
+  char infile_name[1000];
+  char infile_root[1000];
+  char name_string[150];
+  char outfile_name[1000];
+  char headerfile_name[125];
+  char deffile_name[125];
+  char headerfile_name2[125];
+  int  verbosemode=0;
+  int  num_spargs=0;
+  int in_objective_function_value_flag=0;
+  int  pvmslaves_defined=0;
+  int  splus_debug_flag=0;
+  int  spnumber_flag=0;
+  int random_effects_flag=0;
+  int data_defined=0;
+  int in_define_data=0;
+  int need_prior_globals=0;
+  int debug_flag=0;
+  int makedll=0;
+  int makegaussdll=0;
+  int no_userclass=0;
+  int bound_flag=0;
+  int in_normal_prior_flag=0;
+  int normal_prior_flag2=0;
+  int num_user_classes=0;
+  int have_separable_function=0;
+  int final_defined=0;
+  int top_of_main_defined=0;
+  int globals_section_defined=0;
+  int in_define_parameters=0;
+  int talk_to_splus=0;
+  int initialization_defined=0;
+  int objective_function_defined=0;
+  int report_defined=0;
+  int preliminary_calcs_defined=0;
+  int between_phases_defined=0;
+  int needs_initialization=0;
+  int quadratic_prior_flag=0;
+  int quadratic_classprint_flag=0;
+  int errcopy=0;
+  int params_defined=0;
+  int runtime_defined=0;
+  int procedure_defined=0;
+  int in_procedure_def=0;
+  int class_append_flag=0;
+  int in_aux_proc=0;
+  int in_funnel_proc=0;
+  int in_normal_prior=0;
+  int nline=1;
+  int have_likeprof=0;
+  int num_paren=0;
+  int nchar=0;
+  int sparse_quadprior_flag=0;
+  int sparse_normal_flag=0;
+  int warn_unallocated=1;
+  int have_classcode_tmp=0;
+  char *  conlist_ptr;
+  char conlist[6000];
+  char *  classlist_ptr;
+  char classlist[6000];
+  char *  arglist1_ptr;
+  char arglist1[4000];
+  char *  arglist_ptr;
+  char arglist[4000];
+  char uuu_xxx[80]={"Copyright (c) 2008-2011 Regents of the University of California"};
+  FILE * fdat=NULL;
+  FILE * fdat1=NULL;
+  FILE * htop=NULL;
+  FILE * fall=NULL;
+  FILE * fhead=NULL;
+  FILE * fglobals=NULL;
+  FILE * ftopmain=NULL;
+  FILE * fs=NULL;
+  FILE * fs1=NULL;
+  FILE * tempf_NP=NULL;
+  void write_getindex_stuff(char *str);
+  void initialize(char *);
+  char * before_part(char * d, char * s, char c);
+  char * before_partb(char * d, char * s, char c);
+  char * strict_after_part(char * d, char * s, char c);
+  char * after_part(char * d, char * s, char c);
+  char * after_partb(char * d, char * s, char c);
+  char * strip_leading_blanks(char * d, char * s);
+  char * strip_leading_blanks_and_tabs(char * d, char * s);
+  void check_random_effects_ordering(void);
+  int count_paren(int num_paren,char * yytext);
+  void add_references_to_user_classes(FILE * fall);  
+  void write_funnel_end(void);
+  void write_end_normal_prior(void);
+  void call_destructors_for_user_classes(FILE * fall); 
+  void marker(void);
+  void write_unallocated(const char *);
+  void print_quadratic_random_effect_penalty_class(char *text);
+%}
+
+filename \"[^\"]*\"
+
+filenamesingle \'[^\']*\'
+
+name [a-z_A-Z]+(->)?[a-z_A-Z0-9]*
+
+num_exp [a-z_A-Z0-9\+\-\*\/]+
+
+index ([a-z_A-Z]+(->)?[a-z_A-Z0-9]*)|([a-z_A-Z0-9\+\-\*\/]+)
+
+float_num_exp [a-z_A-Z0-9\.\+\-\*]+
+
+%s DEFINE_DATA DEFINE_PARAMETERS DEFINE_PROCS DEFINE_PROCS_NP IN_DATA_DEF IN_PARAM_DEF
+%s IN_NUMBER_DEF IN_SPNUMBER_DEF IN_VECTOR_DEF IN_VECTOR_VECTOR_DEF 
+%s IN_SPVECTOR_DEF 
+%s IN_MATRIX_DEF IN_TABLE_DEF IN_SPMATRIX_DEF IN_THREE_ARRAY_DEF IN_SPTHREE_ARRAY_DEF
+%s IN_NAMED_NUMBER_DEF IN_NAMED_VECTOR_DEF IN_NAMED_MATRIX_DEF
+%s IN_NAMED_THREE_ARRAY_DEF IN_NAMED_FOUR_ARRAY_DEF DEFINE_AUX_PROC
+%s INIT_BOUNDED_NUMBER_DEF INIT_BOUNDED_VECTOR_DEF IN_BOUNDED_MATRIX_DEF
+%s DEFINE_INITIALIZATION DEFINE_PRELIMINARY_CALCS INIT_BOUNDED_MATRIX_DEF
+%s CONTINUE_PROTOTYPE_DEF DEFINE_RUNTIME IN_FOUR_ARRAY_DEF IN_LOCAL_CALCS
+%s IN_GLOBALS_SECTION IN_TOP_SECTION INIT_BOUNDED_THREE_ARRAY_DEF 
+%s DEFINE_BETWEEN_PHASES IN_FIVE_ARRAY_DEF IN_SIX_ARRAY_DEF IN_SEVEN_ARRAY_DEF 
+%s IN_NAMED_FIVE_ARRAY_DEF IN_NAMED_SIX_ARRAY_DEF IN_NAMED_SEVEN_ARRAY_DEF 
+%s IN_SPBOUNDED_NUMBER_DEF INIT_SPBOUNDED_VECTOR_DEF IN_PVM_SLAVE_SECTION
+%%
+;             /* ignore semi colons */ ;
+[ \t]+        /* ignore blanks */  ;
+\/\/.*$         /* ignore trailing comments */ ;
+
+\n    { nline++; }
+\r    { ; }
+
+INITIALIZATION_SECTION  {
+
+  /*
+  if (!data_defined)
+  {
+    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
+      " INITIALIZATION_SECTION \n");
+    exit(1);
+  }
+  if (initialization_defined)
+  {
+    fprintf(stderr,"%s","Error -- only one INTIALIZATION SECTION allowed\n");
+    exit(1);
+  }
+  if (!params_defined)
+  {
+    fprintf(stderr,"Error -- INITIALIZATION_SECTION must be defined before"
+      " PARAMETER_SECTION \n");
+    exit(1);
+  }
+  else
+  */
+  {
+    BEGIN DEFINE_INITIALIZATION;
+    initialization_defined=1;
+    fprintf(fall,"%s","}\n\nvoid model_parameters::initializationfunction(void)"
+      "\n{\n");
+  }
+                }
+
+REPORT_SECTION  {
+
+  in_aux_proc=0;
+  if (!data_defined)
+  {
+    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
+      " REPORT_SECTION \n");
+    exit(1);
+  }
+  if (report_defined)
+  {
+    fprintf(stderr,"%s","Error -- only one REPORT SECTION allowed\n");
+    exit(1);
+  }
+  if (!params_defined)
+  {
+    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
+      " REPORT_SECTION \n");
+    exit(1);
+  }
+  else
+  {
+    BEGIN DEFINE_PROCS;
+    report_defined=1;
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"}\n");
+    //if (!preliminary_calcs_defined)
+    {
+      fclose(fall);
+      fall=fopen("xxalloc4.tmp","w+");
+      if (fall==NULL)
+      {
+        fprintf(stderr,"%s","Error trying to open file xxalloc4.tmp\n");
+      }
+    }
+    fprintf(fall,"%s","\nvoid model_parameters::report()"
+      "\n{\n");
+    fprintf(fall," adstring ad_tmp=initial_params::get_reportfile_name();\n");
+    fprintf(fall,"  ofstream report((char*)"
+                 "(adprogram_name + ad_tmp));\n");
+    fprintf(fall,"  if (!report)\n"
+                 "  {\n    cerr << \"error trying to open report file\" "
+                 " << adprogram_name << \".rep\";\n    return;\n  }\n");
+  }
+                }
+
+FINAL_SECTION  {
+
+  in_aux_proc=0;
+  if (!data_defined)
+  {
+    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
+      " FINAL_SECTION \n");
+    exit(1);
+  }
+  if (final_defined)
+  {
+    fprintf(stderr,"%s","Error -- only one FINAL SECTION allowed\n");
+    exit(1);
+  }
+  if (!params_defined)
+  {
+    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
+      " FINAL_SECTION \n");
+    exit(1);
+  }
+  else
+  {
+    BEGIN DEFINE_PROCS;
+    final_defined=1;
+    fprintf(fall,"%s","}\n\nvoid model_parameters::final_calcs()"
+      "\n{\n");
+  }
+                }
+
+
+RUNTIME_SECTION  {
+
+  in_aux_proc=0;
+  if (!data_defined)
+  {
+    fprintf(stderr,"Error -- DATA_SECTION must be defined before"
+      " REPORT_SECTION \n");
+    exit(1);
+  }
+  if (runtime_defined)
+  {
+    fprintf(stderr,"%s","Error -- only one REPORT SECTION allowed\n");
+    exit(1);
+  }
+  if (!params_defined)
+  {
+    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
+      " RUNTIME_SECTION \n");
+    exit(1);
+  }
+  else
+  {
+    BEGIN DEFINE_RUNTIME;
+    runtime_defined=1;
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"%s","}\n\nvoid model_parameters::set_runtime(void)"
+      "\n{\n");
+  }
+                }
+
+<DEFINE_RUNTIME>^" "*convergence_criteria" ".*$ { 
+
+    strip_leading_blanks(tmp_string1,yytext);
+    after_part(tmp_string2,tmp_string1,' ');  // get 10  in x  10
+    strip_leading_blanks(tmp_string1,tmp_string2);
+    fprintf(fall,"%s","  dvector temp(\"{"); 
+    fprintf(fall,"%s}\");\n", tmp_string1); 
+    fprintf(fall,"  convergence_criteria.allocate"
+      "(temp.indexmin(),temp.indexmax());\n" ); 
+    fprintf(fall,"  convergence_criteria=temp;\n");
+
+                                  }
+
+<DEFINE_RUNTIME>^" "*maximum_function_evaluations" ".*$ { 
+
+    strip_leading_blanks(tmp_string1,yytext);
+    after_part(tmp_string2,tmp_string1,' ');  // get 10  in x  10
+    strip_leading_blanks(tmp_string1,tmp_string2);
+    fprintf(fall,"%s","  dvector temp1(\"{"); 
+    fprintf(fall,"%s}\");\n", tmp_string1); 
+    fprintf(fall,"  maximum_function_evaluations.allocate"
+      "(temp1.indexmin(),temp1.indexmax());\n" ); 
+    fprintf(fall,"  maximum_function_evaluations=temp1;\n");
+
+                                  }
+
+
+PRELIMINARY_CALCULATIONS_SECTION  |
+PRELIMINARY_CALCS_SECTION  {
+
+#  if defined(ADMB_REDEMO)
+    printf("Error -- you can not use the PRELIMINARY_CALCS_SECTION"
+      "\n in the random effects model at present. Use LOCAL_CALCS instead\n");
+    exit(1);
+#  endif
+    //preliminary_calcs_defined=1;
+    write_end_normal_prior();
+    write_funnel_end();
+  if (!data_defined)
+  {
+    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
+      " INITIALIZATION_SECTION \n");
+    exit(1);
+  }
+  if (preliminary_calcs_defined)
+  {
+    fprintf(stderr,"%s","Error -- only one PRELIMINARY_CALCS_SECTION allowed\n");
+    exit(1);
+  }
+  if (!params_defined)
+  {
+    fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
+      " PRELIMINARY_CALCS_SECTION\n");
+    exit(1);
+  }
+  else
+  {
+    BEGIN DEFINE_PRELIMINARY_CALCS;
+    preliminary_calcs_defined=1;
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"}\n");
+    //if (!report_defined)
+    {
+      fclose(fall);
+      fall=fopen("xxalloc5.tmp","w+");
+      if (fall==NULL)
+      {
+        fprintf(stderr,"%s","Error trying to open file xxalloc5.tmp\n");
+      }
+    }
+    fprintf(fall,"%s","\nvoid model_parameters::preliminary_calculations(void)"
+      "\n{\n");
+    fprintf(fall,"%s","\n  admaster_slave_variable_interface(*this);\n");
+  }
+                }
+
+<DEFINE_PRELIMINARY_CALCS>^" ".* {fprintf(fall,"%s\n",yytext);}
+
+BETWEEN_PHASES_SECTION {
+
+  if (between_phases_defined)
+  {
+    fprintf(stderr,"%s","Error -- only one BETWEEN_PHASES_SECTION allowed\n");
+    exit(1);
+  }
+  else
+  {
+    BEGIN DEFINE_BETWEEN_PHASES;
+    between_phases_defined=1;
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"%s","}\n\nvoid model_parameters::between_phases_calculations(void)"
+      "\n{\n");
+    fprintf(fdat,"%s","  void between_phases_calculations(void);\n");
+  }
+                }
+
+<DEFINE_BETWEEN_PHASES>^" ".* {fprintf(fall,"%s\n",yytext);}
+
+
+<DEFINE_INITIALIZATION>{name}[ ]+{float_num_exp} {
+
+
+    before_part(tmp_string,yytext,' ');  // get x in x 10
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".set_initial_value(");
+    after_part(tmp_string1,yytext,' ');  // get 10  in x  10
+    strip_leading_blanks(tmp_string2,tmp_string1);
+    fprintf(fall,"%s);\n",tmp_string2);
+
+                            }
+
+SLAVE_SECTION  {
+
+  if (pvmslaves_defined)
+  {
+    fprintf(stderr,"%s","Error -- only one pvm slave section allowed\n");
+    exit(1);
+  }
+  else
+  {
+    BEGIN IN_PVM_SLAVE_SECTION;
+    pvmslaves_defined=1;
+    fprintf(fdat,"  virtual imatrix get_slave_assignments(void);\n");
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"%s","}\n\nimatrix model_parameters::"
+      "get_slave_assignments(void)\n{\n");
+  }
+
+         }
+
+<IN_PVM_SLAVE_SECTION>^[ \t].*$ { fprintf(fall,"%s\n",yytext); }
+
+DATA_SECTION  {
+
+  if (data_defined)
+  {
+    fprintf(stderr,"%s","Error -- only one data section allowed\n");
+    exit(1);
+  }
+  else
+  {
+    BEGIN DEFINE_DATA;
+    data_defined=1;
+    in_define_data=1;
+    if (makedll)
+    { 
+      fprintf(fall,"%s","model_data::model_data(int argc,char * argv[],dll_args& ad_dll) : "
+        "ad_comm(argc,argv)\n{\n");
+      fprintf(fdat,"%s","class dll_args;\n");
+    }  
+    else  
+    {
+        
+      fprintf(fall,"%s","model_data::model_data(int argc,char * argv[]) : "
+        "ad_comm(argc,argv)\n{\n");
+    }  
+    fprintf(fdat,"%s","#define SEPFUN1\n");
+    fprintf(fdat,"%s","#define SEPFUN3\n");
+    fprintf(fdat,"%s","#define SEPFUN4\n");
+
+    fprintf(fdat,"%s","class model_data : public ad_comm{\n"
+       "  public:\n");
+  }
+                }
+
+<DEFINE_DATA>^[ \t]*!!USER_CODE.*$ {
+    strip_leading_blanks_and_tabs(tmp_string1,yytext);
+    strcpy(tmp_string2,tmp_string1+11);
+    fprintf(fall,"%s\n",tmp_string2);
+    
+    }
+
+<DEFINE_DATA>^[ \t]*!!CLASS.*$ {              // start with !!CLASSbbclassname classinstance(xxx)
+    num_user_classes++;
+    strip_leading_blanks_and_tabs(tmp_string1,yytext);
+    strcpy(tmp_string2,tmp_string1+7);  // now bbclassname classinstance(xxx)
+    strip_leading_blanks(tmp_string1,tmp_string2); // now classname classinstance(xxx)
+    initialize(tmp_string);
+    before_part(tmp_string,tmp_string1,'('); // now classname classinstance in tmp_string
+    if (!strlen(tmp_string)) 
+    {
+      strcpy(tmp_string,tmp_string1);
+    }  
+    //fprintf(fdat,"%s;\n",tmp_string);
+    before_partb(tmp_string2,tmp_string,' '); // now classname in tmp_string2
+    
+    after_partb(tmp_string3,tmp_string,' ');  // now bbclassinstance in tmp_string3
+    strip_leading_blanks(tmp_string4,tmp_string3);// now classinstance in tmp_string4
+    fprintf(fdat,"  %s * ",tmp_string2);
+    fprintf(fdat,"  pad_%s;\n",tmp_string4);
+    
+    fprintf(fall,"  pad_%s = new ",tmp_string4);
+    fprintf(fall,"%s",tmp_string2);
+    initialize(tmp_string3);
+    after_partb(tmp_string3,tmp_string1,'(');  // now xxx) in tmp_string3
+    if (strlen(tmp_string3))
+    {
+      fprintf(fall,"(%s",tmp_string3);
+    } 
+    fprintf(fall,";\n");
+    strcpy(reference_statements[num_user_classes-1],tmp_string2);
+    strcat(reference_statements[num_user_classes-1],"& ");
+    strcat(reference_statements[num_user_classes-1],tmp_string4);
+    strcat(reference_statements[num_user_classes-1],"= *pad_");
+    strcat(reference_statements[num_user_classes-1],tmp_string4);
+    //strcat(reference_statements[num_user_classes-1],";");
+    strcpy(class_instances[num_user_classes-1],tmp_string4);
+    
+  }
+
+<DEFINE_DATA>^[ \t]*@@.*$ {              // start with !!CLASSbbclassname classinstance(xxx)
+    strip_leading_blanks_and_tabs(tmp_string1,yytext);
+    printf("ddd\n");
+    strcpy(tmp_string2,tmp_string1+2);  // now bbclassname classinstance(xxx)
+    strip_leading_blanks(tmp_string1,tmp_string2); // now classname classinstance(xxx)
+    initialize(tmp_string);
+    before_part(tmp_string,tmp_string1,'('); // now classname classinstance in tmp_string
+    if (!strlen(tmp_string)) 
+    {
+      strcpy(tmp_string,tmp_string1);
+    }  
+    //fprintf(fdat,"%s;\n",tmp_string);
+    before_partb(tmp_string2,tmp_string,' '); // now classname in tmp_string2
+    
+    after_partb(tmp_string3,tmp_string,' ');  // now bbclassinstance in tmp_string3
+    strip_leading_blanks(tmp_string4,tmp_string3);// now classinstance in tmp_string4
+    fprintf(fdat,"  %s ",tmp_string2);
+    fprintf(fdat,"  %s;\n",tmp_string4);
+    
+    fprintf(fall,"  %s * tmp_%s = new ",tmp_string2,tmp_string4);
+    fprintf(fall,"%s",tmp_string2);
+
+
+    initialize(tmp_string3);
+    after_partb(tmp_string3,tmp_string1,'(');  // now xxx) in tmp_string3
+    if (strlen(tmp_string3))
+    {
+      fprintf(fall,"(%s",tmp_string3);
+    } 
+    fprintf(fall,";\n");
+    fprintf(fall,"  memcpy(cbuf,(char*)(&%s),sizeof(%s));\n",
+      tmp_string4,tmp_string2);
+    fprintf(fall,"  memcpy((char*)(&%s),(char*)(tmp_%s),sizeof(%s));\n",
+      tmp_string4,tmp_string4,tmp_string2);
+    fprintf(fall,"  memcpy((char*)(tmp_%s),buf,sizeof(%s));\n",
+      tmp_string4,tmp_string2);
+    fprintf(fall,"  delete tmp_%s;\n",tmp_string4);
+    fprintf(fall,"  tmp_%s=NULL;\n",tmp_string4);
+
+    
+  }
+
+<DEFINE_DATA>^[ \t]*!!.*$ {
+    strip_leading_blanks_and_tabs(tmp_string1,yytext);
+    strcpy(tmp_string2,tmp_string1+2);
+    fprintf(fall,"%s\n",tmp_string2);
+    
+    }
+
+
+
+<DEFINE_DATA>^[ \t]*LOCAL_CALCULATIONS | 
+<DEFINE_DATA>^[ \t]*LOCAL_CALCS |
+<DEFINE_DATA>^[ \t]*LOC_CALCULATIONS | 
+<DEFINE_DATA>^[ \t]*LOC_CALCS  {
+
+    BEGIN IN_LOCAL_CALCS;
+
+        }
+
+<DEFINE_DATA>init_number {
+
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  data_number ");
+                     }
+
+<DEFINE_DATA>init_adstring {
+
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  init_adstring ");
+                     }
+
+<DEFINE_DATA>init_line_adstring {
+
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  init_line_adstring ");
+                     }
+
+<DEFINE_DATA>init_int {
+
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  data_int ");
+                     }
+		     
+<DEFINE_DATA>splus_number |
+<DEFINE_DATA>dll_init_number |
+<DEFINE_DATA>dll_number {
+    spnumber_flag=1;
+    BEGIN IN_SPNUMBER_DEF;
+    fprintf(fdat,"%s","  dll_data_number ");
+                     }
+
+<DEFINE_DATA>splus_int |
+<DEFINE_DATA>dll_init_int |
+<DEFINE_DATA>dll_int {
+
+    BEGIN IN_SPNUMBER_DEF;
+    fprintf(fdat,"%s","  dll_data_int ");
+                     }
+
+<DEFINE_DATA>splus_adstring |
+<DEFINE_DATA>dll_adstring {
+    spnumber_flag=2;
+
+    BEGIN IN_SPNUMBER_DEF;
+    fprintf(fdat,"%s","  dll_named_adstring ");
+                     }
+
+<DEFINE_DATA>splus_vector |
+<DEFINE_DATA>dll_init_vector |
+<DEFINE_DATA>dll_vector {
+    spnumber_flag=1;
+
+    BEGIN IN_SPVECTOR_DEF;
+    fprintf(fdat,"%s","  dll_data_vector ");
+                     }
+
+<DEFINE_DATA>init_vector {
+
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  data_vector ");
+                     }
+
+<DEFINE_DATA>init_ivector {
+
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  data_ivector ");
+                     }
+
+<DEFINE_DATA>splus_matrix |
+<DEFINE_DATA>dll_init_matrix |
+<DEFINE_DATA>dll_matrix {
+
+    spnumber_flag=1;
+    BEGIN IN_SPMATRIX_DEF;
+    fprintf(fdat,"%s","  dll_data_matrix ");
+                     }
+
+<DEFINE_DATA>splus_imatrix |
+<DEFINE_DATA>dll_init_imatrix |
+<DEFINE_DATA>dll_imatrix {
+
+    //spnumber_flag=1;
+    BEGIN IN_SPMATRIX_DEF;
+    fprintf(fdat,"%s","  dll_data_imatrix ");
+                     }
+
+<DEFINE_DATA>init_imatrix {
+
+    //spnumber_flag=1;
+    BEGIN IN_MATRIX_DEF;
+    fprintf(fdat,"%s","  data_imatrix ");
+                     }
+
+<DEFINE_DATA>splus_3darray |
+<DEFINE_DATA>dll_init_3darray |
+<DEFINE_DATA>dll_3darray {
+
+    spnumber_flag=1;
+    BEGIN IN_SPTHREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  dll_data_3array ");
+                     }
+
+<DEFINE_DATA>init_matrix {
+
+    BEGIN IN_MATRIX_DEF;
+    fprintf(fdat,"%s","  data_matrix ");
+                     }
+
+<DEFINE_DATA>init_table {
+    BEGIN IN_TABLE_DEF;
+    fprintf(fdat,"%s","  data_matrix ");
+                     }
+
+<DEFINE_DATA>init_3darray {
+
+    BEGIN IN_THREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  data_3array ");
+                     }
+
+
+<DEFINE_DATA>init_4darray {
+
+    BEGIN IN_FOUR_ARRAY_DEF;
+    fprintf(fdat,"%s","  data_4array ");
+                     }
+
+<DEFINE_DATA>init_5darray {
+
+    BEGIN IN_FIVE_ARRAY_DEF;
+    fprintf(fdat,"%s","  data_5array ");
+                     }
+
+
+<DEFINE_DATA>init_6darray {
+
+    BEGIN IN_SIX_ARRAY_DEF;
+    fprintf(fdat,"%s","  data_6array ");
+                     }
+
+
+<DEFINE_DATA>init_7darray {
+
+    BEGIN IN_SEVEN_ARRAY_DEF;
+    fprintf(fdat,"%s","  data_4array ");
+                     }
+
+
+<DEFINE_DATA>number {
+
+    BEGIN IN_NAMED_NUMBER_DEF;
+    fprintf(fdat,"%s","  double ");
+
+                     }
+
+<DEFINE_DATA>int {
+
+    BEGIN IN_NAMED_NUMBER_DEF;
+    fprintf(fdat,"%s","  int ");
+                     }
+
+<DEFINE_DATA>vector {
+
+    BEGIN IN_NAMED_VECTOR_DEF;
+    fprintf(fdat,"%s","  dvector ");
+                     }
+
+<DEFINE_DATA>ivector {
+
+    BEGIN IN_NAMED_VECTOR_DEF;
+    fprintf(fdat,"%s","  ivector ");
+                     }
+
+<DEFINE_DATA>matrix {
+
+    BEGIN IN_NAMED_MATRIX_DEF;
+    fprintf(fdat,"%s","  dmatrix ");
+                     }
+
+<DEFINE_DATA>imatrix {
+
+    BEGIN IN_NAMED_MATRIX_DEF;
+    fprintf(fdat,"%s","  imatrix ");
+                     }
+
+<DEFINE_DATA>3darray {
+
+    BEGIN IN_NAMED_THREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  d3_array ");
+                     }
+
+<DEFINE_DATA>4darray {
+
+    BEGIN IN_NAMED_FOUR_ARRAY_DEF;
+    fprintf(fdat,"%s","  d4_array ");
+                     }
+
+<DEFINE_DATA>5darray {
+
+    BEGIN IN_NAMED_FIVE_ARRAY_DEF;
+    fprintf(fdat,"%s","  d5_array ");
+                     }
+
+<DEFINE_DATA>6darray {
+
+    BEGIN IN_NAMED_FIVE_ARRAY_DEF;
+    fprintf(fdat,"%s","  d6_array ");
+                     }
+
+<DEFINE_DATA>7darray {
+
+    BEGIN IN_NAMED_FIVE_ARRAY_DEF;
+    fprintf(fdat,"%s","  d7_array ");
+                     }
+
+<IN_LOCAL_CALCS>^[ \t]END_CALCS | 
+<IN_LOCAL_CALCS>^[ \t]END_CALCULATIONS {
+
+    if (in_define_data) BEGIN DEFINE_DATA;
+    if (in_define_parameters) BEGIN DEFINE_PARAMETERS;
+      
+                  }
+
+<IN_LOCAL_CALCS>^[ \t][ \t].*$       {
+    fprintf(fall,"%s\n",yytext);
+          }
+
+<DEFINE_PARAMETERS>^[ \t]*!!CLASS.*$ {              // start with !!CLASSbbclassname classinstance(xxx)
+    num_user_classes++;
+    strip_leading_blanks_and_tabs(tmp_string1,yytext);
+    strcpy(tmp_string2,tmp_string1+7);  // now bbclassname classinstance(xxx)
+    strip_leading_blanks(tmp_string1,tmp_string2); // now classname classinstance(xxx)
+    initialize(tmp_string);
+    before_part(tmp_string,tmp_string1,'('); // now classname classinstance in tmp_string
+    if (!strlen(tmp_string)) 
+    {
+      strcpy(tmp_string,tmp_string1);
+    }  
+    //fprintf(fdat,"%s;\n",tmp_string);
+    before_partb(tmp_string2,tmp_string,' '); // now classname in tmp_string2
+    
+    after_partb(tmp_string3,tmp_string,' ');  // now bbclassinstance in tmp_string3
+    strip_leading_blanks(tmp_string4,tmp_string3);// now classinstance in tmp_string4
+    fprintf(fdat,"  %s * ",tmp_string2);
+    fprintf(fdat,"  pad_%s;\n",tmp_string4);
+    
+    fprintf(fall,"  pad_%s = new ",tmp_string4);
+    fprintf(fall,"%s",tmp_string2);
+    initialize(tmp_string3);
+    after_partb(tmp_string3,tmp_string1,'(');  // now xxx) in tmp_string3
+    if (strlen(tmp_string3))
+    {
+      fprintf(fall,"(%s",tmp_string3);
+    } 
+    fprintf(fall,";\n");
+    strcpy(reference_statements[num_user_classes-1],tmp_string2);
+    strcat(reference_statements[num_user_classes-1],"& ");
+    strcat(reference_statements[num_user_classes-1],tmp_string4);
+    strcat(reference_statements[num_user_classes-1],"= *pad_");
+    strcat(reference_statements[num_user_classes-1],tmp_string4);
+    //strcat(reference_statements[num_user_classes-1],";");
+    strcpy(class_instances[num_user_classes-1],tmp_string4);
+    
+  }
+
+<DEFINE_PARAMETERS>^[ \t]*!!USER_CODE.*$ {
+    strip_leading_blanks_and_tabs(tmp_string1,yytext);
+    strcpy(tmp_string2,tmp_string1+11);
+    fprintf(fall,"%s\n",tmp_string2);
+    
+    }
+
+<DEFINE_PARAMETERS>^[ \t]*!!.*$ {
+    strip_leading_blanks_and_tabs(tmp_string1,yytext);
+    strcpy(tmp_string2,tmp_string1+2);
+    fprintf(fall,"%s\n",tmp_string2);
+    
+    }
+
+<DEFINE_PARAMETERS>^[ \t]*LOCAL_CALCULATIONS | 
+<DEFINE_PARAMETERS>^[ \t]*LOCAL_CALCS |
+<DEFINE_PARAMETERS>^[ \t]*LOC_CALCULATIONS | 
+<DEFINE_PARAMETERS>^[ \t]*LOC_CALCS  {
+
+    BEGIN IN_LOCAL_CALCS;
+
+        }
+
+<DEFINE_PARAMETERS>number {
+
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  param_number ");
+    needs_initialization=1;
+                    }
+
+<DEFINE_PARAMETERS>objective_function_value {
+
+    in_objective_function_value_flag=1;
+    if(objective_function_defined++)
+    {
+      fprintf(stderr,"%s %d %s","Error in line",nline,"\n");
+      fprintf(stderr,"only one instance of objective_function_value" 
+                     " may be declared\n");
+      exit(1);
+    }
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  objective_function_value ");
+                     }
+
+<DEFINE_PARAMETERS>sdreport_number {
+
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  param_stddev_number ");
+                     }
+
+<DEFINE_PARAMETERS>likeprof_number {
+
+    have_likeprof=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  param_likeprof_number ");
+                     }
+
+<DEFINE_PARAMETERS>init_int {
+
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  param_init_int ");
+                     }
+
+<DEFINE_PARAMETERS>equality_constraint_vector {
+
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  equality_constraint_vector ");
+    needs_initialization=1;
+                     }
+<DEFINE_PARAMETERS>inequality_constraint_vector {
+
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  inequality_constraint_vector ");
+    needs_initialization=1;
+                     }
+
+<DEFINE_PARAMETERS>vector {
+
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  param_vector ");
+    needs_initialization=1;
+                     }
+
+<DEFINE_PARAMETERS>constant_quadratic_penalty {
+
+    BEGIN IN_NUMBER_DEF;
+    //BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  constant_quadratic_re_penalty ");
+    //needs_initialization=1;
+      quadratic_prior_flag=1;
+                     }
+
+<DEFINE_PARAMETERS>quadratic_penalty {
+
+    BEGIN IN_NUMBER_DEF;
+    //BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  df_normal_prior_");
+    //needs_initialization=1;
+      quadratic_classprint_flag=3;
+      quadratic_prior_flag=1;
+                     }
+
+<DEFINE_PARAMETERS>normal_prior |
+<DEFINE_PARAMETERS>gaussian_prior {
+
+    BEGIN IN_NUMBER_DEF;
+    //BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  df_normal_prior_");
+    //needs_initialization=1;
+      quadratic_prior_flag=1;
+      quadratic_classprint_flag=2;
+      need_prior_globals=1;
+                     }
+
+<DEFINE_PARAMETERS>sparse_quadratic_prior {
+
+    BEGIN IN_NUMBER_DEF;
+    //BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  df_sparse_quadratic_prior_");
+    //needs_initialization=1;
+      quadratic_prior_flag=1;
+      quadratic_classprint_flag=4;
+      need_prior_globals=1;
+      sparse_quadprior_flag=1;
+      sparse_normal_flag=0;
+                     }
+
+<DEFINE_PARAMETERS>sparse_normal_prior {
+
+    BEGIN IN_NUMBER_DEF;
+    //BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  df_sparse_normal_prior_");
+    //needs_initialization=1;
+      quadratic_prior_flag=1;
+      quadratic_classprint_flag=4;
+      need_prior_globals=1;
+      sparse_quadprior_flag=1;
+      sparse_normal_flag=1;
+                     }
+
+
+<DEFINE_PARAMETERS>quadratic_prior {
+
+    BEGIN IN_NUMBER_DEF;
+    //BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  quadratic_prior ");
+    //needs_initialization=1;
+      quadratic_prior_flag=1;
+                     }
+
+<DEFINE_PARAMETERS>sdreport_vector {
+
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  param_stddev_vector ");
+                     }
+
+<DEFINE_PARAMETERS>matrix {
+
+    BEGIN IN_MATRIX_DEF;
+    fprintf(fdat,"%s","  param_matrix ");
+    needs_initialization=1;
+                     }
+
+
+<DEFINE_PARAMETERS>sdreport_matrix {
+
+    BEGIN IN_MATRIX_DEF;
+    fprintf(fdat,"%s","  param_stddev_matrix ");
+                     }
+
+<DEFINE_PARAMETERS>3darray {
+
+    BEGIN IN_THREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_3array ");
+    needs_initialization=1;
+                     }
+
+
+<DEFINE_PARAMETERS>4darray {
+
+    BEGIN IN_FOUR_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_4array ");
+    needs_initialization=1;
+                     }
+
+<DEFINE_PARAMETERS>5darray {
+
+    BEGIN IN_FIVE_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_5array ");
+    needs_initialization=1;
+                     }
+
+<DEFINE_PARAMETERS>6darray {
+
+    BEGIN IN_SIX_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_6array ");
+    needs_initialization=1;
+                     }
+
+<DEFINE_PARAMETERS>7darray {
+
+    BEGIN IN_SEVEN_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_7array ");
+    needs_initialization=1;
+                     }
+
+
+<DEFINE_PARAMETERS>SPinit_number {
+
+    check_random_effects_ordering();
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPparam_init_number ");
+                     }
+
+<DEFINE_PARAMETERS>SPinit_bounded_number {
+
+    check_random_effects_ordering();
+    talk_to_splus=1;
+    BEGIN INIT_BOUNDED_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPparam_init_bounded_number ");
+                     }
+
+<DEFINE_PARAMETERS>SPinit_vector {
+
+    check_random_effects_ordering();
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPparam_init_vector ");
+                     }
+
+
+<DEFINE_PARAMETERS>SPinit_bounded_vector {
+
+    check_random_effects_ordering();
+    talk_to_splus=1;
+    BEGIN INIT_BOUNDED_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPparam_init_bounded_vector ");
+                     }
+
+<DEFINE_PARAMETERS>SPinit_matrix {
+
+    check_random_effects_ordering();
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPparam_init_matrix ");
+                     }
+
+<DEFINE_PARAMETERS>SPinit_bounded_matrix {
+
+    check_random_effects_ordering();
+    talk_to_splus=1;
+    BEGIN INIT_BOUNDED_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPparam_init_bounded_matrix ");
+                     }
+
+<DEFINE_PARAMETERS>SPinit_3darray {
+
+    check_random_effects_ordering();
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPparam_init_3array ");
+                     }
+
+<DEFINE_PARAMETERS>SPinit_bounded_3darray {
+
+    check_random_effects_ordering();
+    talk_to_splus=1;
+    BEGIN INIT_BOUNDED_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPparam_init_bounded_d3array ");
+                     }
+
+
+<DEFINE_DATA>SPinit_number {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPdata_number ");
+                     }
+
+<DEFINE_DATA>SPinit_int {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPdata_int ");
+                     }
+
+<DEFINE_DATA>SPinit_vector {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPdata_vector ");
+                     }
+
+<DEFINE_DATA>SPinit_ivector {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPdata_ivector ");
+                     }
+
+<DEFINE_DATA>SPinit_matrix {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPdata_matrix ");
+                     }
+
+<DEFINE_DATA>SPinit_imatrix {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPdata_imatrix ");
+                     }
+
+<DEFINE_DATA>SPinit_3darray {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPdata_3array ");
+                     }
+
+<DEFINE_DATA>SPinit_4darray {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPdata_4array ");
+                     }
+<DEFINE_DATA>SPnumber {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPnamed_number ");
+                     }
+
+<DEFINE_DATA>SPint {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPnamed_int ");
+                     }
+
+<DEFINE_DATA>SPvector {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPnamed_dvector ");
+                     }
+
+<DEFINE_DATA>SPivector {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPnamed_ivector ");
+                     }
+
+<DEFINE_DATA>SPmatrix {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPnamed_dmatrix ");
+                     }
+
+
+<DEFINE_PARAMETERS>splus_init_number |
+<DEFINE_PARAMETERS>dll_init_number {
+    check_random_effects_ordering();
+    spnumber_flag=1;
+    BEGIN IN_SPNUMBER_DEF;
+    fprintf(fdat,"%s","  dll_param_init_number ");
+                     }
+
+
+
+<DEFINE_PARAMETERS>splus_init_bounded_number |
+<DEFINE_PARAMETERS>dll_init_bounded_number {
+    check_random_effects_ordering();
+    spnumber_flag=1;
+    BEGIN IN_SPBOUNDED_NUMBER_DEF;
+    fprintf(fdat,"%s","  dll_param_init_bounded_number ");
+                     }
+
+
+<DEFINE_PARAMETERS>splus_number |
+<DEFINE_PARAMETERS>dll_number {
+    check_random_effects_ordering();
+    spnumber_flag=1;
+    BEGIN IN_SPNUMBER_DEF;
+    fprintf(fdat,"%s","  dll_param_number ");
+                     }
+
+<DEFINE_PARAMETERS>init_number {
+    check_random_effects_ordering();
+
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  param_init_number ");
+                     }
+
+<DEFINE_PARAMETERS>init_number_vector {
+
+    check_random_effects_ordering();
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  param_init_number_vector ");
+                     }
+
+<DEFINE_PARAMETERS>init_bounded_number {
+    
+    check_random_effects_ordering();
+    BEGIN INIT_BOUNDED_NUMBER_DEF;
+    fprintf(fdat,"%s","  param_init_bounded_number ");
+                     }
+
+<DEFINE_PARAMETERS>init_bounded_number_vector {
+
+    check_random_effects_ordering();
+    BEGIN INIT_BOUNDED_VECTOR_DEF;
+    fprintf(fdat,"%s","  param_init_bounded_number_vector ");
+                     }
+
+<DEFINE_PARAMETERS>splus_init_vector |
+<DEFINE_PARAMETERS>dll_init_vector {
+
+    check_random_effects_ordering();
+    spnumber_flag=1;
+    BEGIN IN_SPVECTOR_DEF;
+    fprintf(fdat,"%s","  dll_param_init_vector ");
+                     }
+
+<DEFINE_PARAMETERS>splus_vector |
+<DEFINE_PARAMETERS>dll_vector {
+
+    check_random_effects_ordering();
+    spnumber_flag=1;
+    BEGIN IN_SPVECTOR_DEF;
+    fprintf(fdat,"%s","  dll_param_vector ");
+                     }
+
+<DEFINE_PARAMETERS>init_vector {
+
+    check_random_effects_ordering();
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  param_init_vector ");
+                     }
+
+<DEFINE_PARAMETERS>random_effects_vector {
+
+    random_effects_flag=1;
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  random_effects_vector ");
+                     }
+
+<DEFINE_PARAMETERS>dll_random_effects_vector {
+
+    spnumber_flag=1;
+    random_effects_flag=1;
+    BEGIN IN_SPVECTOR_DEF;
+    fprintf(fdat,"%s","  dll_param_vector ");
+                     }
+
+
+
+
+
+
+<DEFINE_PARAMETERS>random_effects_bounded_vector {
+
+    random_effects_flag=1;
+    BEGIN INIT_BOUNDED_VECTOR_DEF;
+    fprintf(fdat,"%s","  random_effects_bounded_vector ");
+                     }
+
+<DEFINE_PARAMETERS>init_vector_vector {
+
+    check_random_effects_ordering();
+    BEGIN IN_MATRIX_DEF;
+    fprintf(fdat,"%s","  param_init_vector_vector ");
+                     }
+
+<DEFINE_PARAMETERS>init_bounded_dev_vector {
+
+    check_random_effects_ordering();
+    BEGIN INIT_BOUNDED_VECTOR_DEF;
+    fprintf(fdat,"%s","  param_init_bounded_dev_vector ");
+                     }
+
+<DEFINE_PARAMETERS>init_bounded_vector {
+
+    check_random_effects_ordering();
+    BEGIN INIT_BOUNDED_VECTOR_DEF;
+    fprintf(fdat,"%s","  param_init_bounded_vector ");
+                     }
+
+<DEFINE_PARAMETERS>init_bounded_vector_vector {
+
+    check_random_effects_ordering();
+    BEGIN INIT_BOUNDED_MATRIX_DEF;
+    fprintf(fdat,"%s","  param_init_bounded_vector_vector ");
+                     }
+
+<DEFINE_PARAMETERS>splus_init_bounded_vector |
+<DEFINE_PARAMETERS>dll_init_bounded_vector {
+
+    check_random_effects_ordering();
+    spnumber_flag=1;
+    BEGIN INIT_SPBOUNDED_VECTOR_DEF;
+    fprintf(fdat,"%s","  dll_param_init_bounded_vector ");
+                     }
+
+<DEFINE_PARAMETERS>splus_matrix |
+<DEFINE_PARAMETERS>dll_matrix {
+
+    spnumber_flag=1;
+    BEGIN IN_SPMATRIX_DEF;
+    fprintf(fdat,"%s","  dll_param_matrix ");
+                     }
+
+<DEFINE_PARAMETERS>splus_init_matrix |
+<DEFINE_PARAMETERS>dll_init_matrix {
+
+    check_random_effects_ordering();
+    spnumber_flag=1;
+    BEGIN IN_SPMATRIX_DEF;
+    fprintf(fdat,"%s","  dll_param_init_matrix ");
+                     }
+
+<DEFINE_PARAMETERS>init_matrix {
+
+    check_random_effects_ordering();
+    BEGIN IN_MATRIX_DEF;
+    fprintf(fdat,"%s","  param_init_matrix ");
+                     }
+
+<DEFINE_PARAMETERS>random_effects_matrix {
+
+    random_effects_flag=1;
+    BEGIN IN_MATRIX_DEF;
+    fprintf(fdat,"%s","  random_effects_matrix ");
+                     }
+
+<DEFINE_PARAMETERS>random_effects_bounded_matrix {
+
+    random_effects_flag=1;
+    BEGIN INIT_BOUNDED_MATRIX_DEF;
+    fprintf(fdat,"%s","  random_effects_bounded_matrix ");
+                     }
+
+<DEFINE_PARAMETERS>init_matrix_vector {
+
+    check_random_effects_ordering();
+    BEGIN IN_THREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_init_matrix_vector ");
+                     }
+
+<DEFINE_PARAMETERS>init_bounded_matrix {
+
+    check_random_effects_ordering();
+    BEGIN INIT_BOUNDED_MATRIX_DEF;
+    fprintf(fdat,"%s","  param_init_bounded_matrix ");
+                     }
+
+<DEFINE_PARAMETERS>init_bounded_matrix_vector {
+
+    check_random_effects_ordering();
+    BEGIN INIT_BOUNDED_THREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_init_bounded_matrix_vector ");
+                     }
+
+<DEFINE_PARAMETERS>splus_init_3darray |
+<DEFINE_PARAMETERS>dll_init_3darray {
+
+    spnumber_flag=1;
+    BEGIN IN_SPTHREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  dll_param_init_d3array ");
+                     }
+
+<DEFINE_PARAMETERS>splus_3darray |
+<DEFINE_PARAMETERS>dll_3darray {
+
+    spnumber_flag=1;
+    BEGIN IN_SPTHREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  dll_param_d3array ");
+                     }
+
+<DEFINE_PARAMETERS>init_3darray {
+
+    check_random_effects_ordering();
+    BEGIN IN_THREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_init_d3array ");
+                     }
+
+<DEFINE_PARAMETERS>init_4darray {
+
+    check_random_effects_ordering();
+    BEGIN IN_FOUR_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_init_4array ");
+                     }
+
+<DEFINE_PARAMETERS>init_5darray {
+
+    check_random_effects_ordering();
+    BEGIN IN_FIVE_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_init_5array ");
+                     }
+
+<DEFINE_PARAMETERS>init_bounded_3darray {
+
+    check_random_effects_ordering();
+    BEGIN INIT_BOUNDED_THREE_ARRAY_DEF;
+    fprintf(fdat,"%s","  param_init_bounded_d3array ");
+                     }
+
+
+<DEFINE_PARAMETERS>SPnumber {
+
+    talk_to_splus=1;
+    BEGIN IN_NUMBER_DEF;
+    fprintf(fdat,"%s","  SPnamed_dvariable ");
+                     }
+
+<DEFINE_PARAMETERS>SPvector {
+
+    talk_to_splus=1;
+    BEGIN IN_VECTOR_DEF;
+    fprintf(fdat,"%s","  SPnamed_dvar_vector ");
+                     }
+
+<DEFINE_PARAMETERS>SPmatrix {
+
+    talk_to_splus=1;
+    BEGIN IN_MATRIX_DEF;
+    fprintf(fdat,"%s","  SPnamed_dvar_matrix ");
+                     }
+
+<IN_SPNUMBER_DEF>{name} {
+    num_spargs++;
+    if (spnumber_flag==1)
+    {
+      strcpy(name_string,"double *");
+    }  
+    else if (spnumber_flag==2)
+    {
+      strcpy(name_string,"char **");
+    }  
+    else
+    {
+      strcpy(name_string,"int *");
+    }  
+    spnumber_flag=0;
+    
+    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,yytext);
+    classlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(conlist_ptr,",%s(_%s)",yytext,yytext);
+    else
+      nchar=sprintf(conlist_ptr," %s(_%s)",yytext,yytext);
+    conlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist_ptr,",%s_%s",name_string,yytext);
+    else
+      nchar=sprintf(arglist_ptr,"%s_%s",name_string,yytext);
+    arglist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist1_ptr,",_%s",yytext);
+    else
+      nchar=sprintf(arglist1_ptr,"_%s",yytext);
+    arglist1_ptr+=nchar;
+    
+    fprintf(fdat,"%s",yytext);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"  %s",yytext);
+    fprintf(fall,".allocate(ad_dll.%s,\"%s\");\n",yytext,yytext);
+
+    if (needs_initialization)
+    {
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"  %s",yytext);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      printf("IN_SP_NUMBER_DEF %s\n",yytext);
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_SPNUMBER_DEF>({name}\({num_exp}\)) {
+
+    num_spargs++;
+    if (spnumber_flag==1)
+    {
+      strcpy(name_string,"double *");
+    }  
+    else if (spnumber_flag==2)
+    {
+      strcpy(name_string,"char **");
+    }  
+    else
+    {
+      strcpy(name_string,"int *");
+    }  
+    spnumber_flag=0;
+    
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
+    classlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
+    else
+      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
+    conlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
+    else
+      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
+    arglist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
+    else
+      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
+    arglist1_ptr+=nchar;
+    
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    marker();
+    fprintf(fall,"%s",".allocate(ad_dll.");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    strict_after_part(tmp_string3,tmp_string2,'(');  // get x in x(1,4)
+    fprintf(fall,"%s,%s,\"%s\")",tmp_string,tmp_string3,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+
+                            }
+
+
+<IN_NUMBER_DEF>{name} {
+
+    if (quadratic_classprint_flag)
+    {
+      fprintf(fdat,"%s ",yytext);
+     /*
+      fprintf(fdat,"public:\n  void evaluate_%s(void);\nprivate:\n",yytext);
+     */
+      print_quadratic_random_effect_penalty_class(yytext);
+    }
+    else
+    {
+      fprintf(fdat," ");
+    }
+
+    fprintf(fdat,"%s",yytext);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"  %s",yytext);
+    fprintf(fall,".allocate(\"%s\");",yytext);
+    if (in_objective_function_value_flag)
+    {
+      fprintf(fall,"  /* ADOBJECTIVEFUNCTION */");
+        in_objective_function_value_flag=0;
+    }
+    fprintf(fall,"\n");
+
+    if (needs_initialization)
+    {
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"  %s",yytext);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      //printf("IN_NUMBER_DEF %s\n",yytext);
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+<IN_NAMED_NUMBER_DEF>{name} {
+
+    fprintf(fdat,"%s",yytext);
+    fprintf(fdat,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NUMBER_DEF>({name}\({num_exp}\)) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    if (quadratic_classprint_flag)
+    {
+      fprintf(fdat,"%s ",tmp_string);
+      fprintf(fdat," ");
+      fprintf(fdat,"%s;\n",tmp_string);
+     /*
+      fprintf(fdat,"public:\n  void evaluate_%s(void);\nprivate:\n",tmp_string);
+     */
+      print_quadratic_random_effect_penalty_class(tmp_string);
+    }
+    else
+    {
+      fprintf(fdat," ");
+      fprintf(fdat,"%s;\n",tmp_string);
+    }
+
+
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    /*fprintf(fdat,"%s",";\n");*/
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+
+                            }
+
+
+<INIT_BOUNDED_NUMBER_DEF>({name}\({float_num_exp},{float_num_exp},{num_exp}\)) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+
+                            }
+
+
+
+<IN_SPBOUNDED_NUMBER_DEF>({name}\({float_num_exp},{float_num_exp},{num_exp}\)) |
+<IN_SPBOUNDED_NUMBER_DEF>({name}\({float_num_exp},{float_num_exp}\)) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    //fprintf(fall,"%s",".allocate");
+    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
+    
+
+    num_spargs++;
+    if (spnumber_flag==1)
+    {
+      strcpy(name_string,"double *");
+    }  
+    else if (spnumber_flag==2)
+    {
+      strcpy(name_string,"char **");
+    }  
+    else
+    {
+      strcpy(name_string,"int *");
+    }  
+    spnumber_flag=0;
+    
+    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
+    classlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
+    else
+      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
+    conlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
+    else
+      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
+    arglist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
+    else
+      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
+    arglist1_ptr+=nchar;
+    
+    
+    
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+
+                            }
+
+
+
+
+
+
+
+<INIT_BOUNDED_NUMBER_DEF>({name}\({float_num_exp},{float_num_exp}\)) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+
+                            }
+
+
+<IN_VECTOR_DEF>{name}\({num_exp},{num_exp}\) |
+<IN_VECTOR_DEF>{name}\({num_exp},{name}\) |
+<IN_VECTOR_DEF>{name}\({name},{num_exp}\) |
+<IN_VECTOR_DEF>{name}\({name},{name}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";");
+    if (quadratic_prior_flag)
+    {
+      fprintf(fdat,"   /* deleteXquadraticXprior */ ");
+      fprintf(fall,"   /* deleteXquadraticXprior */ ");
+      quadratic_prior_flag=0;
+    }
+    fprintf(fdat,"%s","\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_VECTOR_DEF>{name} {
+
+    strcpy(tmp_string,yytext);  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    //after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    //before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"(\"%s\")",tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      /*
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      */
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_VECTOR_DEF>{name}\({num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_SPVECTOR_DEF>{name}\({num_exp},{num_exp}\) |
+<IN_SPVECTOR_DEF>{name}\({num_exp},{num_exp},{num_exp}\) {
+
+    //fprintf(fall,".allocate(ad_dll.%s,\"%s\");\n",yytext,yytext);
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    //fprintf(fall,"%s",".allocate");
+    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
+    
+    
+// ****************************************************************
+
+    num_spargs++;
+    if (spnumber_flag==1)
+    {
+      strcpy(name_string,"double *");
+    }  
+    else if (spnumber_flag==2)
+    {
+      strcpy(name_string,"char **");
+    }  
+    else
+    {
+      strcpy(name_string,"int *");
+    }  
+    spnumber_flag=0;
+    
+    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
+    classlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
+    else
+      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
+    conlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
+    else
+      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
+    arglist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
+    else
+      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
+    arglist1_ptr+=nchar;
+    
+// ****************************************************************
+    
+    
+    
+    
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<INIT_SPBOUNDED_VECTOR_DEF>{name}\({num_exp},{num_exp},{float_num_exp},{float_num_exp}\) |
+<INIT_SPBOUNDED_VECTOR_DEF>{name}\({num_exp},{num_exp},{float_num_exp},{float_num_exp},{num_exp}\) {
+
+    //fprintf(fall,".allocate(ad_dll.%s,\"%s\");\n",yytext,yytext);
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    //fprintf(fall,"%s",".allocate");
+    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
+    
+    
+// ****************************************************************
+
+    num_spargs++;
+    if (spnumber_flag==1)
+    {
+      strcpy(name_string,"double *");
+    }  
+    else if (spnumber_flag==2)
+    {
+      strcpy(name_string,"char **");
+    }  
+    else
+    {
+      strcpy(name_string,"int *");
+    }  
+    spnumber_flag=0;
+    
+    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
+    classlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
+    else
+      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
+    conlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
+    else
+      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
+    arglist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
+    else
+      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
+    arglist1_ptr+=nchar;
+    
+// ****************************************************************
+    
+    
+    
+    
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+<IN_NAMED_VECTOR_DEF>{name}\({num_exp},{num_exp}\) |
+<IN_NAMED_VECTOR_DEF>{name}\({num_exp},{name}\) |
+<IN_NAMED_VECTOR_DEF>{name}\({name},{num_exp}\) |
+<IN_NAMED_VECTOR_DEF>{name}\({name},{name}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+<IN_NAMED_VECTOR_DEF>{name} {
+
+    if (warn_unallocated) write_unallocated("vector()");
+    strcpy(tmp_string,yytext);  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate()");
+    //fprintf(fall,"(\"%s\")",tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+<INIT_BOUNDED_VECTOR_DEF>{name}\({num_exp},{num_exp},{float_num_exp},{float_num_exp}\)    {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+<INIT_BOUNDED_VECTOR_DEF>{name}\({num_exp},{num_exp},{float_num_exp},{float_num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) |
+<IN_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_MATRIX_DEF>{name}\({num_exp},{num_exp}\) {
+
+    if (warn_unallocated) write_unallocated("matrix(ix,iy)");
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      /*
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      */
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_MATRIX_DEF>{name} {
+
+    if (warn_unallocated) write_unallocated("matrix()");
+    strcpy(tmp_string,yytext);  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    fprintf(fall,"(\"%s\")",tmp_string);
+    //before_part(tmp_string2,tmp_string1,')');
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      /*
+      XXXX
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+      */
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+<IN_TABLE_DEF>{name}\({filename}\) {
+
+    before_part(tmp_string,yytext,'(');  // get A in A("mat.tab")
+ 
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fdat,"%s",";\n");
+ 
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,".allocate(0,-1,0,-1,\"%s\");\n",tmp_string);
+    after_part(tmp_string1,yytext,'\"');
+    fprintf(fall,"  dmatrix %s_tmp((adstring)%s;\n",tmp_string,tmp_string1);
+    fprintf(fall,"  %s = %s_tmp;\n",tmp_string,tmp_string);
+    if (needs_initialization)
+    {
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_TABLE_DEF>{name}\({filenamesingle}\) {
+    fprintf(stderr,"%s %d %s","Error in line",nline,"while reading (use double instead of single quotes)\n");
+    exit(1);
+                            }
+
+<IN_TABLE_DEF>{name} {
+    fprintf(fdat,"%s",yytext);
+    fprintf(fdat,"%s",";\n");
+ 
+    fprintf(fall,"  %s",yytext);
+    fprintf(fall,".allocate(0,-1,0,-1,\"%s\");\n",yytext);
+    fprintf(fall,"  adstring datname;\n");
+    fprintf(fall,"  if(option_match(argc,argv,\"-ind\") > -1){ \n");
+    fprintf(fall,"    datname = argv[option_match(argc,argv,\"-ind\") + 1];\n");
+    fprintf(fall,"  }else{\n");
+    fprintf(fall,"    datname = \"%s.dat\";\n",infile_root);
+    fprintf(fall,"  }\n");
+    fprintf(fall,"  dmatrix %s_tmp(datname);\n",yytext);
+    fprintf(fall,"  %s = %s_tmp;\n",yytext,yytext);
+
+    if (needs_initialization)
+    {
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+<IN_TABLE_DEF>{name}\({name}\) {
+    before_part(tmp_string,yytext,'(');  // get A in A(str1)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fdat,"%s",";\n");
+ 
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,".allocate(0,-1,0,-1,\"%s\");\n",tmp_string);
+
+    strict_after_part(tmp_string1, yytext,'(');
+    fprintf(fall,"  dmatrix %s_tmp((adstring)%s;\n",tmp_string,tmp_string1);
+    fprintf(fall,"  %s = %s_tmp;\n",tmp_string,tmp_string);
+    if (needs_initialization)
+    {
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+
+
+<IN_SPMATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) |
+<IN_SPMATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    //fprintf(fall,"%s",".allocate");
+    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+// ****************************************************************
+
+    num_spargs++;
+    if (spnumber_flag==1)
+    {
+      strcpy(name_string,"double *");
+    }  
+    else if (spnumber_flag==2)
+    {
+      strcpy(name_string,"char **");
+    }  
+    else
+    {
+      strcpy(name_string,"int *");
+    }  
+    spnumber_flag=0;
+    
+    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
+    classlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
+    else
+      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
+    conlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
+    else
+      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
+    arglist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
+    else
+      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
+    arglist1_ptr+=nchar;
+    
+// ****************************************************************
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+<IN_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) |
+<IN_THREE_ARRAY_DEF>{name}\({index},{index},{index},{index},{index},{index},{index}\) |
+<IN_THREE_ARRAY_DEF>{name}\({index},{index},{index},{index},{index},{index}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) |
+<IN_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp}\) {
+
+    if (warn_unallocated) write_unallocated("3darray(ix,iy)");
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      /*
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      */
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_THREE_ARRAY_DEF>{name} {
+
+    if (warn_unallocated) write_unallocated("3darray()");
+    strcpy(tmp_string,yytext);  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    //after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    //before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"(\"%s\")",tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      /*
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      */
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_SPTHREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) |
+<IN_SPTHREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    //fprintf(fall,"%s",".allocate");
+    fprintf(fall,".allocate(ad_dll.%s,",tmp_string);
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2+1,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+// ****************************************************************
+
+    num_spargs++;
+    if (spnumber_flag==1)
+    {
+      strcpy(name_string,"double *");
+    }  
+    else if (spnumber_flag==2)
+    {
+      strcpy(name_string,"char **");
+    }  
+    else
+    {
+      strcpy(name_string,"int *");
+    }  
+    spnumber_flag=0;
+    
+    nchar=sprintf(classlist_ptr,"  %s%s;\n",name_string,tmp_string);
+    classlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(conlist_ptr,",%s(_%s)",tmp_string,tmp_string);
+    else
+      nchar=sprintf(conlist_ptr," %s(_%s)",tmp_string,tmp_string);
+    conlist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist_ptr,",%s_%s",name_string,tmp_string);
+    else
+      nchar=sprintf(arglist_ptr,"%s_%s",name_string,tmp_string);
+    arglist_ptr+=nchar;
+    
+    if (num_spargs>1)
+      nchar=sprintf(arglist1_ptr,",_%s",tmp_string);
+    else
+      nchar=sprintf(arglist1_ptr,"_%s",tmp_string);
+    arglist1_ptr+=nchar;
+    
+// ****************************************************************
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) |
+<IN_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) |
+<IN_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      /*
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      */
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_FOUR_ARRAY_DEF>{name} {
+
+    strcpy(tmp_string,yytext);  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    //after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    //before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"(\"%s\")",tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      /*
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      */
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_FIVE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_SIX_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_SEVEN_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (needs_initialization)
+    {
+      before_part(tmp_string,yytext,'('); 
+      fprintf(fall,"  #ifndef NO_AD_INITIALIZE\n");
+      fprintf(fall,"    %s",tmp_string);
+      fprintf(fall,".initialize();\n");
+      fprintf(fall,"  #endif\n");
+      needs_initialization=0;
+    }
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+
+<IN_NAMED_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_MATRIX_DEF>{name}\({num_exp},{num_exp}\) {
+    if (warn_unallocated) write_unallocated("matrix(i1,i2)");
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_MATRIX_DEF>{name} {
+    if (warn_unallocated) write_unallocated("matrix()");
+
+    strcpy(tmp_string,yytext);  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate()");
+    //after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    //before_part(tmp_string2,tmp_string1,')');
+    //fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<INIT_BOUNDED_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{float_num_exp},{float_num_exp}\)    {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+			    }
+
+
+<INIT_BOUNDED_MATRIX_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{float_num_exp},{float_num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<INIT_BOUNDED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{float_num_exp},{float_num_exp}\)    {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+			    }
+
+
+<INIT_BOUNDED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{float_num_exp},{float_num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s,\"%s\")",tmp_string2,tmp_string);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) |
+<IN_NAMED_THREE_ARRAY_DEF>{name}\({num_exp},{name},{num_exp},{num_exp},{num_exp},{num_exp}\) |
+<IN_NAMED_THREE_ARRAY_DEF>{name}\({index},{index},{index},{index},{index},{index}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp}\) {
+    if (warn_unallocated) write_unallocated("3darray(i1,i2,j1,j2)");
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_THREE_ARRAY_DEF>{name}\({num_exp},{num_exp}\) {
+    if (warn_unallocated) write_unallocated("3darray(i1,i2)");
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_THREE_ARRAY_DEF>{name} {
+    if (warn_unallocated) write_unallocated("3darray()");
+
+    strcpy(tmp_string,yytext);  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_FOUR_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_FIVE_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_SIX_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+<IN_NAMED_SEVEN_ARRAY_DEF>{name}\({num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp},{num_exp}\) {
+
+    before_part(tmp_string,yytext,'(');  // get x in x(1,4)
+    fprintf(fdat,"%s",tmp_string);
+    fprintf(fall,"  %s",tmp_string);
+    fprintf(fall,"%s",".allocate");
+    after_part(tmp_string1,yytext,'(');  // get x in x(1,4)
+    before_part(tmp_string2,tmp_string1,')');
+    fprintf(fall,"%s)",tmp_string2);
+    fprintf(fdat,"%s",";\n");
+    fprintf(fall,"%s",";\n");
+    if (!params_defined)
+    {
+      BEGIN DEFINE_DATA;
+    }
+    else
+    {
+      BEGIN DEFINE_PARAMETERS;
+    }
+                            }
+
+
+
+.  {
+  fprintf(stderr,"%s %d %s","Error in line",nline,"while reading\n");
+  fprintf(stderr,"%s\n",yytext);
+  exit(1);
+     }
+
+PARAMETER_SECTION {
+    if (!data_defined)
+    {
+      fprintf(stderr,"Error DATA_SECTION must be defined before"
+        " PARAMETER SECTION\n");
+      exit(1);
+    }
+    BEGIN DEFINE_PARAMETERS;
+    in_define_data=0;
+    in_define_parameters=1;
+    params_defined=1;
+
+    fprintf(fdat,"  ~model_data();\n");
+    if (makedll)
+      fprintf(fdat,"  model_data(int argc,char * argv[],dll_args&);\n  friend class model_parameters;\n");
+    else  
+      fprintf(fdat,"  model_data(int argc,char * argv[]);\n  friend class model_parameters;\n");
+    fprintf(fdat,"%s","};\n\nclass model_parameters : "
+      "public model_data ,"
+      "\n  public function_minimizer\n{\n");
+    
+    fprintf(fdat,"%s","public:\n");
+
+    fprintf(fdat,"  static model_parameters * model_parameters_ptr;\n"
+      "  static model_parameters * get_model_parameters_ptr(void)\n"
+      "  {\n"
+      "    return model_parameters_ptr;\n"
+      "  }\n");
+
+    fprintf(fdat,"  ~model_parameters();\n");
+//    fprintf(fdat,"%s","  void admaster_slave_variable_interface(void);\n");
+    fprintf(fdat,"%s","  void preliminary_calculations(void);\n");
+    fprintf(fdat,"%s","  void set_runtime(void);\n");
+    fprintf(fdat,"%s","  virtual void * mycast(void) {return (void*)this;}\n");
+
+    fprintf(fdat,"%s", "  static int mc_phase(void)\n"
+      "  {\n    return initial_params::mc_phase;\n  }\n");
+      
+    fprintf(fdat,"%s", "  static int mceval_phase(void)\n"
+      "  {\n    return initial_params::mceval_phase;\n  }\n");
+      
+    fprintf(fdat,"%s", "  static int sd_phase(void)\n"
+      "  {\n    return initial_params::sd_phase;\n  }\n");
+ 
+   fprintf(fdat,"%s", "  static int current_phase(void)\n"
+      "  {\n    return initial_params::current_phase;\n  }\n");
+    fprintf(fdat,"%s", "  static int last_phase(void)\n"
+      "  {\n    return (initial_params::current_phase\n"
+      "      >=initial_params::max_number_phases);\n  }\n");
+
+   /*
+    if (random_effects_flag)
+    {
+
+      fprintf(fdat,"%s", "  void AD_uf_inner(const dvector& x,"
+        "const dvar_vector& u);\n"
+        "  void AD_uf_outer(const dvar_vector& x,"
+        "const dvar_vector& u);\n");
+    }
+    */
+
+    fprintf(fdat,"%s","private:\n");
+    fprintf(fdat,"%s", "  ivector integer_control_flags;\n");
+    fprintf(fdat,"%s", "  void begin_df1b2_funnel(void);\n");
+    fprintf(fdat,"%s", "  void end_df1b2_funnel(void);\n");
+  
+    fprintf(fdat,"%s", "  dvector double_control_flags;\n");
+    fclose(fdat);
+    fdat=fopen("tfile2","w+");
+    if (fdat==NULL)
+    {
+      fprintf(stderr,"Error trying to open file tfile2\n");
+    }
+    
+    if (makedll)
+    {
+      fprintf(fall,"%s","}\n\nmodel_parameters::model_parameters"
+        "(int sz,int argc,char * argv[], dll_args& ad_dll) : "
+        "\n model_data(argc,argv,ad_dll) , function_minimizer(sz)\n{\n");
+  //        "\n ad_comm(argc,argv), model_data(ad_dll) , function_minimizer(sz)\n{\n");
+    }
+    else	
+    {
+      fprintf(fall,"%s","}\n\nmodel_parameters::model_parameters"
+        "(int sz,int argc,char * argv[]) : "
+        "\n model_data(argc,argv) , function_minimizer(sz)\n{\n");
+    }
+    fprintf(fall,"%s", "  model_parameters_ptr=this;\n");
+    fprintf(fall,"%s", "  initializationfunction();\n");
+    fclose(fall);
+    fall=fopen("xxalloc2.tmp","w+");
+    if (fall==NULL)
+    {
+      fprintf(stderr,"%s","Error trying to open file xxalloc2.tmp\n");
+    }
+
+                  }
+
+PROCEDURE_SECTION {
+
+    /* int i; */
+
+    if (!data_defined)
+    {
+      fprintf(stderr,"Error -- DATA_SECTION must be defined before"
+        " PROCEDURE SECTION\n OR PARAMETER SECTION\n");
+      exit(1);
+    }
+    if (!params_defined)
+    {
+      fprintf(stderr,"Error -- PARAMETER_SECTION must be defined before"
+        " PROCEDURE SECTION\n");
+      exit(1);
+    }
+    if (!objective_function_defined)
+    {
+      fprintf(stderr,"Error -- You must define an object of type objective"
+        "_function_value in the\nPARAMETER SECTION"
+        "and assign the approriate value to it in the\nPROCEDURE_SECTION");
+      exit(1);
+    }
+    BEGIN DEFINE_PROCS;
+    procedure_defined=1;
+    in_procedure_def=1;
+    in_define_parameters=0;
+
+    fclose(fdat);
+    fdat=fopen("tfile3","w+");
+    if (fdat==NULL)
+    {
+      fprintf(stderr,"Error trying to open file tfile3\n");
+    }
+
+    if (makedll)
+    {
+      fprintf(fdat,"public:\n  virtual void userfunction(void);\n"
+        "  virtual void report(void);\n" // define this to get a report
+        "  virtual void final_calcs(void);\n" 
+        "  model_parameters(int sz,int argc, char * argv[],"
+        " dll_args& ad_dll);\n");
+    }
+    else	
+    {
+      fprintf(fdat,"public:\n  virtual void userfunction(void);\n"
+        "  virtual void report(void);\n" // define this to get a report
+        "  virtual void final_calcs(void);\n" 
+        "  model_parameters(int sz,int argc, char * argv[]);\n");
+    }
+    if(!initialization_defined)
+    {
+      fprintf(fdat,"  virtual void initializationfunction(void){}\n");
+    }
+    else
+    {
+      fprintf(fdat,"  virtual void initializationfunction(void);\n");
+    }
+
+    if (random_effects_flag)
+    {
+
+      fprintf(fdat,"%s", "  virtual void AD_uf_inner(void){pre_userfunction();}\n"
+        "  virtual void AD_uf_outer(void){pre_userfunction();}\n"
+        /*"  virtual void user_function(const init_df1b2vector& x,"
+        "df1b2variable& f){;}\n" */
+        "  virtual void user_function(void){;}\n"
+        "  virtual void allocate(void){;}\n");
+    }
+    fclose(fdat);
+    fdat=fopen("tfile4","w+");
+    if (fdat==NULL)
+    {
+      fprintf(stderr,"Error trying to open file tfile\n");
+    }
+
+   /* fprintf(fdat,"%s","};\n");*/
+    fprintf(fall,"%s","}\n");
+    fclose(fall);
+    fall=fopen("xxalloc3.tmp","w+");
+    if (fall==NULL)
+    {
+      fprintf(stderr,"%s","Error trying to open file xxalloc3.tmp\n");
+    }
+    fprintf(fall,"%s","void model_parameters::userfunction(void)"
+      "\n{\n");
+    add_references_to_user_classes(fall);  
+                  }
+
+FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
+    if (!in_procedure_def)
+    {
+      fprintf(stderr,"Error -- FUNCTION must be used within the"
+        " PROCEDURE SECTION\n");
+      exit(1);
+    }
+
+    after_part(tmp_string1,yytext,' ');  // get function name
+    strip_leading_blanks(tmp_string2,tmp_string1); 
+    before_part(tmp_string3,tmp_string2,' '); 
+    after_part(tmp_string4,tmp_string2,' ');  // get function name
+    strip_leading_blanks(tmp_string1,tmp_string4); 
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"}\n\n%s ",tmp_string3);
+    fprintf(fall,"model_parameters::%s\n{\n",tmp_string1);
+    fprintf(fdat," %s %s;\n",tmp_string3,tmp_string1);
+    add_references_to_user_classes(fall); 
+    in_aux_proc=1;
+    BEGIN DEFINE_PROCS;
+                              }
+
+
+
+SEPARABLE_FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
+    if (!in_procedure_def)
+    {
+      fprintf(stderr,"Error -- SEPARABLE_FUNCTION must be used within the"
+        " PROCEDURE SECTION\n");
+      exit(1);
+    }
+
+    after_part(tmp_string1,yytext,' ');  // get function name
+    strip_leading_blanks(tmp_string2,tmp_string1); 
+    before_part(tmp_string3,tmp_string2,' '); 
+    after_part(tmp_string4,tmp_string2,' ');  // get function name
+    strip_leading_blanks(tmp_string1,tmp_string4); 
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"}\n\n%s SEPFUN1  ",tmp_string3);
+    fprintf(fall,"model_parameters::%s\n{\n  "
+      "begin_df1b2_funnel();\n" ,tmp_string1);
+    fprintf(fdat,"SEPFUN3 %s %s;\n",tmp_string3,tmp_string1);
+    add_references_to_user_classes(fall); 
+    in_aux_proc=1;
+    in_funnel_proc=1;
+    have_separable_function=1;
+    BEGIN DEFINE_PROCS;
+                              }
+
+
+NESTED_FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
+    if (!in_procedure_def)
+    {
+      fprintf(stderr,"Error -- NESTED_SEPARABLE_FUNCTION must be used"
+        " within the PROCEDURE SECTION\n");
+      exit(1);
+    }
+
+    printf(" %s \n",yytext);
+    after_part(tmp_string1,yytext,' ');  // get function name
+    strip_leading_blanks(tmp_string2,tmp_string1); 
+    before_part(tmp_string3,tmp_string2,' '); 
+    after_part(tmp_string4,tmp_string2,' ');  // get function name
+    strip_leading_blanks(tmp_string1,tmp_string4); 
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"}\n\n%s SEPFUN4  ",tmp_string3);
+    fprintf(fall,"model_parameters::%s\n{\n  "
+      "lapprox->begin_separable_call_stuff();\n" ,tmp_string1);
+  
+    //fprintf(fall,"model_parameters::%s\n{\n  ",tmp_string1);
+    //fprintf(fdat,"SEPFUN3 %s %s;\n",tmp_string3,tmp_string1);
+    fprintf(fdat,"SEPFUN4 %s %s;\n",tmp_string3,tmp_string1);
+    //fprintf(fall," PPPPPP\n");
+    write_getindex_stuff(tmp_string1);
+    add_references_to_user_classes(fall); 
+    in_aux_proc=1;
+    in_funnel_proc=2;
+    have_separable_function=1;
+    BEGIN DEFINE_PROCS;
+                              }
+
+
+QUADRATIC_PENALTY_FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
+    if (!in_procedure_def)
+    {
+      fprintf(stderr,"Error -- FUNCTION must be used within the"
+        " PROCEDURE SECTION\n");
+      exit(1);
+    }
+    //---  parsing the function header to get parameter names 
+    strict_after_part(tmp_string1,yytext,'(');  
+    before_part(tmp_string2,tmp_string1,')'); 
+      
+    char * pch;
+    pch = strtok (tmp_string2,",");
+    FILE * tempf_sed;
+    tempf_sed=fopen("_tempfnpsed","w+");
+    while (pch != NULL)
+    {
+      after_partb(tmp_string3,pch,' ');  
+      fprintf(tempf_sed,
+        "s/\\([^a-zA-Z0-9]\\)%s\\([^a-zA-Z0-9]\\)/\\1value(%s)\\2/g\n",
+        tmp_string3,tmp_string3);
+      fprintf(tempf_sed,"s/^%s\\([^a-zA-Z0-9]\\)/value(%s)\\1/g\n",
+        tmp_string3,tmp_string3);
+      fprintf(tempf_sed,"s/\\([^a-zA-Z0-9]\\)%s$/\\1value(%s)/g\n",
+        tmp_string3,tmp_string3);
+      pch = strtok (NULL, ",");
+    }
+    fclose(tempf_sed);
+    //--
+    tempf_NP=fopen("tempfnp","w+");
+    if (tempf_NP==NULL)
+    {
+      fprintf(stderr,"%s","Error trying to open file tempfnp\n");
+    }
+    after_part(tmp_string1,yytext,' ');  // get function name
+    strip_leading_blanks(tmp_string2,tmp_string1); 
+    before_part(tmp_string3,tmp_string2,' '); 
+    after_part(tmp_string4,tmp_string2,' ');  // get function name
+    strip_leading_blanks(tmp_string1,tmp_string4);     
+    write_end_normal_prior();
+    write_funnel_end();  
+    fprintf(fall,"}\n\n%s SEPFUN1  ",tmp_string3);
+    fprintf(fall,"model_parameters::%s\n{\n  "
+      "begin_df1b2_funnel();\n" ,tmp_string1);
+    fprintf(fall,"  if (inner_opt_flag==0)\n  {\n");
+    
+    fprintf(fdat,"SEPFUN3 %s %s;\n",tmp_string3,tmp_string1);
+
+
+    add_references_to_user_classes(fall); 
+    in_aux_proc=1;
+    in_funnel_proc=1;
+    //have_separable_function=1;
+    in_normal_prior_flag=1;
+    in_normal_prior=1;
+    BEGIN DEFINE_PROCS_NP;
+                              }
+NORMAL_PRIOR_FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
+    if (!in_procedure_def)
+    {
+      fprintf(stderr,"Error -- FUNCTION must be used within the"
+        " PROCEDURE SECTION\n");
+      exit(1);
+    }
+    //---  parsing the function header to get parameter names 
+    strict_after_part(tmp_string1,yytext,'(');  
+    before_part(tmp_string2,tmp_string1,')'); 
+      
+    char * pch;
+    pch = strtok (tmp_string2,",");
+    FILE * tempf_sed;
+    tempf_sed=fopen("_tempfnpsed","w+");
+    while (pch != NULL)
+    {
+      after_partb(tmp_string3,pch,' ');  
+      fprintf(tempf_sed,
+        "s/\\([^a-zA-Z0-9]\\)%s\\([^a-zA-Z0-9]\\)/\\1value(%s)\\2/g\n",
+        tmp_string3,tmp_string3);
+      fprintf(tempf_sed,"s/^%s\\([^a-zA-Z0-9]\\)/value(%s)\\1/g\n",
+        tmp_string3,tmp_string3);
+      fprintf(tempf_sed,"s/\\([^a-zA-Z0-9]\\)%s$/\\1value(%s)/g\n",
+        tmp_string3,tmp_string3);
+      pch = strtok (NULL, ",");
+    }
+    fclose(tempf_sed);
+    //--
+    tempf_NP=fopen("tempfnp","w+");
+    if (tempf_NP==NULL)
+    {
+      fprintf(stderr,"%s","Error trying to open file tempfnp\n");
+    }
+    after_part(tmp_string1,yytext,' ');  // get function name
+    strip_leading_blanks(tmp_string2,tmp_string1); 
+    before_part(tmp_string3,tmp_string2,' '); 
+    after_part(tmp_string4,tmp_string2,' ');  // get function name
+    strip_leading_blanks(tmp_string1,tmp_string4);     
+    write_end_normal_prior();
+    write_funnel_end();  
+    fprintf(fall,"}\n\n%s SEPFUN1  ",tmp_string3);
+    fprintf(fall,"model_parameters::%s\n{\n  "
+      "begin_df1b2_funnel();\n" ,tmp_string1);
+    fprintf(fall,"  if (inner_opt_flag==0)\n  {\n");
+    
+    fprintf(fdat,"SEPFUN3 %s %s;\n",tmp_string3,tmp_string1);
+
+
+    add_references_to_user_classes(fall); 
+    in_aux_proc=1;
+    in_funnel_proc=1;
+    //have_separable_function=1;
+    in_normal_prior_flag=1;
+    normal_prior_flag2=1;
+    in_normal_prior=1;
+    BEGIN DEFINE_PROCS_NP;
+                              }
+
+QUADPRIOR_FUNCTION[ ]*{name}[ ]*{name}\(.*\) {
+    if (!in_procedure_def)
+    {
+      fprintf(stderr,"Error -- FUNCTION must be used within the"
+        " PROCEDURE SECTION\n");
+      exit(1);
+    }
+
+    after_part(tmp_string1,yytext,' ');  // get function name
+    strip_leading_blanks(tmp_string2,tmp_string1); 
+    before_part(tmp_string3,tmp_string2,' '); 
+    after_part(tmp_string4,tmp_string2,' ');  // get function name
+    strip_leading_blanks(tmp_string1,tmp_string4); 
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"}\n\n%s SEPFUN1  ",tmp_string3);
+    fprintf(fall,"model_parameters::%s\n{\n"
+      "  setup_quadprior_calcs();\n"
+      "  begin_df1b2_funnel();\n" ,tmp_string1);
+    fprintf(fdat,"SEPFUN3 %s %s;\n",tmp_string3,tmp_string1);
+    add_references_to_user_classes(fall); 
+    in_aux_proc=1;
+    in_funnel_proc=1;
+    have_separable_function=1;
+    BEGIN DEFINE_PROCS;
+                              }
+
+
+FUNCTION[ ]*{name} {
+    if (!in_procedure_def)
+    {
+      fprintf(stderr,"Error -- FUNCTION must be used within the"
+        " PROCEDURE SECTION\n");
+      exit(1);
+    }
+
+    after_partb(tmp_string1,yytext,' ');  // get function name
+    write_end_normal_prior();
+    write_funnel_end();
+    fprintf(fall,"}\n\nvoid model_parameters::%s(void)\n{\n",tmp_string1);
+    fprintf(fdat,"  void %s(void);\n",tmp_string1);
+    
+    add_references_to_user_classes(fall); 
+    
+    in_aux_proc=1;
+    BEGIN DEFINE_PROCS;
+   /*  BEGIN DEFINE_AUX_PROC; */
+                              }
+
+FUNCTION_DECLARATION[ ]*{name}[ ]*{name}\(.*\) |
+[ ]FUNCTION_DECLARATION[ ]*{name}[ ]*{name}\(.*\) {
+    if (!in_procedure_def)
+    {
+      fprintf(stderr,"Error -- FUNCTION_DECLARATION  must be used within the"
+        " PROCEDURE SECTION\n");
+      exit(1);
+    }
+
+    after_part(tmp_string1,yytext,' ');  // get function name
+    strip_leading_blanks(tmp_string2,tmp_string1); 
+    before_part(tmp_string3,tmp_string2,' '); 
+    after_part(tmp_string4,tmp_string2,' ');  // get function name
+    strip_leading_blanks(tmp_string1,tmp_string4); 
+    //fprintf(fall,"}\n\n%s ",tmp_string3);
+    //fprintf(fall,"model_parameters::%s\n{\n",tmp_string1);
+    fprintf(fdat," %s %s;\n",tmp_string3,tmp_string1);
+    add_references_to_user_classes(fall); 
+    in_aux_proc=1;
+    BEGIN DEFINE_PROCS;
+                              }
+
+
+FUNCTION_DECLARATION[ ]*{name} |
+[ ]FUNCTION_DECLARATION[ ]*{name} {
+    if (!in_procedure_def)
+    {
+      fprintf(stderr,"Error -- FUNCTION_DECLARATION must be used within the"
+        " PROCEDURE SECTION\n");
+      exit(1);
+    }
+
+    after_partb(tmp_string1,yytext,' ');  // get function name
+    //fprintf(fall,"}\n\nvoid model_parameters::%s(void)\n{\n",tmp_string1);
+    fprintf(fdat,"  void %s(void);\n",tmp_string1);
+    
+    add_references_to_user_classes(fall); 
+    
+    in_aux_proc=1;
+    BEGIN DEFINE_PROCS;
+   /*  BEGIN DEFINE_AUX_PROC; */
+                              }
+
+
+<DEFINE_PROCS>^[ \t].*$ { 
+   fprintf(fall,"%s\n",yytext); 
+           }
+
+<DEFINE_PROCS_NP>^[ \t].*$ { 
+   fprintf(fall,"    %s\n",yytext); 
+   fprintf(tempf_NP,"  %s\n",yytext); 
+           }
+
+
+<DEFINE_AUX_PROC>^\ +{name}\ +{name}\(.*$       {
+
+   fprintf(fall,"  %s\n",yytext);
+   num_paren=count_paren(num_paren,yytext); 
+   printf("in define_aux_procs num_paren = %d\n",num_paren);
+   if (num_paren==0)
+   {
+     fprintf(fhead,"%s;\n\n",yytext);
+     BEGIN DEFINE_PROCS;
+   }
+   else
+   {
+     fprintf(fhead,"%s\n",yytext);
+     BEGIN CONTINUE_PROTOTYPE_DEF;
+   }  
+                              }
+
+
+<CONTINUE_PROTOTYPE_DEF>^\ .*$       {
+
+   fprintf(fall,"  %s\n",yytext);
+   num_paren=count_paren(num_paren,yytext); 
+   printf("in continue_prorotoype_def num_paren = %d\n",num_paren);
+   if (num_paren==0)
+   {
+     fprintf(fhead,"%s;\n\n",yytext);
+     BEGIN DEFINE_PROCS;
+   }
+   else
+   {
+     fprintf(fhead,"%s\n",yytext);
+   }  
+                              }
+
+
+GLOBALS_SECTION {
+  
+    if (globals_section_defined) {
+      fprintf(stderr,"Error -- there is more than 1 GLOBALS_SECTION\n");
+      exit(1);
+    }
+    globals_section_defined=1;
+    BEGIN IN_GLOBALS_SECTION;
+    /*fglobals=fopen("xxglobal.tmp","w+");*/
+    if (fglobals==NULL)
+    {
+      fprintf(stderr,"%s","Error trying to open file xxglobal.tmp\n");
+    }
+
+                }
+
+<IN_GLOBALS_SECTION>^[ \t].*$ { 
+
+        fprintf(fglobals,"%s\n",yytext);
+
+                              }
+
+TOP_OF_MAIN_SECTION {
+  
+    *arglist_ptr='\0';
+    if (top_of_main_defined) {
+      fprintf(stderr,"Error -- there is more than 1 TOP_OF_MAIN_SECTION\n");
+      exit(1);
+    }
+    top_of_main_defined=1;
+    BEGIN IN_TOP_SECTION;
+    ftopmain=fopen("xxtopm.tmp","w+");
+    if (ftopmain==NULL)
+    {
+      fprintf(stderr,"%s","Error trying to open file xxtopmn.tmp\n");
+      exit(1);
+    }
+    if (need_prior_globals==1)
+    {
+      //fprintf(ftopmain,"  df1b2_parameters * df1b2_parameters::df1b2_parameters_ptr=0;\n");
+      //fprintf(ftopmain,"  model_parameters * model_parameters::model_parameters_ptr=0;\n");
+      need_prior_globals=0;
+    }
+    fprintf(ftopmain,"  long int arrmblsize=0;\n");
+    if (makedll) fprintf(ftopmain,"extern \"C\" {\n");
+    if (splus_debug_flag)
+    {
+      if (!makegaussdll)
+        fprintf(ftopmain,"\nvoid ");
+      else
+        fprintf(ftopmain,"\nint ");
+
+      fprintf(ftopmain,"%s",infile_root);
+      if (!makegaussdll)
+        fprintf(ftopmain,"(%s,char ** dll_options);\n\n",arglist);
+      else
+        fprintf(ftopmain,"(%s,char * dll_options);\n\n",arglist);
+      
+      fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
+      fprintf(ftopmain,"  %s",infile_root);
+      fprintf(ftopmain,"    ad_set_new_handler();\n");
+      if (bound_flag) fprintf(ftopmain,"    ad_exit=&ad_boundf;\n");
+      fprintf(ftopmain,"(%s,dll_options);\n}\n",arglist1);
+    }   
+    if (!splus_debug_flag)
+    {
+      if (makedll)
+      {
+        fprintf(ftopmain,"\n#if !defined(__MSVC32__)"
+           "\n#  define __declspec(x)"
+           "\n#endif\n");
+
+        fprintf(ftopmain,"\n#if !defined(__BORLANDC__)"
+           "\n#  define _export"
+           "\n#else"
+           "\n#  define _export __stdcall"
+           "\n#endif\n");
+        if (!makegaussdll)
+          fprintf(ftopmain,"\n__declspec(dllexport) void _export ");
+        else
+          fprintf(ftopmain,"\n__declspec(dllexport) int _export ");
+      }
+      else
+      {	
+        fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
+        fprintf(ftopmain,"  ad_set_new_handler();\n");
+        if (bound_flag) fprintf(ftopmain,"  ad_exit=&ad_boundf;\n");
+      }	
+    }	
+    else
+    {
+      fprintf(ftopmain,"\nvoid ");
+    }	
+    if (makedll)
+    {
+      fprintf(ftopmain,"%s",infile_root);
+      if (num_spargs)
+      {
+        if (!makegaussdll)
+          fprintf(ftopmain,"(%s,char ** dll_options)\n{\n",arglist);
+        else
+          fprintf(ftopmain,"(%s,char * dll_options)\n{\n",arglist);
+      }
+      else  
+      {
+        if (!makegaussdll)
+          fprintf(ftopmain,"(%schar ** dll_options)\n{\n",arglist);
+        else
+          fprintf(ftopmain,"(%schar * dll_options)\n{\n",arglist);
+      }
+    }	
+
+                }
+
+<IN_TOP_SECTION>^[ \t].*$ { 
+
+        fprintf(ftopmain,"%s\n",yytext);
+
+                              }
+
+
+<<EOF>>           {
+
+    if (!data_defined)
+    {
+      fprintf(stderr,"Error -- Reached end-of-file without the DATA_SECTION"
+        " being defined\n");
+      exit(1);
+    }
+    if (!params_defined)
+    {
+      fprintf(stderr,"Error -- Reached end-of-file without the PARAMETER_SECTION"
+        " being defined\n");
+      exit(1);
+    }
+    if (!procedure_defined)
+    {
+      fprintf(stderr,"Error -- Reached end-of-file without the"
+        " PROCEDURE_SECTION being defined\n");
+      exit(1);
+    }
+    write_end_normal_prior();
+    write_funnel_end();
+    //if (!in_aux_proc)
+    //if (in_aux_proc)
+    {
+     // fprintf(fall,"}\n");
+    }
+
+    fprintf(fall,"}\n");
+    fclose(fall);
+    fall=fopen("xxalloc6.tmp","w+");
+    if (fall==NULL)
+    {
+      fprintf(stderr,"%s","Error trying to open file xxalloc6.tmp\n");
+    }
+    if (!preliminary_calcs_defined)
+    {
+      fprintf(fall,"\nvoid model_parameters::preliminary_calculations(void)"
+        "{");
+      fprintf(fall,"%s","\n  admaster_slave_variable_interface(*this);\n  }\n");
+    }
+
+    fprintf(fall,"\nmodel_data::~model_data()\n"
+      "{");
+    fprintf(fall,"}\n");
+    fprintf(fall,"\nmodel_parameters::~model_parameters()\n"
+      "{");
+    call_destructors_for_user_classes(fall); 
+
+    if (!report_defined)
+    {
+      fprintf(fall,"}\n");
+      fprintf(fall,"\nvoid model_parameters::report(void)"
+        "{");
+    }
+
+    if (!final_defined)
+    {
+      fprintf(fall,"}\n");
+      fprintf(fall,"\nvoid model_parameters::final_calcs(void)"
+        "{");
+    }
+
+    if (!runtime_defined)
+    {
+      fprintf(fall,"}\n");
+      fprintf(fall,"%s","\nvoid model_parameters::set_runtime(void)"
+        "{");
+    }
+
+    fprintf(fall,"}\n");
+    fprintf(fall,"\n#ifdef _BORLANDC_\n"
+                 "  extern unsigned _stklen=10000U;\n#endif\n\n");
+    fprintf(fall,"\n#ifdef __ZTC__\n"
+                 "  extern unsigned int _stack=10000U;\n#endif\n\n");
+    fprintf(fall,"\n#define __DF1B2PART__\n");
+
+    if (!ftopmain)
+    {
+      ftopmain=fopen("xxtopm.tmp","w+");
+      if (ftopmain==NULL)
+      {
+        fprintf(stderr,"%s","Error trying to open file xxtopmn.tmp\n");
+        exit(1);
+      }
+      fprintf(ftopmain,"  long int arrmblsize=0;\n");
+      // **********************************************************************
+      // **********************************************************************
+      if (makedll)
+      {
+        fprintf(ftopmain,"extern \"C\" {\n");
+        //fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
+        if (splus_debug_flag)
+        {
+          if (!makegaussdll)
+            fprintf(ftopmain,"\nvoid ");
+          else
+            fprintf(ftopmain,"\nint ");
+
+          fprintf(ftopmain,"%s",infile_root);
+          if (!makegaussdll)
+            fprintf(ftopmain,"(%s,char ** dll_options);\n\n",arglist);
+          else
+            fprintf(ftopmain,"(%s,char * dll_options);\n\n",arglist);
+        
+          fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
+          fprintf(ftopmain,"  ad_set_new_handler();\n");
+          if (bound_flag) fprintf(ftopmain,"  ad_exit=&ad_boundf;\n");
+          fprintf(ftopmain,"  %s",infile_root);
+          fprintf(ftopmain,"(%s,dll_options);\n}\n",arglist1);
+        }   
+        if (!splus_debug_flag)
+        {
+          fprintf(ftopmain,"\n#if !defined(__MSVC32__)"
+            "\n#  define __declspec(x)"
+            "\n#endif\n");
+      
+          fprintf(ftopmain,"\n#if !defined(__BORLANDC__)"
+            "\n#  define _export"
+           "\n#else"
+           "\n#  define _export __stdcall"
+            "\n#endif\n");
+	    
+          if (!makegaussdll)
+            fprintf(ftopmain,"\n__declspec(dllexport) void _export ");
+          else
+            fprintf(ftopmain,"\n__declspec(dllexport) int _export ");
+        }	
+        else
+        {
+          if (!makegaussdll)
+            fprintf(ftopmain,"\nvoid ");
+          else
+            fprintf(ftopmain,"\nint ");
+        }	
+        fprintf(ftopmain,"%s",infile_root);
+        if (num_spargs)
+        {
+          if (!makegaussdll)
+            fprintf(ftopmain,"(%s,char ** dll_options)\n{\n",arglist);
+          else
+            fprintf(ftopmain,"(%s,char * dll_options)\n{\n",arglist);
+        }
+        else  
+        {
+          if (!makegaussdll)
+            fprintf(ftopmain,"(%schar ** dll_options)\n{\n",arglist);
+          else
+            fprintf(ftopmain,"(%schar * dll_options)\n{\n",arglist);
+        }
+
+      }
+      else
+      {
+        fprintf(ftopmain,"\nint main(int argc,char * argv[])\n{\n");
+        fprintf(ftopmain,"  ad_set_new_handler();\n");
+        if (bound_flag) fprintf(ftopmain,"  ad_exit=&ad_boundf;\n");
+      }	
+      // **********************************************************************
+      // **********************************************************************
+
+    }
+    if (talk_to_splus)
+    {
+      fprintf(ftopmain,"  DDEspclient ddesc;\n");
+    }
+    
+    if (makedll)
+    {
+      if (makegaussdll)
+      {
+        fprintf(ftopmain,"  AD_gaussflag=1;\n");
+      }
+      fprintf(ftopmain,"  int argc=1;\n");
+      fprintf(ftopmain,"  char **argv=0;\n");
+      fprintf(ftopmain,"  try {\n");
+    
+      if (!makegaussdll)
+      {
+        fprintf(ftopmain,"    argv=parse_dll_options(\"%s\",argc,"
+          "*dll_options);\n",infile_root);
+      }
+      else
+      {
+        fprintf(ftopmain,"    argv=parse_dll_options(\"%s\",argc,"
+          "dll_options);\n", infile_root);
+      }
+      fprintf(ftopmain,"    do_dll_housekeeping(argc,argv);\n");
+      //fprintf(ftopmain,"    strcpy(argv[0],\"%s\");\n",infile_root);
+      //fprintf(ftopmain,"    strcat(argv[0],\".exe\");\n");
+    
+      if (num_spargs)
+        fprintf(ftopmain,"    dll_args ad_dll(%s);\n",arglist1);
+      else  
+        fprintf(ftopmain,"    dll_args ad_dll;\n");
+    }	
+    fprintf(ftopmain,"    gradient_structure::set_NO_DERIVATIVES();\n");
+    // **********************************************************************
+    // **********************************************************************
+    
+    if (makedll)
+    {
+      fprintf(ftopmain,"    gradient_structure::set_YES_SAVE_VARIABLES_VALUES();\n"
+        "  #if defined(__GNUDOS__) || defined(DOS386) || defined(__DPMI32__) "
+        " || \\\n"
+        "     defined(__MSVC32__)\n"
+        "      if (!arrmblsize) arrmblsize=150000;\n"
+        "  #else\n"
+        "      if (!arrmblsize) arrmblsize=25000;\n"
+        "  #endif\n");
+
+      if (!random_effects_flag)
+      {
+        fprintf(ftopmain,"    model_parameters mp(arrmblsize,argc,argv,ad_dll);\n"
+          "    mp.iprint=10;\n");
+      }
+      else
+      {
+        fprintf(ftopmain,"    df1b2variable::noallocate=1;\n");
+        fprintf(ftopmain,"    df1b2_parameters mp(arrmblsize,argc,argv,ad_dll);\n"
+          "    mp.iprint=10;\n");
+      }
+      
+    }	
+    else
+    {
+      fprintf(ftopmain,"    gradient_structure::set_YES_SAVE_VARIABLES_VALUES();\n"
+        "  #if defined(__GNUDOS__) || defined(DOS386) || defined(__DPMI32__) "
+        " || \\\n"
+        "     defined(__MSVC32__)\n"
+        "      if (!arrmblsize) arrmblsize=150000;\n"
+        "  #else\n"
+        "      if (!arrmblsize) arrmblsize=25000;\n"
+        "  #endif\n");
+      if (!random_effects_flag)
+      {
+       fprintf(ftopmain,"    model_parameters mp(arrmblsize,argc,argv);\n"
+         "    mp.iprint=10;\n");
+      }
+      else
+      {
+       fprintf(ftopmain,"    df1b2variable::noallocate=1;\n");
+       fprintf(ftopmain,"    df1b2_parameters mp(arrmblsize,argc,argv);\n"
+         "    mp.iprint=10;\n");
+      }
+    }	
+    
+
+     if (random_effects_flag)
+     {
+       fprintf(ftopmain,"%s",
+         "\n    function_minimizer::random_effects_flag=1;\n");
+       fprintf(ftopmain,"    df1b2variable::noallocate=0;\n");
+     }
+
+     fprintf(ftopmain,"    mp.preliminary_calculations();\n");
+
+     if (have_separable_function)
+       fprintf(ftopmain,"    initial_df1b2params::separable_flag=1;\n");
+#if defined(NET_DEMO)
+     fprintf(ftopmain,"    mp.computationsx(argc,argv);\n");
+#else
+     fprintf(ftopmain,"    mp.computations(argc,argv);\n");
+#endif
+
+    fprintf(htop,"#include <admodel.h>\n\n");
+
+    if (random_effects_flag)
+    {
+      fprintf(htop,"#include <df1b2fun.h>\n\n");
+      fprintf(htop,"#include <adrndeff.h>\n\n");
+    }
+
+    if (bound_flag)
+    {
+      fprintf(htop,"  extern \"C\"  {\n");
+      fprintf(htop,"    void ad_boundf(int i);\n  }\n");
+    }
+      
+    
+    if (talk_to_splus)
+    {
+      fprintf(htop,"#include <adsplus.h>\n\n");
+    }
+
+    if (makedll)
+    {
+      // make a definition file
+      FILE * fd=0;
+      char deffile_name[125];
+      strcpy(deffile_name,infile_root);
+      strcat(deffile_name,".def");
+      fd=fopen("deffile_name","w");
+      if (!fd)
+      {
+        fprintf(stderr,"Error opining file %s\n",deffile_name);
+      }
+      else
+      {
+        fprintf(fd,"LIBRARY %s\n",infile_root);
+        fprintf(fd,"EXPORTS\n     %s\n",infile_root);
+      }
+    }
+      
+
+    if (makedll)
+    {
+      fprintf(ftopmain,"    ad_make_code_reentrant();\n");
+      fprintf(ftopmain,"  }\n");
+    
+      fprintf(ftopmain,"  catch (spdll_exception spe){ \n");
+      fprintf(ftopmain,"    if (ad_printf && spe.e) (*ad_printf)"
+        " (\"abnormal exit from newtest\\n\");\n");
+      fprintf(ftopmain,"  }\n");
+      fprintf(ftopmain,"  cleanup_argv(argc,&argv);\n");
+      if (makegaussdll) fprintf(ftopmain,"  return 0;\n");
+      fprintf(ftopmain,"}\n");
+      fprintf(ftopmain,"}\n");
+      fprintf(fdat,"%s","};\n");
+      *conlist_ptr='\0';
+      *arglist1_ptr='\0';
+      *classlist_ptr='\0';
+      fprintf(fdat1,"\nclass dll_args\n{\npublic:\n%s",classlist);
+      if (num_spargs)
+        fprintf(fdat1,"\n dll_args(%s) : %s{}\n",arglist,conlist);
+      else  
+        fprintf(fdat1,"\n dll_args()  {}\n");
+      fprintf(fdat1,"\n};\n");
+    }  
+    else
+    {
+      fprintf(ftopmain,"    return 0;\n}\n");
+      fprintf(fdat,"\n};\n");
+    }
+    if (fdat1)
+    {
+      fclose(fdat1);
+      fdat1=0;
+    }
+    //fprintf(fdat,"\n};\n");
+    if (bound_flag)
+    {
+      fprintf(ftopmain,"\nextern \"C\"  {\n");
+      fprintf(ftopmain,"  void ad_boundf(int i)\n  {\n");
+      fprintf(ftopmain,"    /* so we can stop here */\n");
+      fprintf(ftopmain,"    exit(i);\n  }\n}\n");
+    }
+      
+    fclose(fhead);
+    fclose(htop);
+    fclose(fglobals);
+    fclose(ftopmain);
+    fclose(fdat);
+    fclose(fall);
+
+#if defined(_WIN32)
+    strcpy(outcommand,"copy xxglobal.tmp + xxhtop.tmp + header.tmp "
+     "+ xxalloc1.tmp + xxalloc2.tmp + xxalloc3.tmp");
+    if (report_defined)
+    {
+      strcat(outcommand," + xxalloc4.tmp ");
+    }
+    if (preliminary_calcs_defined)
+    {
+      strcat(outcommand," + xxalloc5.tmp ");
+    } 
+    strcat(outcommand, " + xxtopm.tmp + xxalloc6.tmp ");
+  
+    strcpy(outcommand2,"copy tfile1 + tfile2 + tfile3 +tfile4 ");
+
+    strcpy(outcommand3a,"sed -n -f ");
+    strcat(outcommand3a,seddirpath);
+    if (makedll==0)
+      strcat(outcommand3a,"seddf1b3 tfile2 >> ");
+    else
+      strcat(outcommand3a,"seddf1b3dll tfile2 >> ");
+
+    strcpy(outcommand3b,"sed -n -f ");
+    strcat(outcommand3b,seddirpath);
+    strcat(outcommand3b,"seddf1b4 tfile4 >> ");
+
+       
+    strcpy(outcommand3,"sed -f ");
+    strcat(outcommand3,seddirpath);
+    if (makedll==0)
+      strcat(outcommand3,"seddf1b2 tfile2 >> ");
+    else
+      strcat(outcommand3,"seddf1b2dll tfile2 >> ");
+
+    // !!!!! DF may 1 03 Is this right?
+    // this
+    // strcpy(outcommand6,"cat tfile4 >> ");
+    // changed to
+    strcpy(outcommand6,"sed -f ");
+    strcat(outcommand6,seddirpath);
+    strcat(outcommand6,"sedf1b2d tfile4 >> ");
+
+
+    strcpy(outcommand4,"sed -f ");
+    strcat(outcommand4,seddirpath);
+    strcat(outcommand4,"sedf1b2a xxalloc3.tmp >> ");
+
+    strcpy(outcommand5,"sed -f ");
+    strcat(outcommand5,seddirpath);
+    strcat(outcommand5,"sedf1b2c xxalloc2.tmp >> ");
+
+    strcpy(outcommand8,"sed -e \"  \"  tfile5 >> ");
+
+#else
+    strcpy(outcommand,"cat xxglobal.tmp   xxhtop.tmp   header.tmp "
+     "  xxalloc1.tmp   xxalloc2.tmp   xxalloc3.tmp ");
+    if (report_defined)
+    {
+      strcat(outcommand," xxalloc4.tmp");
+    }
+    if (preliminary_calcs_defined)
+    {
+      strcat(outcommand," xxalloc5.tmp");
+    } 
+    strcat(outcommand, "  xxtopm.tmp    xxalloc6.tmp > ");
+
+    strcpy(outcommand2,"cat tfile1  tfile2 tfile3 tfile4 > ");
+
+    strcpy(outcommand3a,"sed -n -f ");
+    strcat(outcommand3a,seddirpath);
+    if (makedll==0)
+      strcat(outcommand3a,"seddf1b3 tfile2 >> ");
+    else
+      strcat(outcommand3a,"seddf1b3dll tfile2 >> ");
+
+    strcpy(outcommand3b,"sed -n -f ");
+    strcat(outcommand3b,seddirpath);
+    strcat(outcommand3b,"seddf1b4 tfile4 >> ");
+
+    printf("%s\n",dirpath);
+
+    strcpy(outcommand3,"sed -f ");
+    strcat(outcommand3,seddirpath);
+    if (makedll==0)
+      strcat(outcommand3,"seddf1b2 tfile2 >> ");
+    else
+      strcat(outcommand3,"seddf1b2dll tfile2 >> ");
+
+    // !!!!! DF may 1 03 Is this right?
+    // this
+    // strcpy(outcommand6,"cat tfile4 >> ");
+    // changed to
+    strcpy(outcommand6,"sed -f ");
+    strcat(outcommand6,seddirpath);
+    strcat(outcommand6,"sedf1b2d tfile4 >> ");
+
+
+    strcpy(outcommand4,"sed -f ");
+    strcat(outcommand4,seddirpath);
+    strcat(outcommand4,"sedf1b2a xxalloc3.tmp >> ");
+
+    strcpy(outcommand5,"sed -f ");
+    strcat(outcommand5,seddirpath);
+    strcat(outcommand5,"sedf1b2c xxalloc2.tmp >> ");
+    
+
+   /*
+    strcpy(outcommand3a,"sed -n -f ");
+    strcat(outcommand3a,dirpath);
+    if (makedll==0)
+      strcat(outcommand3a,"seddf1b3 tfile2 >> ");
+    else
+      strcat(outcommand3a,"seddf1b3dll tfile2 >> ");
+
+    strcpy(outcommand3b,"sed -n -f ");
+    strcat(outcommand3b,dirpath);
+    strcat(outcommand3b,"seddf1b4 tfile4 >> ");
+
+       
+    strcpy(outcommand3,"sed -f ");
+    strcat(outcommand3,dirpath);
+    if (makedll==0)
+      strcat(outcommand3,"seddf1b2 tfile2 >> ");
+    else
+      strcat(outcommand3,"seddf1b2dll tfile2 >> ");
+
+    // !!!!! DF may 1 03 Is this right?
+    // this
+    // strcpy(outcommand6,"cat tfile4 >> ");
+    // changed to
+    strcpy(outcommand6,"sed -f ");
+    strcat(outcommand6,dirpath);
+    strcat(outcommand6,"sedf1b2d tfile4 >> ");
+
+
+    strcpy(outcommand4,"sed -f ");
+    strcat(outcommand4,dirpath);
+    strcat(outcommand4,"sedf1b2a xxalloc3.tmp >> ");
+
+    strcpy(outcommand5,"sed -f ");
+    strcat(outcommand5,dirpath);
+    strcat(outcommand5,"sedf1b2c xxalloc2.tmp >> ");
+
+    strcpy(outcommand8,"sed -e \"  \"  tfile5 >> ");
+
+#else
+    strcpy(outcommand,"cat xxglobal.tmp   xxhtop.tmp   header.tmp "
+     "  xxalloc1.tmp   xxalloc2.tmp   xxalloc3.tmp ");
+    if (report_defined)
+    {
+      strcat(outcommand," xxalloc4.tmp");
+    }
+    if (preliminary_calcs_defined)
+    {
+      strcat(outcommand," xxalloc5.tmp");
+    } 
+    strcat(outcommand, "  xxtopm.tmp    xxalloc6.tmp > ");
+
+    strcpy(outcommand2,"cat tfile1  tfile2 tfile3 tfile4 > ");
+
+    strcpy(outcommand3a,"sed -n -f ");
+    strcat(outcommand3a,dirpath);
+    if (makedll==0)
+      strcat(outcommand3a,"seddf1b3 tfile2 >> ");
+    else
+      strcat(outcommand3a,"seddf1b3dll tfile2 >> ");
+
+    strcpy(outcommand3b,"sed -n -f ");
+    strcat(outcommand3b,dirpath);
+    strcat(outcommand3b,"seddf1b4 tfile4 >> ");
+
+    printf("%s\n",dirpath);
+
+    strcpy(outcommand3,"sed -f ");
+    strcat(outcommand3,dirpath);
+    if (makedll==0)
+      strcat(outcommand3,"seddf1b2 tfile2 >> ");
+    else
+      strcat(outcommand3,"seddf1b2dll tfile2 >> ");
+
+    // !!!!! DF may 1 03 Is this right?
+    // this
+    // strcpy(outcommand6,"cat tfile4 >> ");
+    // changed to
+    strcpy(outcommand6,"sed -f ");
+    strcat(outcommand6,dirpath);
+    strcat(outcommand6,"sedf1b2d tfile4 >> ");
+
+
+    strcpy(outcommand4,"sed -f ");
+    strcat(outcommand4,dirpath);
+    strcat(outcommand4,"sedf1b2a xxalloc3.tmp >> ");
+
+    strcpy(outcommand5,"sed -f ");
+    strcat(outcommand5,dirpath);
+    strcat(outcommand5,"sedf1b2c xxalloc2.tmp >> ");
+   */
+    
+    strcpy(outcommand8,"sed -e \"  \"  tfile5 >> ");
+    
+    //strcpy(outcommand,"cat xxglobal.tmp xxhtop.tmp header.tmp 
+    //  xxalloc1.tmp xxalloc2.tmp xxalloc3.tmp xxalloc4.tmp xxalloc6.tmp " 
+    //  " xxtopm.tmp > ");
+#endif
+    // strcpy(outcommand,"copy xxdata.tmp + header.tmp + xxalloc.tmp ");
+    strcat(outcommand,outfile_name);
+    if (verbosemode)
+      printf("\n%s\n",outcommand);
+    errcopy=system(outcommand);
+    if (errcopy)
+    {
+      fprintf(stderr,"Error executing command %s\n",
+        outcommand);
+    }
+    strcat(outcommand2,headerfile_name);
+
+    if (verbosemode)
+      printf("\n%s\n",outcommand2);
+    errcopy=system(outcommand2);
+    if (errcopy)
+    {
+      fprintf(stderr,"Error executing command %s\n",
+        outcommand2);
+    }
+
+    if (random_effects_flag)
+    {
+      strcpy(outcommand7, " sed -e \" \" ");
+      strcat(outcommand7,headerfile_name); 
+      strcat(outcommand7," >>  classdef.tmp"); 
+      if (verbosemode)
+        printf("\n%s\n",outcommand7);
+      errcopy=system(outcommand7);
+      if (errcopy)
+      {
+        fprintf(stderr,"Error executing command %s\n",
+          outcommand7);
+      }
+    }
+
+    if (random_effects_flag)
+    {
+      strcpy(outcommand7, " sed -e \" \" ");
+      strcat(outcommand7," classdef.tmp > "); 
+      strcat(outcommand7,headerfile_name); 
+      if (verbosemode)
+        printf("\n%s\n",outcommand7);
+      errcopy=system(outcommand7);
+      if (errcopy)
+      {
+        fprintf(stderr,"Error executing command %s\n",
+          outcommand7);
+      }
+    }
+
+    if (random_effects_flag  && have_classcode_tmp)
+    {
+      strcpy(outcommand7, " sed -e \" \" ");
+      strcat(outcommand7," classcode.tmp >> "); 
+      strcat(outcommand7,outfile_name); 
+      if (verbosemode)
+        printf("\n%s\n",outcommand7);
+      errcopy=system(outcommand7);
+      if (errcopy)
+      {
+        fprintf(stderr,"Error executing command %s\n",
+          outcommand7);
+      }
+    }
+
+    strcat(outcommand3a,headerfile_name);
+    if (verbosemode)
+      printf("\n%s\n",outcommand3a);
+    errcopy=system(outcommand3a);
+    if (errcopy)
+    {
+      fprintf(stderr,"Error executing command %s\n",
+        outcommand3a);
+    }
+
+    strcat(outcommand3b,headerfile_name);
+    if (verbosemode)
+      printf("\n%s\n",outcommand3b);
+    errcopy=system(outcommand3b);
+    if (errcopy)
+    {
+      fprintf(stderr,"Error executing command %s\n",
+        outcommand3b);
+    }
+
+    strcat(outcommand3,headerfile_name);
+    if (verbosemode)
+      printf("\n%s\n",outcommand3);
+    errcopy=system(outcommand3);
+    if (errcopy)
+    {
+      fprintf(stderr,"Error executing command %s\n",
+        outcommand3);
+    }
+
+    strcat(outcommand6,headerfile_name);
+    if (verbosemode)
+      printf("\n%s\n",outcommand6);
+    errcopy=system(outcommand6);
+    if (errcopy)
+    {
+      fprintf(stderr,"Error executing command %s\n",
+        outcommand6);
+    }
+    strcat(outcommand4,outfile_name);
+    if (verbosemode)
+      printf("\n%s\n",outcommand4);
+    errcopy=system(outcommand4);
+    if (errcopy)
+    {
+      fprintf(stderr,"Error executing command %s\n",
+        outcommand4);
+    }
+    strcat(outcommand5,outfile_name);
+    if (verbosemode)
+      printf("\n%s\n",outcommand5);
+    errcopy=system(outcommand5);
+    if (errcopy)
+    {
+      fprintf(stderr,"Error executing command %s\n",
+        outcommand5);
+    }
+  
+    if (makedll) 
+    {
+      strcat(outcommand8,headerfile_name);
+      if (verbosemode)
+        printf("\n%s\n",outcommand8);
+      errcopy=system(outcommand8);
+
+      printf("%s\n",outcommand8);
+
+      if (errcopy)
+      {
+        fprintf(stderr,"Error executing command %s\n",
+          outcommand8);
+      }
+    }
+    if (!errcopy)
+    {
+        //  unlink("classdef.tmp");
+        //  unlink("xxdata.tmp");
+        //  unlink("xxhtop.tmp");
+        //  unlink("xxhtopm.tmp");
+        //  unlink("xxglobal.tmp");
+        //  unlink("xxtopm.tmp");
+        //  unlink("xxalloc.tmp");
+        //  unlink("xxalloc1.tmp");
+        //  unlink("xxalloc2.tmp");
+        //  unlink("xxalloc3.tmp");
+        //  unlink("xxalloc4.tmp");
+        //  unlink("xxalloc5.tmp");
+        //  unlink("xxalloc6.tmp");
+        //  unlink("header.tmp");
+        //  unlink("tfile1");
+        //  unlink("tfile2");
+        //  unlink("tfile3");
+        //  unlink("tfile4");
+        //  unlink("tempfnp");
+        //  unlink("tempfnp_tmp1");
+        //  unlink("tempfnp_tmp2");
+        //  unlink("tempfnp_tmp3");
+        //  unlink("tempfnp_tmp4");
+        //  unlink("_tempfnpsed");
+        if (makedll) 
+        {
+          unlink("tfile5");
+        }
+    }
+    else
+    {
+      fprintf(stderr,"Error trying to create output file %s\n",
+        outfile_name);
+    }
+    if (!random_effects_flag)
+    {
+      fprintf(stderr,"%s"," WARNING !!! No random effects vector defined "
+        "in this TPL file\n");
+    }
+    
+    exit(0);
+                  }
+
+
+%%
+
+int check_for_blanks(const char * s)
+{
+  int bflag=0;
+  int i;
+  for (i=0;i<strlen(s);i++)
+  {
+    if (s[i]==' ')
+    {
+      bflag=1;
+      break;
+    }
+  }
+  return bflag;
+}
+
+int option_match(int argc,char * argv[], char * string);
+
+unsigned _stklen = 16000;
+char * get_directory_name(const char * s)
+{
+  char * path;
+  char quote[]="\"";
+  int bflag=0;
+  int len;
+  int i,j;
+  char * path1=getenv("ADMB_HOME");
+  /* char sed_file_separator='/'; */
+#if defined(WIN32)
+  char file_separator='\\';
+  char file_separator_string[]="\\";
+#else
+  char file_separator='/';
+  char file_separator_string[]="/";
+#endif
+  if (path1==0)
+  {
+    printf("ADMB_HOME environment string is not set\n");
+    exit(1);
+    len=strlen(s);
+    for (i=1;i<=len;i++)
+    {
+      if (s[len-i]==file_separator) break;
+    }
+    path = (char*) malloc(sizeof(char*)*(len-i+2));
+    for (j=0;j<=len-i;j++)
+    {
+      path[j]=s[j];
+    }
+    path[len-i+1]=0;
+  }
+  else
+  {
+    bflag=check_for_blanks(path1);
+    len=strlen(path1);
+    if (path1[len-1]==file_separator) 
+    {
+      path = (char*) malloc(sizeof(char*)*(len+9));
+      if (bflag==0)
+      {
+        strcpy(path,path1);
+      }
+      else
+      {
+        strcpy(path,quote);
+        strcat(path,path1);
+        strcat(path,file_separator_string);
+        strcat(path,quote);
+        len+=2;
+      }
+      
+      strcat(path,"bin");
+      path[len+4]=file_separator;
+      path[len+5]=0;
+    }
+    else
+    {
+      path = (char*) malloc(sizeof(char*)*(len+9));
+      if (bflag==0)
+      {
+        strcpy(path,path1);
+      }
+      else
+      {
+        strcpy(path,quote);
+        strcat(path,path1);
+        strcat(path,quote);
+        len+=2;
+      }
+      path[len]=file_separator;
+      path[len+1]=0;
+      strcat(path,"bin");
+      path[len+4]=file_separator;
+      path[len+5]=0;
+    }
+  } 
+  return path;
+}
+
+void check_random_effects_ordering(void)
+{
+  if (random_effects_flag==1)
+  {
+    fprintf(stderr,"Error in PARAMETER_SECTION at line");
+    fprintf(stderr," %d \n",nline);
+    fprintf(stderr,"Random effects objects must be declared after all other"
+       " initial objects.\n");
+    exit(1);
+  }
+}
+  
+int main(int argc, char * argv[])
+{
+  FILE * f1=NULL;
+  int ioff=argc-1;
+  int on=0;
+  dirpath= get_directory_name(argv[0]);
+  if (verbosemode)
+    printf(" dirpath = %s\n",dirpath);
+  //printf(" PATH= %s\n",getenv("PATH"));
+  //if ( (on=option_match(argc,argv,"-bounds"))>-1)
+  {
+    bound_flag=1;
+  }  
+
+  if ( (on=option_match(argc,argv,"-seddir"))>-1)
+  {
+    strncpy(seddirpath,argv[on+1],100);
+  }
+  else
+  {
+    strncpy(seddirpath,dirpath,100);
+  }
+  printf(" seddirpath set to %s\n",seddirpath);
+
+  if ( (on=option_match(argc,argv,"-v"))>-1)
+  {
+    verbosemode=1;
+  }  
+  if ( (on=option_match(argc,argv,"-dll"))>-1)
+  {
+    makedll=1;
+  }  
+  if ( (on=option_match(argc,argv,"-gaussdll"))>-1)
+  {
+    makedll=1;
+    makegaussdll=1;
+  }  
+  if ( (on=option_match(argc,argv,"-debug"))>-1)
+  {
+    splus_debug_flag=1;
+  }  
+  if ( (on=option_match(argc,argv,"-no_pad"))>-1)
+  {
+    no_userclass=1;
+  }  
+  if (argc>1)
+  {
+    strcpy(infile_name,argv[ioff]);
+    strcpy(deffile_name,argv[ioff]);
+    strcpy(infile_root,infile_name);
+    strcpy(outfile_name,argv[ioff]);
+    strcpy(headerfile_name,argv[ioff]);
+    strcpy(headerfile_name2,argv[ioff]);
+    strcat(infile_name,".tpl");
+    strcat(outfile_name,".cpp");
+    strcat(headerfile_name,".htp");
+    strcat(deffile_name,".def");
+    strcat(headerfile_name2,"2.htp");
+    if (debug_flag) fprintf(stderr,"Trying to open file %s for input\n", infile_name);
+    yyin=fopen(infile_name,"r");
+    if (!yyin)
+    {
+      fprintf(stderr,"Error trying to open input file %s\n",
+        infile_name);
+      exit(1);
+    }
+    if (debug_flag) fprintf(stderr,"Opened file %s for input\n", infile_name);
+    if (makedll) 
+    {
+      strcpy(tmp_string1,argv[ioff]);
+      strcat(tmp_string1,".def");
+      f1=fopen(tmp_string1,"w");
+      fprintf(f1,"LIBRARY %s\n\n",argv[ioff]);
+      fprintf(f1,"EXPORTS\n");
+      fprintf(f1,"\t%s\n",argv[ioff]);
+      fclose(f1);
+      f1=NULL;
+    }  
+  }
+  else
+  {
+    strcpy(infile_name,"admodel.tpl");
+    strcpy(outfile_name,"admodel.cpp");
+    if (debug_flag) fprintf(stderr,"Trying to open file %s for input\n", infile_name);
+    yyin=fopen(infile_name,"r");
+    if (!yyin)
+    {
+      fprintf(stderr,"Error trying to open default input file %s\n",
+        infile_name);
+      exit(1);
+    }
+    if (debug_flag) fprintf(stderr,"Opened file %s for input\n", infile_name);
+  }
+  conlist_ptr=&(conlist[0]);
+  classlist_ptr=&(classlist[0]);
+  arglist_ptr=&(arglist[0]);
+  arglist1_ptr=&(arglist1[0]);
+
+
+  htop=fopen("xxhtop.tmp","w+");
+  if (htop==NULL)
+  {
+    fprintf(stderr,"Error trying to open file %s\n","xxhtop.tmp");
+  }
+  fglobals=fopen("xxglobal.tmp","w+");
+  if (fglobals==NULL)
+  {
+    fprintf(stderr,"Error trying to open file %s\n","xxglobal.tmp");
+  }
+  //fdat=fopen(headerfile_name,"w+");
+  fdat=fopen("tfile1","w+");
+  if (fdat==NULL)
+  {
+    fprintf(stderr,"Error trying to open file tfile1\n");
+  }
+  if (makedll)
+  {
+    fdat1=fopen("tfile5","w+");
+    if (fdat1==NULL)
+    {
+      fprintf(stderr,"Error trying to open file tfile1\n");
+    }
+  }
+  fall=fopen("xxalloc1.tmp","w+");
+  if (fall==NULL)
+  {
+    fprintf(stderr,"%s","Error trying to open file xxalloc1.tmp\n");
+  }
+  fprintf(fall,"#include <%s>\n\n",headerfile_name);
+  fprintf(fall,"  df1b2_parameters * df1b2_parameters::df1b2_parameters_ptr=0;\n");
+  fprintf(fall,"  model_parameters * model_parameters::model_parameters_ptr=0;\n");
+  fhead=fopen("header.tmp","w+");
+  if (fhead==NULL)
+  {
+    fprintf(stderr,"%s","Error trying to open file header.tmp\n");
+  }
+  yylex();
+  if (fs)
+  {
+    fclose(fs);
+    fs=0;
+  }
+  return 0;
+}
+
+char * before_part(char * d, char * s, char c)
+{
+  int ipos=0;
+  int i=0;
+  int iflag=0;
+  if (strlen(s) > MAX_TMP_STRING)
+  {
+    fprintf(stderr,"%s","string passed to before_part is too long\n");
+    exit(1);
+  }
+  for (i=0;i<strlen(s);i++)
+  {
+    if (s[i]==c)
+    {
+      ipos=i;
+      iflag=1;
+      break;
+    }
+  }
+  if (ipos)
+  {
+    for (i=0;i<ipos;i++)
+    {
+      d[i]=s[i];
+    }
+    d[ipos]='\0';
+  }
+  return d;
+}
+
+char * before_partb(char * d, char * s, char c)
+{
+  int ipos=0;
+  int i=0;
+  int iflag=0;
+  if (strlen(s) > MAX_TMP_STRING)
+  {
+    fprintf(stderr,"%s","string passed to before_part is too long\n");
+    exit(1);
+  }
+  for (i=strlen(s)-1;i>=1;i--)
+  {
+    if (s[i]==c)
+    {
+      ipos=i;
+      iflag=1;
+      break;
+    }
+  }
+  if (ipos)
+  {
+    for (i=0;i<ipos;i++)
+    {
+      d[i]=s[i];
+    }
+    d[ipos]='\0';
+  }
+  return d;
+}
+
+char * after_part(char * d, char * s, char c)
+{
+  int ipos=0;
+  int i=0;
+  int iflag=0;
+  if (strlen(s) > MAX_TMP_STRING)
+  {
+    fprintf(stderr,"%s","string passed to before_part is too long\n");
+    exit(1);
+  }
+  for (i=0;i<strlen(s);i++)
+  {
+    if (s[i]==c)
+    {
+      ipos=i;
+      iflag=1;
+      break;
+    }
+  }
+  if(iflag)
+  {
+    for (i=ipos;i<strlen(s);i++)
+    {
+      d[i-ipos]=s[i];
+    }
+    d[strlen(s)-ipos]='\0';
+  }
+  return d;
+}
+
+char * strict_after_part(char * d, char * s, char c)
+{
+  int ipos=0;
+  int i=0;
+  int iflag=0;
+  if (strlen(s) > MAX_TMP_STRING)
+  {
+    fprintf(stderr,"%s","string passed to before_part is too long\n");
+    exit(1);
+  }
+  for (i=0;i<strlen(s);i++)
+  {
+    if (s[i]==c)
+    {
+      ipos=i;
+      iflag=1;
+      break;
+    }
+  }
+  if(iflag)
+  {
+    for (i=ipos+1;i<strlen(s);i++)
+    {
+      d[i-ipos-1]=s[i];
+    }
+    d[strlen(s)-ipos-1]='\0';
+  }
+  return d;
+}
+char * after_partb(char * d, char * s, char c)
+{
+  int ipos=0;
+  int i=0;
+  int iflag=0;
+  if (strlen(s) > MAX_TMP_STRING)
+  {
+    fprintf(stderr,"%s","string passed to before_part is too long\n");
+    exit(1);
+  }
+  for (i=strlen(s)-1;i>=0;i--)
+  {
+    if (s[i]==c)
+    {
+      ipos=i+1;
+      iflag=1;
+      break;
+    }
+  }
+  if(iflag)
+  {
+    for (i=ipos;i<strlen(s);i++)
+    {
+      d[i-ipos]=s[i];
+    }
+    d[strlen(s)-ipos]='\0';
+  }
+  else
+  {
+    d[0]='\0';
+  }  
+  return d;
+}
+
+char * strip_leading_blanks(char * d, char * s)
+{
+  int start_flag=0;
+  int j=0;
+  int i=0;
+  if (strlen(s) > MAX_TMP_STRING)
+  {
+    fprintf(stderr,"%s","string passed to before_part is too long\n");
+    exit(1);
+  }
+  for (i=0;i<strlen(s);i++)
+  {
+    if (!start_flag)
+    {
+      if (s[i]!=' ')
+      {
+        start_flag=1;
+        d[j++]=s[i];
+      }
+    }
+    else
+    {
+      d[j++]=s[i];
+    }
+  }
+  d[j]='\0';
+  return d;
+}
+
+char * strip_leading_blanks_and_tabs(char * d, char * s)
+{
+  int start_flag=0;
+  int j=0;
+  int i=0;
+  if (strlen(s) > MAX_TMP_STRING)
+  {
+    fprintf(stderr,"%s","string passed to before_part is too long\n");
+    exit(1);
+  }
+  for (i=0;i<strlen(s);i++)
+  {
+    if (!start_flag)
+    {
+      if (s[i]!=' ' && s[i]!='\t')
+      {
+        start_flag=1;
+        d[j++]=s[i];
+      }
+    }
+    else
+    {
+      d[j++]=s[i];
+    }
+  }
+  d[j]='\0';
+  return d;
+}
+
+int count_paren(int num_paren,char * yytext)
+{
+  int i;
+  for (i=0;i<=strlen(yytext);i++)
+  {
+    if (yytext[i]=='(')
+    {
+      num_paren++;
+    } 
+    if (yytext[i]==')')
+    {
+      num_paren--;
+    } 
+  }
+  return num_paren;
+}
+
+void add_references_to_user_classes(FILE * fall)  
+{
+  int i;
+  if (!no_userclass)
+  {
+    if (num_user_classes)
+    {
+      for (i=0;i<=num_user_classes-1;i++)
+        fprintf(fall,"  %s;\n",reference_statements[i]);
+    }
+  }
+}
+
+void call_destructors_for_user_classes(FILE * fall)  
+{
+  int i;
+  if (num_user_classes)
+  {
+    fprintf(fall,"\n");
+    for (i=0;i<=num_user_classes-1;i++)
+    {
+      fprintf(fall,"  delete pad_%s;\n",class_instances[i]);
+      fprintf(fall,"  pad_%s = NULL;\n",class_instances[i]);
+    }
+  }
+}
+void initialize(char *s)
+{
+  s[0]='\0';
+}  
+
+void marker(void){;}
+
+
+void write_end_normal_prior(void){
+  if(in_normal_prior==1)
+  {
+    if (sparse_quadprior_flag==0)
+    {
+      fprintf(fall,"      if (M.dfpMinv){\n");
+      fprintf(fall,"        delete M.dfpMinv;\n");
+      fprintf(fall,"        M.dfpMinv=0;\n");
+      fprintf(fall,"      }\n");
+      if (normal_prior_flag2==0)
+        fprintf(fall,"      M.dfpMinv=new dvar_matrix(tmpM);\n");
+      else
+        fprintf(fall,"      M.dfpMinv=new dvar_matrix(inv(tmpM)); /* df1b2 Deletion Tag */\n");
+      //normal_prior_flag2=0;
+    }
+    else
+    {
+      fprintf(fall,"      if (M.S_dfpMinv){\n");
+      fprintf(fall,"        delete M.S_dfpMinv;\n");
+      fprintf(fall,"        M.S_dfpMinv=0;\n");
+      fprintf(fall,"      }\n");
+      fprintf(fall,"      M.S_dfpMinv=new dvar_compressed_triplet(tmpM);\n");
+    }
+    fprintf(fall,"    if (quadratic_prior::matrix_mult_flag){\n");
+    fprintf(fall,"      M=tmpM;\n  }\n");
+    fprintf(fall,"/* XXXX */ \n  }else{\n/*CUTSNIP-BEGIN*/\n");
+    fprintf(fall,"    if (quadratic_prior::calc_matrix_flag){\n");
+    fclose(tempf_NP);
+    errcopy=system("sed -e s/dvariable/double/g tempfnp > tempfnp_tmp1");
+    if (errcopy){
+      fprintf(stderr,"Error executing command %s\n","write_end_normal_prior ()");
+    }
+    errcopy=system("sed -e s/dvar_vector/dvector/g "
+      " -e s/dvar_compressed_triplet/dcompressed_triplet/g "
+      " tempfnp_tmp1 > tempfnp_tmp2");
+    if (errcopy){
+      fprintf(stderr,"Error executing command %s\n","write_end_normal_prior ()");
+    }
+    errcopy=system("sed -e s/dvar_matrix/dmatrix/g tempfnp_tmp2 > tempfnp_tmp3");
+    if (errcopy){
+      fprintf(stderr,"Error executing command %s\n","write_end_normal_prior ()");
+    }
+    errcopy=system("sed -f _tempfnpsed tempfnp_tmp3 > tempfnp_tmp4");
+    if (errcopy){
+      fprintf(stderr,"Error executing command %s\n","write_end_normal_prior ()");
+    }
+
+    FILE *ffrom;
+    char ch;
+    ffrom = fopen("tempfnp_tmp4","r");
+    while(1){
+      ch = getc(ffrom);
+      if(ch==EOF){
+        break;
+      }
+      else{
+        putc(ch,fall);
+      }
+    }
+    if (sparse_quadprior_flag==0)
+    {
+      if (normal_prior_flag2==0)
+      {
+        fprintf(fall,"      if (M.CM){\n");
+        fprintf(fall,"        delete M.CM;\n");
+        fprintf(fall,"        M.CM=0;\n");
+        fprintf(fall,"      }\n");
+        printf("iVVVV");
+        fprintf(fall,"      M.CM=new dmatrix(tmpM);\n");
+        fprintf(fall,"      ZZZZZ");
+        fprintf(fall,"      if (M.SCM){\n");
+        fprintf(fall,"        delete M.SCM;\n");
+        fprintf(fall,"        M.SCM=0;\n");
+        fprintf(fall,"      }\n");
+        fprintf(fall,"    }\n");
+        fprintf(fall,"    if (quadratic_prior::matrix_mult_flag){\n");
+        fprintf(fall,"      M=*(M.CM);\n");
+      }
+      else
+      {
+        fprintf(fall,"      if (M.LU){\n");
+        fprintf(fall,"        delete M.LU;\n");
+        fprintf(fall,"        M.LU=0;\n");
+        fprintf(fall,"      }\n");
+        printf("iVVVV");
+        fprintf(fall,"     M.LU=new dmatrix(ludcmp(tmpM,*(M.indx)"
+          ",M.lndet,M.sgn,M.d));  /* df1b2 Deletion Tag */ \n");
+
+        fprintf(fall,"      if (M.SCM){\n");
+        fprintf(fall,"        delete M.SCM;\n");
+        fprintf(fall,"        M.SCM=0;\n");
+        fprintf(fall,"      }\n");
+        fprintf(fall,"    }\n");
+        fprintf(fall,"    if (quadratic_prior::matrix_mult_flag){\n");
+        fprintf(fall,"      M=*(M.LU);\n");
+      }
+      fprintf(fall,"  }\n/*CUTSNIP-END*/ \n");
+      fprintf(fall,"  } \n") ;
+    }
+    else
+    {
+      fprintf(fall,"      if (M.CM){\n");
+      fprintf(fall,"        delete M.CM;\n");
+      fprintf(fall,"        M.CM=0;\n");
+      fprintf(fall,"      }\n");
+      fprintf(fall,"      if (M.SCM){\n");
+      fprintf(fall,"        delete M.SCM;\n");
+      fprintf(fall,"        M.SCM=0;\n");
+      fprintf(fall,"      }\n");
+      fprintf(fall,"      M.SCM=new dcompressed_triplet(tmpM);\n");
+      fprintf(fall,"    }\n");
+      fprintf(fall,"    if (quadratic_prior::matrix_mult_flag){\n");
+      fprintf(fall,"    M=*(M.SCM);\n");
+      fprintf(fall,"  }\n/*CUTSNIP-END*/ \n");
+      fprintf(fall,"  } \n") ;
+    }
+    in_normal_prior=0;
+    //normal_prior_flag2=0;
+  }
+}
+
+ void write_funnel_end(void)
+ {
+   switch (in_funnel_proc)
+   {
+   case 0:
+     break;
+   case 1:
+     fprintf(fall,"  end_df1b2_funnel();\n");
+     break;
+   case 2:
+     fprintf(fall,"  lapprox->end_separable_call_stuff();\n");
+     break;
+   default:
+      fprintf(stderr,"illegal value for in_funnel_proc\n");
+      exit(1);
+   }
+   in_funnel_proc=0;
+ }
+
+ int option_match(int argc,char * argv[], char * string)
+ {
+   int rval=-1;
+   int i=0;
+   for (i=0;i<argc;i++)
+   {
+     if (!strcmp(argv[i],string))
+     {
+       rval=i;
+       break;
+     }
+   }
+   return rval;
+ }
+
+ void write_unallocated(const char * t)
+ {
+   fprintf(stderr,"warning -- creating unallocated %s at line %d\n",t,
+     nline);
+ }
+void  get_next_argument(char * buffer,char * arg)
+{
+  int ii;
+  int len;
+  char * tptr;
+  char * ptr;
+  char * argend;
+  char * argbegin;
+  arg[0]='\0';
+  len=strlen(buffer);
+  if (len==0)
+    return;
+  ptr=buffer+len-1;
+  while(*ptr == ' ')
+  {
+    if (ptr<=buffer) break;
+    ptr--;
+  }   
+  argend=ptr;
+  while(*ptr !=' ' && *ptr != '&')
+  {
+    if (ptr<=buffer) break;
+    ptr--;
+  }   
+  argbegin=ptr+1;
+  ii=0;
+  for (tptr=argbegin;tptr<=argend;tptr++)
+  {
+    arg[ii++]=*tptr;
+    if (ii>1000)
+    {
+      printf("Overflow error in get_next_argument\n");
+      exit(1);
+    }
+  } 
+  arg[ii]='\0';
+  while(*ptr !=',' && *ptr != '(')
+  {
+    if (ptr<=buffer) break;
+    ptr--;
+  }   
+  *ptr='\0';
+}
+void write_getindex_stuff(char *str)
+{
+  int icount;
+  /* char * argptr; */
+  int paren_level=0;
+  char * last_paren;
+  char * first_paren;
+  char buffer[10001];
+  char function_arg[1001];
+  printf(" %s \n",str);
+  first_paren=strchr(str,'(');
+  if (first_paren==0)
+  {
+    printf("Error in write_getindex_stuff\n");
+    exit(1);
+  }
+  strncpy(buffer,first_paren+1,10000);
+  last_paren=strrchr(buffer,')');
+  if (last_paren==0)
+  {
+    printf("Error in write_getindex_stuff\n");
+    exit(1);
+  }
+  else
+  {
+    *(last_paren)='\0';
+    paren_level=1;
+  }
+  do
+  {
+    get_next_argument(buffer,&(function_arg[0]));
+    if (strlen(function_arg)==0) break;
+    fprintf(fall,"  ADMB_getcallindex(%s);\n",function_arg);
+    icount++;
+  }
+  while(1);
+  // XNESTED
+}
+
+void print_quadratic_random_effect_penalty_class(char *text)
+{
+  if (class_append_flag==0)
+  {
+    if(fs==0) 
+    {
+      fs=fopen("classdef.tmp","w+");
+    }
+  
+    if(fs1==0) 
+    {
+      fs1=fopen("classcode.tmp","w+");
+      have_classcode_tmp=1;
+    }
+  } 
+  else
+  {
+    if(fs==0) 
+    {
+      fs=fopen("classdef.tmp","a+");
+    }
+  
+    if(fs1==0) 
+    {
+      fs1=fopen("classcode.tmp","a+");
+      have_classcode_tmp=1;
+    }
+  } 
+
+  if (quadratic_classprint_flag==1)
+  {
+    fprintf(fs,"AAA\n");
+   
+    fprintf(fs,"\nclass df1b2quadratic_re_penalty_%s : "
+      "public df1b2quadratic_re_penalty\n" 
+    "{\n"
+    "public:\n"
+    "  void get_Lxu(dmatrix& M);\n"
+    "  void get_cM(void);\n"
+    "  void operator = (const df1b2matrix & M)\n"
+    "  {\n"
+    "    df1b2quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "};\n",text);
+    fprintf(fs,"\nclass quadratic_re_penalty_%s : "
+      "public quadratic_re_penalty\n" 
+    "{\n"
+    "public:\n"
+    "  void get_cM(void);\n"
+    "  void operator = (const dvar_matrix & M)\n"
+    "  {\n"
+    "    quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "};\n",text);
+  }
+  if (quadratic_classprint_flag==2)
+  {
+    if (in_normal_prior_flag==1)
+    {
+      fprintf(fs,"\nclass df1b2_normal_prior_%s : ",text);
+      //in_normal_prior_flag=0;
+    }
+    else
+    {
+      fprintf(fs,"\nclass df1b2_normal_prior_%s : ",text);
+      //fprintf(fs,"\nclass df1b2quadratic_re_penalty_%s : ",text);
+    }
+    fprintf(fs,"public df1b2quadratic_re_penalty\n" 
+    "{\n"
+    "public:\n"
+    "  void get_Lxu(dmatrix& M);\n"
+    "  df1b2_normal_prior_%s(){old_style_flag=0;}\n"
+    "  void get_cM(void);\n"
+    "  void operator = (const df1b2matrix & M)\n"
+    "  {\n"
+    "    df1b2quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "  void operator = (const dmatrix & M)\n"
+    "  {\n"
+    "    cerr << \" should not get here\" << endl;  \n"
+    "    ad_exit(1);\n"
+    "  }\n"
+    "  void operator = (const dcompressed_triplet & M)\n"
+    "  {\n"
+    "    cerr << \" should not get here\" << endl;  \n"
+    "    ad_exit(1);\n"
+    "  }\n"
+    "  void operator = (const df1b2_compressed_triplet & M)\n"
+    "  {\n"
+    "    df1b2quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "};\n",text);
+    if (sparse_quadprior_flag==0) 
+    {
+      fprintf(fs,"\nclass df_normal_prior_%s : "
+        "public quadratic_re_penalty\n" 
+      "{\n"
+      "public:\n"
+      "  df_normal_prior_%s(){old_style_flag=0;}\n"
+      "  void get_cM(void);\n"
+      "  void operator = (const dmatrix & M)\n"
+      "  {\n"
+      "    quadratic_re_penalty::operator = (M);\n"
+      "  }\n"
+      "  void operator = (const dvar_matrix & M)\n"
+      "  {\n"
+      "    quadratic_re_penalty::operator = (M);\n"
+      "  }\n"
+      "};\n",text,text);
+    }
+    else
+    {
+      fprintf(fs,"\nclass df_normal_prior_%s : "
+        "public quadratic_re_penalty\n" 
+      "{\n"
+      "public:\n"
+      "  df_normal_prior_%s(){old_style_flag=0;}\n"
+      "  void get_cM(void);\n"
+      "  void operator = (const dcompressed_triplet & M)\n"
+      "  {\n"
+      "    quadratic_re_penalty::operator = (M);\n"
+      "  }\n"
+      "  void operator = (const dvar_matrix & M)\n"
+      "  {\n"
+      "    quadratic_re_penalty::operator = (M);\n"
+      "  }\n"
+      "};\n",text,text);
+    }
+
+    /*
+     fprintf(fs1,"\nvoid df1b2quadratic_re_penalty_%s::get_Lxu(dmatrix& LXU)\n"
+    */
+    fprintf(fs1,"\nvoid df1b2_normal_prior_%s::get_cM(void)\n"
+    "{\n"
+    "  df1b2_parameters * mp=\n"
+    "    df1b2_parameters::get_df1b2_parameters_ptr();\n"
+    "  mp->evaluate_M();\n"
+    "}\n",text);      
+
+    fprintf(fs1,"\nvoid df1b2_normal_prior_%s::get_Lxu(dmatrix& LXU)\n"
+    "{\n"
+     "  df1b2_parameters * mp=\n"
+     "    df1b2_parameters::get_df1b2_parameters_ptr();\n"
+     "  mp->evaluate_M();\n"
+     "  int rmin=Lxu->indexmin();\n"
+     "  int rmax=Lxu->indexmax();\n"
+     "  int cmin=1;\n"
+     "  int cmax=(*Lxu)(rmin).indexmax();\n"
+     "  if (cmax != LXU.indexmax())\n"
+     "  {\n"
+     "    cerr << \"Shape error in get_Lxu\" << endl;\n"
+     "    ad_exit(1);\n"
+     "  }\n"
+     "  \n"
+     "  for (int i=rmin;i<=rmax;i++)\n"
+     "  {\n"
+     "    int row = (int)((*Lxu)(i,0));\n"
+     "    for (int j=cmin;j<=cmax;j++)\n"
+     "    {\n"
+     "      LXU(j,row)+=(*Lxu)(i,j);\n"
+     "    }\n"
+     "  }\n"
+     "}\n",text);
+     fprintf(fs1,"\nvoid df_normal_prior_%s::get_cM(void)\n"
+     "{\n"
+     "  model_parameters * mp=\n"
+     "    model_parameters::get_model_parameters_ptr();\n"
+     "  mp->evaluate_M();\n"
+     "}\n",text);      
+  }
+  if (quadratic_classprint_flag==4)
+  {
+    if (in_normal_prior_flag==1)
+    {
+      if (sparse_normal_flag==0)
+        fprintf(fs,"\nclass df1b2_sparse_quadratic_prior_%s : ",text);
+      else
+        fprintf(fs,"\nclass df1b2_sparse_normal_prior_%s : ",text);
+      //in_normal_prior_flag=0;
+    }
+    else
+    {
+      if (sparse_normal_flag==0)
+        fprintf(fs,"\nclass df1b2_sparse_quadratic_prior_%s : ",text);
+      else
+        fprintf(fs,"\nclass df1b2_sparse_normal_prior_%s : ",text);
+      //fprintf(fs,"\nclass df1b2quadratic_re_penalty_%s : ",text);
+    }
+    fprintf(fs,"public df1b2quadratic_re_penalty\n" 
+    "{\n"
+    "public:\n"
+    "  void get_Lxu(dmatrix& M);\n");
+    if (sparse_normal_flag==0)
+    {
+      fprintf(fs,"  df1b2_sparse_quadratic_prior_%s(){old_style_flag=2;}\n",
+        text);
+    }
+    else
+    {
+      fprintf(fs,"  df1b2_sparse_normal_prior_%s(){old_style_flag=1;}\n",
+        text);
+    }
+    fprintf(fs,"  void get_cM(void);\n"
+    "  void operator = (const df1b2matrix & M)\n"
+    "  {\n"
+    "    df1b2quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "  void operator = (const dmatrix & M)\n"
+    "  {\n"
+    "    cerr << \" should not get here\" << endl;  \n"
+    "    ad_exit(1);\n"
+    "  }\n"
+    "  void operator = (const dcompressed_triplet & M)\n"
+    "  {\n"
+    "    cerr << \" should not get here\" << endl;  \n"
+    "    ad_exit(1);\n"
+    "  }\n"
+    "  void operator = (const df1b2_compressed_triplet & M)\n"
+    "  {\n"
+    "    df1b2quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "};\n");
+    if (sparse_normal_flag==0)
+    {
+      fprintf(fs1,"\nvoid df1b2_sparse_quadratic_prior_%s::get_cM(void)\n",
+        text);
+    }
+    else
+    {
+      fprintf(fs1,"\nvoid df1b2_sparse_normal_prior_%s::get_cM(void)\n",
+        text);
+    }
+    fprintf(fs1,"{\n"
+     "  df1b2_parameters * mp=\n"
+     "    df1b2_parameters::get_df1b2_parameters_ptr();\n"
+     "  mp->evaluate_M();\n"
+     "}\n");      
+    if (sparse_normal_flag==0)
+    {
+      fprintf(fs,"\nclass df_sparse_quadratic_prior_%s : "
+        "public sparse_quadratic_re_penalty\n" 
+      "{\n"
+      "public:\n"
+        "  df_sparse_quadratic_prior_%s(){old_style_flag=2; sparse_flag=1;}\n",
+        text,text);
+    }
+    else
+    {
+      fprintf(fs,"\nclass df_sparse_normal_prior_%s : "
+        "public sparse_quadratic_re_penalty\n" 
+      "{\n"
+      "public:\n"
+        "  df_sparse_normal_prior_%s(){old_style_flag=1; sparse_flag=1;}\n",
+        text,text);
+    }
+    fprintf(fs,
+    "  void get_cM(void);\n"
+    "  void operator = (const dvar_matrix & M)\n"
+    "  {\n"
+    "    sparse_quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "  void operator = (const dvar_compressed_triplet & M)\n"
+    "  {\n"
+    "    sparse_quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "  void operator = (const dcompressed_triplet & M)\n"
+    "  {\n"
+    "    sparse_quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "};\n",text);
+
+
+    if (sparse_normal_flag==0)
+    {
+      fprintf(fs1,
+        "\nvoid df1b2_sparse_quadratic_prior_%s::get_Lxu(dmatrix& LXU)\n",
+          text);
+    }
+    else
+    {
+      fprintf(fs1,
+        "\nvoid df1b2_sparse_normal_prior_%s::get_Lxu(dmatrix& LXU)\n",
+          text);
+    }
+    fprintf(fs1,
+    "{\n"
+     "  df1b2_parameters * mp=\n"
+     "    df1b2_parameters::get_df1b2_parameters_ptr();\n"
+     "  mp->evaluate_M();\n"
+     "  int rmin=Lxu->indexmin();\n"
+     "  int rmax=Lxu->indexmax();\n"
+     "  int cmin=1;\n"
+     "  int cmax=(*Lxu)(rmin).indexmax();\n"
+     "  if (cmax != LXU.indexmax())\n"
+     "  {\n"
+     "    cerr << \"Shape error in get_Lxu\" << endl;\n"
+     "    ad_exit(1);\n"
+     "  }\n"
+     "  \n"
+     "  for (int i=rmin;i<=rmax;i++)\n"
+     "  {\n"
+     "    int row = (int)((*Lxu)(i,0));\n"
+     "    for (int j=cmin;j<=cmax;j++)\n"
+     "    {\n"
+     "      LXU(j,row)+=(*Lxu)(i,j);\n"
+     "    }\n"
+     "  }\n"
+     "}\n",text);
+     if (sparse_normal_flag==0)
+     {
+       fprintf(fs1,"\nvoid df_sparse_quadratic_prior_%s::get_cM(void)\n",
+         text);
+     }
+     else
+     {
+       fprintf(fs1,"\nvoid df_sparse_normal_prior_%s::get_cM(void)\n",
+         text);
+     }
+     fprintf(fs1,"{\n"
+     "  model_parameters * mp=\n"
+     "    model_parameters::get_model_parameters_ptr();\n"
+     "  mp->evaluate_M();\n"
+     "}\n");      
+  }
+  
+  if (quadratic_classprint_flag==3)
+  {
+    if (in_normal_prior_flag==1)
+    {
+      fprintf(fs,"\nclass df1b2_normal_prior_%s : ",text);
+      //in_normal_prior_flag=0;
+    }
+    else
+    {
+      fprintf(fs,"\nclass df1b2_normal_prior_%s : ",text);
+      //fprintf(fs,"\nclass df1b2quadratic_re_penalty_%s : ",text);
+    }
+    fprintf(fs,"public df1b2quadratic_re_penalty\n" 
+    "{\n"
+    "public:\n"
+    "  void get_Lxu(dmatrix& M);\n"
+    "  df1b2_normal_prior_%s(){old_style_flag=2;}\n"
+    "  void get_cM(void);\n"
+    "  void operator = (const df1b2matrix & M)\n"
+    "  {\n"
+    "    df1b2quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "};\n",text);
+    fprintf(fs,"\nclass df_normal_prior_%s : "
+      "public quadratic_re_penalty\n" 
+    "{\n"
+    "public:\n"
+    "  df_normal_prior_%s(){old_style_flag=2;}\n"
+    "  void get_cM(void);\n"
+    "  void operator = (const dvar_matrix & M)\n"
+    "  {\n"
+    "    quadratic_re_penalty::operator = (M);\n"
+    "  }\n"
+    "};\n",text,text);
+
+
+    /*
+     fprintf(fs1,"\nvoid df1b2quadratic_re_penalty_%s::get_Lxu(dmatrix& LXU)\n"
+    */
+    fprintf(fs1,"\nvoid df1b2_normal_prior_%s::get_Lxu(dmatrix& LXU)\n"
+    "{\n"
+     "  df1b2_parameters * mp=\n"
+     "    df1b2_parameters::get_df1b2_parameters_ptr();\n"
+     "  mp->evaluate_M();\n"
+     "  int rmin=Lxu->indexmin();\n"
+     "  int rmax=Lxu->indexmax();\n"
+     "  int cmin=1;\n"
+     "  int cmax=(*Lxu)(rmin).indexmax();\n"
+     "  if (cmax != LXU.indexmax())\n"
+     "  {\n"
+     "    cerr << \"Shape error in get_Lxu\" << endl;\n"
+     "    ad_exit(1);\n"
+     "  }\n"
+     "  \n"
+     "  for (int i=rmin;i<=rmax;i++)\n"
+     "  {\n"
+     "    int row=(*Lxu)(i,0);\n"
+     "    for (int j=cmin;j<=cmax;j++)\n"
+     "    {\n"
+     "      LXU(j,row)+=(*Lxu)(i,j);\n"
+     "    }\n"
+     "  }\n"
+     "}\n",text);
+     fprintf(fs1,"\nvoid df_normal_prior_%s::get_cM(void)\n"
+     "{\n"
+     "  model_parameters * mp=\n"
+     "    model_parameters::get_model_parameters_ptr();\n"
+     "  mp->evaluate_M();\n"
+     "}\n",text);      
+  }
+  
+  quadratic_classprint_flag=0;
+ 
+  if (fs)
+  {
+    fclose(fs);
+  }
+  fs=0;
+  if (fs1)
+  {
+    fclose(fs1);
+  }
+  fs1=0;
+  class_append_flag=1;
+}
Index: linad99/adglobl.cpp
===================================================================
--- linad99/adglobl.cpp	(revision 682)
+++ linad99/adglobl.cpp	(working copy)
@@ -17,6 +17,8 @@
  adtimer * ad_comm::ptm1=0;
  int ad_comm::bandwidth=0;
  adpvm_manager * ad_comm::pvm_manager=NULL;
+ __ADMBTHREAD__ adpthreads_manager * ad_comm::pthreads_manager=0;
+ __ADMBTHREAD__ int  adpthreads_manager::slave_number=0;
 
  int ad_comm::time_flag=0;
  adstring ad_comm::subdir;
Index: linad99/cbetai.cpp
===================================================================
--- linad99/cbetai.cpp	(revision 682)
+++ linad99/cbetai.cpp	(working copy)
@@ -7,6 +7,8 @@
 #include <fvar.hpp>
 #include <math.h>
 
+double betacf(const double a, const double b, const double x, int MAXIT);
+
 /** Incomplete beta function for constant objects.
     \param a \f$a\f$
     \param b \f$b\f$
Index: linad99/combv.cpp
===================================================================
--- linad99/combv.cpp	(revision 682)
+++ linad99/combv.cpp	(working copy)
@@ -10,7 +10,7 @@
 
 #include <fvar.hpp>
 
-dvariable gammln(const dvariable& xx);
+dvariable gammln(const prevariable& z);
 dvariable factln(const dvariable& n);
 double factln(double n);
 
Index: linad99/dcompressed.cpp
===================================================================
--- linad99/dcompressed.cpp	(revision 0)
+++ linad99/dcompressed.cpp	(working copy)
@@ -0,0 +1,43 @@
+
+/*
+ * $Id: dvector.cpp 422 2012-04-12 23:02:36Z johnoel $
+ *
+ * Author: David Fournier
+ * Copyright (c) 2008-2011 Regents of the University of California 
+ */
+/**
+ * \file
+ * Description not yet available.
+ */
+#include "fvar.hpp"
+
+  // this is for a symmetrixc matrix
+  dvector operator * (const dcompressed_triplet& _M,const dvector& _v)
+  {
+    ADUNCONST(dcompressed_triplet,M)
+    ADUNCONST(dvector,v)
+    
+    if (v.indexmin()!=1 ||
+         M.get_m() !=v.indexmax() )
+    {
+      cerr << "Indices do not match in "
+        " operator * (const dcompressed_triplet& _M,const dvector& _v)"
+        << endl;
+      ad_exit(1);
+    }
+    imatrix coords= M.get_coords();
+    dvector x= M.get_x();
+    dvector tmp(1,v.indexmax());
+    int mmin=x.indexmin();
+    int mmax=x.indexmax();
+    tmp.initialize();
+    for (int i=mmin;i<=mmax;i++)
+    {
+      tmp(coords(1,i))+=x(i)*v(coords(2,i));
+      if(coords(1,i)!=coords(2,i))
+        tmp(coords(2,i))+=x(i)*v(coords(1,i));
+    }
+     
+    return tmp;
+  } 
+    
Index: linad99/ddlist.cpp
===================================================================
--- linad99/ddlist.cpp	(revision 682)
+++ linad99/ddlist.cpp	(working copy)
@@ -39,8 +39,8 @@
 extern char otter_address5[];
 
 
-char* ddlist_space;
-char* ddlist_spacea;
+__ADMBTHREAD__ char* ddlist_space;
+__ADMBTHREAD__ char* ddlist_spacea;
 
 /**
  * Description not yet available.
Index: linad99/df12fun.cpp
===================================================================
--- linad99/df12fun.cpp	(revision 682)
+++ linad99/df12fun.cpp	(working copy)
@@ -762,6 +762,21 @@
     num_ind_var=0;
   }
 
+dvariable& dvariable::operator = (const df1_two_variable& v)
+{
+  const prevariable *px = df1_two_variable::ind_var[0];
+  const prevariable *py = df1_two_variable::ind_var[1];
+  const prevariable *pz = df1_two_variable::ind_var[2];
+  double  dfx = *v.get_u_x();
+  double  dfy = *v.get_u_y();
+  value(*this) = *v.get_u();
+
+  gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation3,
+      &(value(*this)),&(value(*px)),dfx,&(value(*py)),dfy);
+
+  return *this;
+}
+
 /**
  * Description not yet available.
  * \param
Index: linad99/df_file.cpp
===================================================================
--- linad99/df_file.cpp	(revision 682)
+++ linad99/df_file.cpp	(working copy)
@@ -186,6 +186,21 @@
     {
       sprintf(&cmpdif_file_name[0],"cmpdiff.%s",ad_random_part);
     }
+   
+    adstring tmpstring;
+    tmpstring=cmpdif_file_name;
+#if ( defined(USE_ADMPI) || defined(USE_PTHREADS))
+      add_slave_suffix(tmpstring);
+#endif // #if defined(USE_ADMPI)
+      //cout << tmpstring << endl;
+      if (::length(tmpstring)>100)
+      {
+        cerr << "Need to increase length of cmpdif_file_name"
+             << endl;
+        ad_exit(1);
+      }
+     strncpy(&cmpdif_file_name[0],tmpstring,100);
+
 #if defined (__MSVC32__) || defined (__WAT32__)
     file_ptr=open(cmpdif_file_name, O_RDWR | O_CREAT | O_TRUNC |
                      O_BINARY, S_IREAD | S_IWRITE);
Index: linad99/dfpool.cpp
===================================================================
--- linad99/dfpool.cpp	(revision 682)
+++ linad99/dfpool.cpp	(working copy)
@@ -21,14 +21,19 @@
 
   void my_do_nothing(void * t){}
 //ofstream xofs("allocation");
-vector_shape_pool * vector_shape::xpool = 
+__ADMBTHREAD__  vector_shape_pool * vector_shape::xpool = 0;
+__ADMBTHREAD__  vector_shape_pool * vector_shapex::xpool =0; 
+__ADMBTHREAD__  vector_shape_pool  * arr_link::xpool = 0;
+/*
+__ADMBTHREAD__  vector_shape_pool * vector_shape::xpool = 
     new vector_shape_pool(sizeof(vector_shape));
 
-vector_shape_pool * vector_shapex::xpool = 
+__ADMBTHREAD__  vector_shape_pool * vector_shapex::xpool = 
     new vector_shape_pool(sizeof(vector_shapex));
 
-vector_shape_pool  * arr_link::xpool = 
+__ADMBTHREAD__  vector_shape_pool  * arr_link::xpool = 
     new vector_shape_pool (sizeof(arr_link));
+*/
 
 vector_shape_pool::vector_shape_pool(void) : dfpool(sizeof(vector_shape))
 { ;}
@@ -69,7 +74,8 @@
 {  
   if (xpool==0) 
   {
-    xpool=new vector_shape_pool(sizeof(vector_shape));
+    xpool=new vector_shape_pool(sizeof(arr_link));
+    //xpool=new vector_shape_pool(sizeof(vector_shape));
   }
 # if defined(SAFE_ALL)
   if (n != xpool->size)
Index: linad99/dmat3.cpp
===================================================================
--- linad99/dmat3.cpp	(revision 682)
+++ linad99/dmat3.cpp	(working copy)
@@ -1,38 +1,22 @@
-/**
- * $Id: dmat3.cpp 789 2010-10-05 01:01:09Z johnoel $
- *
- * Author: David Fournier
- * Copyright (c) 2009-2012 ADMB Foundation
- */
+#define HOME_VERSION
+//COPYRIGHT (c) 1991 OTTER RESEARCH LTD
+
 #include "fvar.hpp"
 #include <math.h>
 #ifndef __ZTC__
 //#include <iomanip.h>
 #endif
-/**
-\def TINY
-A small number. Used to avoid divide by zero in the LU decomposition. Locally defined,
-undefined, redefined and undefined in this file.
-*/
 #define TINY 1.0e-20;
 
-void lubksb(dmatrix a, const ivector&  indx,dvector b);
-void ludcmp(const dmatrix& a, const ivector& indx, const double& d);
+void lubksb(dmatrix a,_CONST ivector&  indx,dvector b);
+void ludcmp(BOR_CONST dmatrix& a,BOR_CONST ivector& indx,BOR_CONST double& d);
 
-/** Inverse of a constant matrix by LU decomposition.
-    \ingroup matop
-    \param m1 A dmatrix, \f$M\f$, for which the inverse is to be computed.
-    \return A dmatrix containing \f$M^{-1}\f$.
-    \n\n The implementation of this algorithm was inspired by
-    "Numerical Recipes in C", 2nd edition,
-    Press, Teukolsky, Vetterling, Flannery, chapter 2
-*/
-dmatrix inv(const dmatrix& m1)
+dmatrix inv(_CONST dmatrix& m1)
 {
   double d;
   if (m1.rowmin()!=m1.colmin() || m1.rowmax() != m1.colmax())
   {
-    cerr << " Error in dmatrix inv(const dmatrix&) -- matrix not square \n";
+    cerr << " Error in dmatrix inv(_CONST dmatrix&) -- matrix not square \n";
   }
  
   dmatrix a(m1.rowmin(),m1.rowmax(),m1.rowmin(),m1.rowmax());
@@ -71,17 +55,38 @@
   return(y);
 }
 
-/** Inverse of a constant matrix by LU decomposition.
-    \param m1 A dmatrix, \f$M\f$, for which the inverse is to be computed.
-    \param _ln_det On return contains \f$|\log M|\f$
-    \param _sign
-    \return A dmatrix containing \f$M^{-1}\f$.
-    \n\n The implementation of this algorithm was inspired by
-    "Numerical Recipes in C", 2nd edition,
-    Press, Teukolsky, Vetterling, Flannery, chapter 2
-*/
-dmatrix inv(const dmatrix& m1,const double& _ln_det, const int& _sgn)
+dmatrix inv_with_lu(const dmatrix& a,const ivector & indx,double d)
 {
+  if (a.rowmin()!=a.colmin() || a.rowmax() != a.colmax())
+  {
+    cerr << " Error in dmatrix inv(_CONST dmatrix&) -- matrix not square \n";
+  }
+ 
+
+  dmatrix y(a.rowmin(),a.rowmax(),a.rowmin(),a.rowmax());
+  dvector col(a.rowmin(),a.rowmax());
+  int i;
+
+  for (int j=a.rowmin(); j<=a.rowmax(); j++)
+  {
+    for (i=a.rowmin(); i<=a.rowmax(); i++)
+    {
+      col[i]=0;
+    }
+    col[j]=1;
+
+    lubksb(a,indx,col);
+  
+    for (i=a.rowmin(); i<=a.rowmax(); i++)
+    {
+      y[i][j]=col[i];
+    }
+  }
+  return(y);
+}
+
+dmatrix inv(_CONST dmatrix& m1,const double& _ln_det, const int& _sgn)
+{
   double d;
   double& ln_det=(double&)(_ln_det);
   ln_det=0.0;
@@ -89,7 +94,7 @@
   
   if (m1.rowmin()!=m1.colmin() || m1.rowmax() != m1.colmax())
   {
-    cerr << " Error in dmatrix inv(const dmatrix&) -- matrix not square \n";
+    cerr << " Error in dmatrix inv(_CONST dmatrix&) -- matrix not square \n";
   }
  
   dmatrix a(m1.rowmin(),m1.rowmax(),m1.rowmin(),m1.rowmax());
@@ -157,15 +162,8 @@
   return(y);
 }
 
-/** Lu decomposition of a constant matrix.
-    \param _a  A dmatrix; replaced by the by its resulting LU decomposition
-    \param _indx An ivector containing the row permutations generated by partial pivoting
-    \param _d A double containing -1 or +1 depending whether the number of row interchanges was even or odd, repectively.
-    \n\n The implementation of this algorithm was inspired by
-    "Numerical Recipes in C", 2nd edition,
-    Press, Teukolsky, Vetterling, Flannery, chapter 2
-*/
-void ludcmp(const dmatrix& _a, const ivector& _indx, const double& _d)
+
+void ludcmp(BOR_CONST dmatrix& _a,BOR_CONST ivector& _indx,BOR_CONST double& _d)
 {
   int i=0;
   int imax=0;
@@ -266,15 +264,7 @@
 
 #define TINY 1.0e-50;
 
-/** LU decomposition. Used to set up determinant computation.
-    \param _a  A dmatrix; replaced by the by its resulting LU decomposition
-    \param _indx An ivector containing the row permutations generated by partial pivoting
-    \param _d A double containing -1 or +1 depending whether the number of row interchanges was even or odd, repectively.
-    \n\n The implementation of this algorithm was inspired by
-    "Numerical Recipes in C", 2nd edition,
-    Press, Teukolsky, Vetterling, Flannery, chapter 2
-*/
-void ludcmp_det(const dmatrix& _a, const ivector& _indx, const double& _d)
+void ludcmp_det(BOR_CONST dmatrix& _a,BOR_CONST ivector& _indx,BOR_CONST double& _d)
 {
   int i,imax,j,k,n;
   double& d=(double&)_d;
@@ -369,21 +359,49 @@
 }
 
 
-/** LU decomposition back susbstitution alogrithm for constant object.
-    \param a A dmatrix containing LU decomposition of input matrix. \f$a\f$. 
-    \param indx Permutation vector from ludcmp.
-    \param b A dvector containing the RHS, \f$b\f$ of the linear equation
-    \f$A\cdot X = B\f$, to be solved, and containing on return the solution vector \f$X\f$.
 
-    \n\n The implementation of this algorithm was inspired by
-    "Numerical Recipes in C", 2nd edition,
-    Press, Teukolsky, Vetterling, Flannery, chapter 2
+void lubksb(dmatrix a,_CONST ivector& indx,dvector b)
+{
+  int i,ii=0,ip,j,iiflag=0;
+  double sum;
+  int lb=a.colmin();
+  int ub=a.colmax();
+  for (i=lb;i<=ub;i++)
+  {
+    ip=indx[i];
+    sum=b[ip];
+    b[ip]=b[i];
+    if (iiflag)
+    {
+      for (j=ii;j<=i-1;j++)
+      {
+        sum -= a[i][j]*b[j];
+      }
+    }
+    else if ( sum )
+    {
+      ii=i;
+      iiflag=1;
+    }
+    b[i]=sum;
+  }
+ 
+  for (i=ub;i>=lb;i--) 
+  {
+    sum=b[i];
+    for (j=i+1;j<=ub;j++) 
+    {                        // !!! remove to show bug
+      sum -= a[i][j]*b[j];
+    }                        // !!! remove to show bug
+    b[i]=sum/a[i][i];
+  }
+}
 
-    \deprecated Scheduled for replacement by 2010.
-*/
-void lubksb(dmatrix a, const ivector& indx, dvector b)
+dvector Lubksb(const dmatrix& a,const ivector&  indx,const dvector&  bb)
 {
   int i,ii=0,ip,j,iiflag=0;
+  dvector b(bb.indexmin(),bb.indexmax());
+  b=bb;
   double sum;
   int lb=a.colmin();
   int ub=a.colmax();
@@ -416,19 +434,10 @@
     }                        // !!! remove to show bug
     b[i]=sum/a[i][i];
   }
+  return b;
 }
 
-/** Compute determinant of a constant matrix.
-    \ingroup matop
-    \param m1 A dmatrix, \f$M\f$, for which the determinant is computed.
-    \return A double containing \f$|M|\f$.
-    \n\n The implementation of this algorithm was inspired by
-    "Numerical Recipes in C", 2nd edition,
-    Press, Teukolsky, Vetterling, Flannery, chapter 2
-
-    \deprecated Scheduled for replacement by 2010.
-*/
-double det(const dmatrix& m1)
+double det(_CONST dmatrix& m1)
 {
   double d;
   dmatrix a(m1.rowmin(),m1.rowmax(),m1.rowmin(),m1.rowmax());
@@ -457,17 +466,7 @@
   return(d);
 }
 
-/** Compute log determinant of a constant matrix.
-    \param m1 A dmatrix, \f$M\f$, for which the determinant is computed.
-    \param _sgn
-    \return A double containing \f$|\log(M)|\f$.
-    \n\n The implementation of this algorithm was inspired by
-    "Numerical Recipes in C", 2nd edition,
-    Press, Teukolsky, Vetterling, Flannery, chapter 2
-
-    \deprecated Scheduled for replacement by 2010.
-*/
-double ln_det(const dmatrix& m1, const int& _sgn)
+double ln_det(_CONST dmatrix& m1,BOR_CONST int& _sgn)
 {
   double d;
   int& sgn=(int&)_sgn;
@@ -522,14 +521,8 @@
   return(ln_det);
 }
 
-/** LU decomposition. 
-    \deprecated This function may be completely unused?
-
-    \n\n The implementation of this algorithm was inspired by
-    "Numerical Recipes in C", 2nd edition,
-    Press, Teukolsky, Vetterling, Flannery, chapter 2
-*/
-void ludcmp_index(const dmatrix& _a, const ivector& _indx, const double& _d)
+void ludcmp_index(BOR_CONST dmatrix& _a,BOR_CONST ivector& _indx,
+  BOR_CONST double& _d)
 {
   int i=0;
   int imax=0;
@@ -584,7 +577,6 @@
       a[i][j]=sum;
     }
     big=0.0;
-
     for (i=j;i<=ub;i++) 
     {
       sum=a[i][j];
@@ -633,3 +625,140 @@
 #undef TINY
 
 
+dmatrix ludcmp(const dmatrix& _a,const ivector& _indx,
+  const double& _det,const double& _sgn, const double& _d)
+{
+  const double TINY=1.e-60;
+  int i=0;
+  int imax=0;
+  int j=0;
+  int k=0;
+  int n=0;
+  double& d=(double&)_d;
+  double& det=(double&)_det;
+  double& sgn=(double&)_sgn;
+  dmatrix& a=(dmatrix&)_a;
+  ivector& indx=(ivector&)_indx;
+
+  n=a.colsize();
+  int lb=a.colmin();
+  int ub=a.colmax();
+
+  double big,dum,sum,temp;
+
+  dvector vv(lb,ub);
+
+
+  d=1.0;
+
+  for (i=lb;i<=ub;i++)
+  {
+    big=0.0;
+    for (j=lb;j<=ub;j++)
+    {
+      temp=fabs(a[i][j]);
+      if (temp > big)
+      {
+        big=temp;
+      }
+    }
+    if (big == 0.0) 
+    {
+      cerr << "Error in matrix inverse -- matrix singular in inv(dmatrix)\n";
+    }
+    vv[i]=1.0/big;
+  }
+
+
+
+  for (j=lb;j<=ub;j++)
+  {
+    for (i=lb;i<j;i++) 
+    {
+      sum=a[i][j];
+      for (k=lb;k<i;k++)
+      {
+        sum -= a[i][k]*a[k][j];
+      }
+      a[i][j]=sum;
+    }
+    big=0.0;
+    for (i=j;i<=ub;i++) 
+    {
+      sum=a[i][j];
+      for (k=lb;k<j;k++)
+      {
+        sum -= a[i][k]*a[k][j];
+      }
+      a[i][j]=sum;
+      dum=vv[i]*fabs(sum);
+      if ( dum >= big)
+      {
+        big=dum;
+        imax=i;
+      }
+    }
+    if (j != imax)
+    {
+      for (k=lb;k<=ub;k++)
+      {
+        dum=a[imax][k];
+        a[imax][k]=a[j][k];
+        a[j][k]=dum;
+      }
+      d = -d;
+      vv[imax]=vv[j];
+    }
+    indx[j]=imax;
+
+    if (a[j][j] == 0.0)
+    {
+      a[j][j]=TINY;
+    }
+
+    if (j != n)
+    {
+      dum=1.0/(a[j][j]);
+      for (i=j+1;i<=ub;i++)
+      {
+        a[i][j] *= dum;
+      }
+    }
+  }
+
+  double ln_det=0.0;
+   
+  if (d>.1) 
+  {
+    sgn=1;
+  }
+  else if (d<-0.1)
+  {
+    sgn=-1;
+  }
+  else
+  {
+    sgn=0;
+  }
+  for (int j=a.rowmin();j<=a.rowmax();j++)
+  {
+    if (a(j,j)>0)
+    {
+      ln_det+=log(a[j][j]);
+    }
+    else if (a(j,j)<0)
+    {
+      sgn=-sgn;
+      ln_det+=log(-a[j][j]);
+    }
+    else
+    {
+      sgn=0;
+    }
+  }
+
+  return a;
+}
+#undef HOME_VERSION
+
+
Index: linad99/dmat34.cpp
===================================================================
--- linad99/dmat34.cpp	(revision 682)
+++ linad99/dmat34.cpp	(working copy)
@@ -25,7 +25,7 @@
 
 
 /** Solve a linear system using LU decomposition. */
-dvector csolve(const dmatrix& aa,const dvector& z)
+dvector old_csolve(const dmatrix& aa,const dvector& z)
 {
   double ln_unsigned_det;
   double sign;
Index: linad99/eigen_dmat.cpp
===================================================================
--- linad99/eigen_dmat.cpp	(revision 0)
+++ linad99/eigen_dmat.cpp	(working copy)
@@ -0,0 +1,315 @@
+/*
+ * $Id: eigen_dmat.cpp 494 2012-06-13 20:41:16Z johnoel $
+ *
+ * Copyright (c) 2009-2012 ADMB foundation
+ */
+/**
+ * \file
+ * Contains routines to find eigenvectors and eigenvalues
+ * for constant types.
+ */
+#include <fvar.hpp>
+
+void eigens(const dmatrix & m, const dmatrix & _evecs,
+	    const dvector & _evals);
+
+/**
+ * \ingroup eigen
+ * Eigenvalues
+ * \param m \f$m\f$
+ * \return a variable vector containing the
+ *         eigenvalues of \f$m\f$.
+ */
+dvector eigenvalues(const dmatrix &m)
+{
+   if (m.rowsize() != m.colsize())
+   {
+      cerr <<
+	 "error -- non square matrix passed to dvector eigenvalues(const dmatrix& m)\n";
+      ad_exit(1);
+   }
+
+   int rmin = m.rowmin();
+   int rmax = m.rowmax();
+
+   dmatrix evecs(rmin, rmax, rmin, rmax);
+   dvector evals(rmin, rmax);
+
+   eigens(m, evecs, evals);
+
+   return evals;
+}
+
+/**
+ * \ingroup eigen
+ * Eigenvectors
+ * \param m \f$m\f$
+ * \return a variable matrix with the
+ *         eigenvectors of \f$m\f$ stored in its columns.
+ */
+dmatrix eigenvectors(const dmatrix &m)
+{
+   if (m.rowsize() != m.colsize())
+   {
+      cerr <<
+	 "error -- non square matrix passed to dmatrix eigenvectors(const dmatrix& m)\n";
+      ad_exit(1);
+   }
+
+   int rmin = m.rowmin();
+   int rmax = m.rowmax();
+
+   dmatrix evecs(rmin, rmax, rmin, rmax);
+   dvector evals(rmin, rmax);
+
+   eigens(m, evecs, evals);
+
+   return evecs;
+}
+
+/**
+ * \ingroup eigen
+ * Eigenvectors and Eigenvalues
+ * \param m \f$m\f$
+ * \param _diag
+ * \return a constant matrix with the
+ *         eigenvectors of \f$m\f$ stored in its columns.
+ * On return _diag contains the eigenvalues of \f$m\f$.
+ */
+dmatrix eigenvectors(const dmatrix &m, const dvector &_diag)
+{
+   ADUNCONST(dvector, diag) if (m.rowsize() != m.colsize())
+   {
+      cerr << "error -- non square matrix passed to dmatrix "
+	 << "eigenvectors(const dmatrix& m, const dvector& _diag)\n";
+      ad_exit(1);
+   }
+
+   int rmin = m.rowmin();
+   int rmax = m.rowmax();
+
+   dmatrix evecs(rmin, rmax, rmin, rmax);
+   dvector evals(rmin, rmax);
+   eigens(m, evecs, evals);
+   diag = evals;
+
+   return evecs;
+}
+
+
+/**
+ * \ingroup eigen
+ * Eigenvector and Eigenvalue algorithm
+ * \param m \f$m\f$
+ * \param _evecs
+ * \param _evals
+ *
+ * \return
+ * On return _evecs will be a constant matrix with the
+ *  eigenvectors of \f$m\f$ stored in its columns.
+ * On return _evals will be a constant vector containing the
+ *  eigenvalues of \f$m\f$.
+ * 
+ * \n\n Cephes Math Library Release 2.1:  December, 1988
+ * Copyright 1984, 1987, 1988 by Stephen L. Moshier 
+ * Direct inquiries to 30 Frost Street, Cambridge, MA 02140
+ */
+void eigens(const dmatrix & m, const dmatrix & _evecs,
+	    const dvector & _evals)
+{
+   ADUNCONST(dmatrix, evecs)
+      ADUNCONST(dvector, evals) if (m.rowsize() != m.colsize())
+   {
+      cerr << "error -- non square matrix passed to "
+	 <<
+	 "void (const dmatirx& m, const dmatirx& evecs, const dvector& evals)\n";
+      ad_exit(1);
+   }
+   if ((m.rowsize() != evecs.rowsize())
+       || (m.colsize() != evecs.colsize()))
+   {
+      cerr << "error -- eigenvector array not compatible with matrix in "
+	 <<
+	 "void (const dmatirx& m, const dmatirx& evecs, const dvector& evals)\n";
+      ad_exit(1);
+   }
+   if (m.rowsize() != evals.size())
+   {
+      cerr << "error -- eigenvalue array not compatible with matrix in "
+	 <<
+	 "void (const dmatirx& m, const dmatirx& evecs, const dvector& evals)\n";
+      ad_exit(1);
+   }
+
+   int evecslb = evecs.rowmin();
+   int evalslb = evals.indexmin();
+
+   int N = m.colsize();
+
+   dmatrix mat = symmetrize(m);
+
+   //shift m, evecs, and evals so they are compatible with algorithm
+   mat.rowshift(0);
+   mat.colshift(0);
+   evecs.rowshift(0);
+   evecs.colshift(0);
+   evals.shift(0);
+
+
+   //mat[ row, column ] = A[ (row*row+row)/2 + column ]
+   dvector A(0, N * (N + 1) / 2);
+
+   for (int i = 0; i < N; i++)
+   {
+      for (int j = 0; j <= i; j++)
+      {
+	 A((i * i + i) / 2 + j) = mat(i, j);
+      }
+   }
+
+   dvector RR(0, N * N - 1);
+   dvector E(0, N - 1);
+
+   // run cephes code
+   int IND, L, LL, LM, M, MM, MQ, I, J, IA, LQ;
+   int IQ, IM, IL, NLI, NMI;
+   double ANORM, ANORMX, AIA, THR, ALM, ALL, AMM, X, Y;
+   double SINX, SINX2, COSX, COSX2, SINCS, AIL, AIM;
+   double RLI, RMI;
+   static double RANGE = 1.0e-10;	/*3.0517578e-5; */
+
+
+   /* Initialize identity matrix in RR[] */
+   for (J = 0; J < N * N; J++)
+      RR[J] = 0.0;
+   MM = 0;
+   for (J = 0; J < N; J++)
+   {
+      RR[MM + J] = 1.0;
+      MM += N;
+   }
+
+   ANORM = 0.0;
+   for (I = 0; I < N; I++)
+   {
+      for (J = 0; J < N; J++)
+      {
+	 if (I != J)
+	 {
+	    IA = I + (J * J + J) / 2;
+	    AIA = A[IA];
+	    ANORM += AIA * AIA;
+	 }
+      }
+   }
+   if (ANORM <= 0.0)
+      goto done;
+   ANORM = sqrt(ANORM + ANORM);
+   ANORMX = ANORM * RANGE / N;
+   THR = ANORM;
+
+   while (THR > ANORMX)
+   {
+      THR = THR / N;
+
+      do
+      {				/* while IND != 0 */
+	 IND = 0;
+
+	 for (L = 0; L < N - 1; L++)
+	 {
+
+	    for (M = L + 1; M < N; M++)
+	    {
+	       MQ = (M * M + M) / 2;
+	       LM = L + MQ;
+	       ALM = A[LM];
+	       if (fabs(ALM) < THR)
+		  continue;
+
+	       IND = 1;
+	       LQ = (L * L + L) / 2;
+	       LL = L + LQ;
+	       MM = M + MQ;
+	       ALL = A[LL];
+	       AMM = A[MM];
+	       X = (ALL - AMM) / 2.0;
+	       Y = -ALM / sqrt(ALM * ALM + X * X);
+	       if (X < 0.0)
+		  Y = -Y;
+	       SINX = Y / sqrt(2.0 * (1.0 + sqrt(1.0 - Y * Y)));
+	       SINX2 = SINX * SINX;
+	       COSX = sqrt(1.0 - SINX2);
+	       COSX2 = COSX * COSX;
+	       SINCS = SINX * COSX;
+
+	       /*       ROTATE L AND M COLUMNS */
+	       for (I = 0; I < N; I++)
+	       {
+		  IQ = (I * I + I) / 2;
+		  if ((I != M) && (I != L))
+		  {
+		     if (I > M)
+			IM = M + IQ;
+		     else
+			IM = I + MQ;
+		     if (I >= L)
+			IL = L + IQ;
+		     else
+			IL = I + LQ;
+		     AIL = A[IL];
+		     AIM = A[IM];
+		     X = AIL * COSX - AIM * SINX;
+		     A[IM] = AIL * SINX + AIM * COSX;
+		     A[IL] = X;
+		  }
+		  NLI = N * L + I;
+		  NMI = N * M + I;
+		  RLI = RR[NLI];
+		  RMI = RR[NMI];
+		  RR[NLI] = RLI * COSX - RMI * SINX;
+		  RR[NMI] = RLI * SINX + RMI * COSX;
+	       }
+
+	       X = 2.0 * ALM * SINCS;
+	       A[LL] = ALL * COSX2 + AMM * SINX2 - X;
+	       A[MM] = ALL * SINX2 + AMM * COSX2 + X;
+	       A[LM] = (ALL - AMM) * SINCS + ALM * (COSX2 - SINX2);
+	    }			/* for M=L+1 to N-1 */
+	 }			/* for L=0 to N-2 */
+
+      }
+      while (IND != 0);
+
+   }				/* while THR > ANORMX */
+
+ done:;
+
+   /* Extract eigenvalues from the reduced matrix */
+   L = 0;
+   for (J = 1; J <= N; J++)
+   {
+      L = L + J;
+      E[J - 1] = A[L - 1];
+   }
+
+   // end of cephes code
+
+   //put data into evecs and evals
+   //EV[ n*i+j ] = evecs[i][j]
+   for (int i = 0; i < N; i++)
+   {
+      for (int j = 0; j < N; j++)
+      {
+	 evecs(j, i) = RR[N * i + j];
+      }
+   }
+
+   evals = E;
+
+   //shift evecs and evals back
+   evecs.rowshift(evecslb);
+   evecs.colshift(evecslb);
+   evals.shift(evalslb);
+
+}
Index: linad99/eigen_dvar.cpp
===================================================================
--- linad99/eigen_dvar.cpp	(revision 0)
+++ linad99/eigen_dvar.cpp	(working copy)
@@ -0,0 +1,287 @@
+/*
+ * $Id: eigen_dvar.cpp 494 2012-06-13 20:41:16Z johnoel $
+ *
+ * Copyright (c) 2009-2012 ADMB foundation
+ */
+/**
+ * \file
+ * Contains routines to find eigenvectors and eigenvalues
+ * for variable types.
+ */
+
+#include <fvar.hpp>
+
+void eigens (const dvar_matrix & m, const dvar_matrix & _evecs,
+	     const dvar_vector & _evals);
+
+/**
+ * \ingroup eigen
+ * Eigenvalues
+ * \param m \f$m\f$
+ * \return a variable vector containing the
+ *         eigenvalues of \f$m\f$.
+ */
+dvar_vector eigenvalues(const dvar_matrix &m)
+{
+  if (m.rowsize () != m.colsize ())
+    {
+      cerr <<
+	"error -- non square matrix passed to dvector eigenvalues(const dmatrix& m)\n";
+      ad_exit (1);
+    }
+
+  int rmin = m.rowmin ();
+  int rmax = m.rowmax ();
+
+  dvar_matrix evecs (rmin, rmax, rmin, rmax);
+  dvar_vector evals (rmin, rmax);
+
+  eigens (m, evecs, evals);
+
+  return evals;
+}
+
+/**
+ * \ingroup eigen
+ * Eigenvectors
+ * \param m \f$m\f$
+ * \return a variable matrix with the
+ *         eigenvectors of \f$m\f$ stored in its columns.
+ */
+dvar_matrix eigenvectors(const dvar_matrix &m)
+{
+  if (m.rowsize () != m.colsize ())
+    {
+      cerr <<
+	"error -- non square matrix passed to dmatrix eigenvectors(const dmatrix& m)\n";
+      ad_exit (1);
+    }
+
+  int rmin = m.rowmin ();
+  int rmax = m.rowmax ();
+
+  dvar_matrix evecs (rmin, rmax, rmin, rmax);
+  dvar_vector evals (rmin, rmax);
+
+  eigens (m, evecs, evals);
+
+  return evecs;
+}
+
+/**
+ * \ingroup eigen
+ * Eigenvector and Eigenvalue algorithm
+ * \param m \f$m\f$
+ * \param _evecs
+ * \param _evals
+ *
+ * \return
+ * On return _evecs will be a variable matrix with the
+ *  eigenvectors of \f$m\f$ stored in its columns.
+ * On return _evals will be a variable vector containing the
+ *  eigenvalues of \f$m\f$.
+ * 
+ * \n\n Cephes Math Library Release 2.1:  December, 1988
+ * Copyright 1984, 1987, 1988 by Stephen L. Moshier 
+ * Direct inquiries to 30 Frost Street, Cambridge, MA 02140
+ */
+void eigens (const dvar_matrix & m, const dvar_matrix & _evecs,
+	const dvar_vector & _evals)
+{
+  ADUNCONST (dvar_matrix, evecs)
+    ADUNCONST (dvar_vector, evals) if (m.rowsize () != m.colsize ())
+    {
+      cerr << "error -- non square matrix passed to "
+	<<
+	"void (const dmatirx& m, const dmatirx& evecs, const dvector& evals)\n";
+      ad_exit (1);
+    }
+  if ((m.rowsize () != evecs.rowsize ())
+      || (m.colsize () != evecs.colsize ()))
+    {
+      cerr << "error -- eigenvector array not compatible with matrix in "
+	<<
+	"void (const dmatirx& m, const dmatirx& evecs, const dvector& evals)\n";
+      ad_exit (1);
+    }
+  if (m.rowsize () != evals.size ())
+    {
+      cerr << "error -- eigenvalue array not compatible with matrix in "
+	<<
+	"void (const dmatirx& m, const dmatirx& evecs, const dvector& evals)\n";
+      ad_exit (1);
+    }
+
+  int evecslb = evecs.rowmin();
+  int evalslb = evals.indexmin();
+
+  int N = m.colsize ();
+
+  dvar_matrix mat = symmetrize (m);
+
+  //shift m, evecs, and evals so they are compatible with algorithm
+  mat.rowshift (0);
+  mat.colshift (0);
+  evecs.rowshift (0);
+  evecs.colshift (0);
+  evals.shift (0);
+
+
+  //mat[ row, column ] = A[ (row*row+row)/2 + column ]
+  dvar_vector A (0, N * (N + 1) / 2);
+
+  for (int i = 0; i < N; i++)
+    {
+      for (int j = 0; j <= i; j++)
+	{
+	  A ((i * i + i) / 2 + j) = mat (i, j);
+	}
+    }
+
+  dvar_vector RR (0, N * N - 1);
+  dvar_vector E (0, N - 1);
+
+  // run cephes code
+  int IND, L, LL, LM, M, MM, MQ, I, J, IA, LQ;
+  int IQ, IM, IL, NLI, NMI;
+  dvariable ANORM, ANORMX, AIA, THR, ALM, ALL, AMM, X, Y;
+  dvariable SINX, SINX2, COSX, COSX2, SINCS, AIL, AIM;
+  dvariable RLI, RMI;
+  static double RANGE = 1.0e-10;	/*3.0517578e-5; */
+
+
+  /* Initialize identity matrix in RR[] */
+  for (J = 0; J < N * N; J++)
+    RR[J] = 0.0;
+  MM = 0;
+  for (J = 0; J < N; J++)
+    {
+      RR[MM + J] = 1.0;
+      MM += N;
+    }
+
+  ANORM = 0.0;
+  for (I = 0; I < N; I++)
+    {
+      for (J = 0; J < N; J++)
+	{
+	  if (I != J)
+	    {
+	      IA = I + (J * J + J) / 2;
+	      AIA = A[IA];
+	      ANORM += AIA * AIA;
+	    }
+	}
+    }
+  if (ANORM <= 0.0)
+    goto done;
+  ANORM = sqrt (ANORM + ANORM);
+  ANORMX = ANORM * RANGE / N;
+  THR = ANORM;
+
+  while (THR > ANORMX)
+    {
+      THR = THR / N;
+
+      do
+	{			/* while IND != 0 */
+	  IND = 0;
+
+	  for (L = 0; L < N - 1; L++)
+	    {
+
+	      for (M = L + 1; M < N; M++)
+		{
+		  MQ = (M * M + M) / 2;
+		  LM = L + MQ;
+		  ALM = A[LM];
+		  if (fabs (ALM) < THR)
+		    continue;
+
+		  IND = 1;
+		  LQ = (L * L + L) / 2;
+		  LL = L + LQ;
+		  MM = M + MQ;
+		  ALL = A[LL];
+		  AMM = A[MM];
+		  X = (ALL - AMM) / 2.0;
+		  Y = -ALM / sqrt (ALM * ALM + X * X);
+		  if (X < 0.0)
+		    Y = -Y;
+		  SINX = Y / sqrt (2.0 * (1.0 + sqrt (1.0 - Y * Y)));
+		  SINX2 = SINX * SINX;
+		  COSX = sqrt (1.0 - SINX2);
+		  COSX2 = COSX * COSX;
+		  SINCS = SINX * COSX;
+
+		  /*     ROTATE L AND M COLUMNS */
+		  for (I = 0; I < N; I++)
+		    {
+		      IQ = (I * I + I) / 2;
+		      if ((I != M) && (I != L))
+			{
+			  if (I > M)
+			    IM = M + IQ;
+			  else
+			    IM = I + MQ;
+			  if (I >= L)
+			    IL = L + IQ;
+			  else
+			    IL = I + LQ;
+			  AIL = A[IL];
+			  AIM = A[IM];
+			  X = AIL * COSX - AIM * SINX;
+			  A[IM] = AIL * SINX + AIM * COSX;
+			  A[IL] = X;
+			}
+		      NLI = N * L + I;
+		      NMI = N * M + I;
+		      RLI = RR[NLI];
+		      RMI = RR[NMI];
+		      RR[NLI] = RLI * COSX - RMI * SINX;
+		      RR[NMI] = RLI * SINX + RMI * COSX;
+		    }
+
+		  X = 2.0 * ALM * SINCS;
+		  A[LL] = ALL * COSX2 + AMM * SINX2 - X;
+		  A[MM] = ALL * SINX2 + AMM * COSX2 + X;
+		  A[LM] = (ALL - AMM) * SINCS + ALM * (COSX2 - SINX2);
+		}		/* for M=L+1 to N-1 */
+	    }			/* for L=0 to N-2 */
+
+	}
+      while (IND != 0);
+
+    }				/* while THR > ANORMX */
+
+done:;
+
+  /* Extract eigenvalues from the reduced matrix */
+  L = 0;
+  for (J = 1; J <= N; J++)
+    {
+      L = L + J;
+      E[J - 1] = A[L - 1];
+    }
+
+  // end of cephes code
+
+
+  //put data into evecs and evals
+  //EV[ n*i+j ] = evecs[i][j]
+  for (int i = 0; i < N; i++)
+    {
+      for (int j = 0; j < N; j++)
+	{
+	  evecs (j, i) = RR[N * i + j];
+	}
+    }
+
+  evals = E;
+
+  //shift evecs and evals back
+  evecs.rowshift (evecslb);
+  evecs.colshift (evecslb);
+  evals.shift (evalslb);
+
+}
Index: linad99/fmm.cpp
===================================================================
--- linad99/fmm.cpp	(revision 682)
+++ linad99/fmm.cpp	(working copy)
@@ -32,6 +32,14 @@
  * Description not yet available.
  * \param
  */
+fmm::fmm(void)
+{
+  disk_save=0;
+  ctlc_flag = 0;
+  n=0;
+  fbest=1.e+100;
+}
+
 fmm::fmm(int nvar,int _disk_save)
 : w(1,4*nvar), funval(1,10),
   xx(0,nvar), gbest(0,nvar), xsave(0,nvar), gsave(0,nvar)
@@ -41,6 +49,16 @@
   ctlc_flag = 0;
   n = nvar;
   fbest=1.e+100;
-//  cout << " In fmm::fmm(int nvar) nvar = " << nvar 
-//       << " and n = " << n << "\n";
 }
+
+void fmm::allocate(int nvar,int _disk_save)
+{
+  w.allocate(1,4*nvar); funval.allocate(1,10);
+  xx.allocate(0,nvar); gbest.allocate(0,nvar);
+  xsave.allocate(0,nvar); gsave.allocate(0,nvar);
+  disk_save=_disk_save;
+  if (!disk_save) h.allocate(nvar); 
+  ctlc_flag = 0;
+  n = nvar;
+  fbest=1.e+100;
+}
Index: linad99/fmmt1.cpp
===================================================================
--- linad99/fmmt1.cpp	(revision 682)
+++ linad99/fmmt1.cpp	(working copy)
@@ -8,6 +8,7 @@
  * \file
  * Description not yet available.
  */
+#define HOME_VERSION
 #include <fvar.hpp>
 
 /**
@@ -32,19 +33,23 @@
  * Description not yet available.
  * \param
  */
+void fmmt1::allocate(int nvar,int _xm)
+{
+  w.allocate(1,4*nvar); funval.allocate(1,10);
+  xx.allocate(0,nvar); gbest.allocate(0,nvar); xsave.allocate(0,nvar);
+  gsave.allocate(0,nvar);xstep.allocate(0,_xm+1,1,nvar);
+  xy.allocate(0,_xm+1,1,nvar); xrho.allocate(0,_xm+1); 
+  xold.allocate(1,nvar); gold.allocate(1,nvar); rrr.allocate(1,nvar);
+  ctlc_flag = 0;
+  n = nvar;
+  xm=_xm;
+  xrho.initialize();
+}
 fmmt1::fmmt1(int nvar,int _xm)
-: w(1,4*nvar),
-  funval(1,10),
-  xstep(0,_xm+1,1,nvar),
-  xrho(0,_xm+1), 
-  rrr(1,nvar),
-  xy(0,_xm+1,1,nvar),
-  xold(1,nvar),
-  gold(1,nvar),
-  xx(0,nvar),
-  gbest(0,nvar),
-  xsave(0,nvar),
-  gsave(0,nvar)
+: w(1,4*nvar), funval(1,10),
+  xx(0,nvar), gbest(0,nvar), xsave(0,nvar), gsave(0,nvar) ,
+  xstep(0,_xm+1,1,nvar), xy(0,_xm+1,1,nvar), xrho(0,_xm+1), 
+  xold(1,nvar), gold(1,nvar), rrr(1,nvar) 
 {
   ctlc_flag = 0;
   n = nvar;
@@ -53,3 +58,10 @@
 //  cout << " In fmm::fmm(int nvar) nvar = " << nvar 
 //       << " and n = " << n << "\n";
 }
+fmmt1::fmmt1(void)
+{
+  ctlc_flag = 0;
+  n = 0;
+  xm=0;
+}
+#undef HOME_VERSION
Index: linad99/fvar.hpp
===================================================================
--- linad99/fvar.hpp	(revision 682)
+++ linad99/fvar.hpp	(working copy)
@@ -2,13 +2,13 @@
  * $Id$
  *
  * Author: David Fournier
- * Copyright (c) 2008-2012 Regents of the University of California
+ * Copyright (c) 2008-2011 Regents of the University of California
+ * 
+ * License:
  *
  * ADModelbuilder and associated libraries and documentations are
  * provided under the general terms of the "New BSD" license
  * 
- * License:
- * 
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
  * met:
@@ -38,135 +38,154 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */
-#ifndef FVAR_HPP
-#define FVAR_HPP
 /** \file fvar.hpp
 AUTODIF classes.
-Class definitions for reverse mode automatic differentiation.
-Function prototypes for math functions.
-Macro definitions.
+A more detailed description might someday be written.
 */
 
-#include <math.h>
 // Borrow definition of M_PI from GCC
 #ifndef M_PI
-#   define M_PI 3.14159265358979323846
+  #define M_PI 3.14159265358979323846
 #endif
 #ifndef PI
-#   define PI 3.14159265358979323846
+  #define PI 3.14159265358979323846
 #endif
 
+#if defined(__MSVC32__) || defined(__MINGW32__) || defined(__MINGW64__)
+#  define sleep(n) Sleep(1000 * n)
+#endif
+
 #if defined(__GNUDOS__)
-#   if defined(__GNUC__)
-#      if (__GNUC__ < 3)
-#         pragma interface
-#      endif
-#   else
-#      pragma interface
-#   endif
+  #if defined(__GNUC__)
+    #if (__GNUC__ < 3)
+      #pragma interface
+    #endif
+  #else
+    #pragma interface
+  #endif
 #endif
 
 
-#if defined(_MSC_VER)
-#   if defined(__MSVC32__)
-#      undef __MSVC32__
-#   endif
-#   if (_MSC_VER>=1200  && _MSC_VER<1300)
+#if defined(_MSC_VER) 
+#  if defined(__MSVC32__)
+#    undef __MSVC32__
+#  endif
+#  if (_MSC_VER>=1200  && _MSC_VER<1300)
 #      define __MSVC32__ 6
-#   endif
-#   if (_MSC_VER>=1300  && _MSC_VER<1400)
+#  endif
+#  if (_MSC_VER>=1300  && _MSC_VER<1400)
 #      define __MSVC32__ 7
-#   endif
-#   if (_MSC_VER>=1400)
+#  endif
+#  if (_MSC_VER>=1400) 
 #      define __MSVC32__ 8
-#   endif
-#   if (__MSVC32__>=7)
-#      define __MSC_NEWER__
-#   endif
+#  endif
 #endif
 
+
+//#define USE_DDOUBLE
+//#define THREAD_EXPERIMENT
 #if defined(THREAD_EXPERIMENT)
-#   define THREAD_SAFE
+#  define THREAD_SAFE
 #endif
 
 #if defined(THREAD_SAFE)
-#   include <pthread.h>
+#  include <pthread.h>
 #endif
 
+#ifndef FVAR_HPP
+#define FVAR_HPP
 #define USE_VECTOR_SHAPE_POOL
-
+//#define MYDEBUG
 #if defined(USE_DDOUBLE)
-#   include <qd/qd.h>
-#   define  double dd_real
-    dd_real operator ++(dd_real & d)
-    {
-       return d += 1.0;
-    }
-
-    dd_real pow(const dd_real & d, int i);
-    dd_real pow(const dd_real & d, const dd_real &);
+#  include <qd/qd.h>
+//#  include </usr/local/include/qd/qd.h>
+# define  double dd_real
+  dd_real operator ++ (dd_real& d) { return d+=1.0;}
+  dd_real pow(const dd_real& d,int i);
+  dd_real pow(const dd_real& d,const dd_real&);
 #endif
-
 #if defined(__TURBOC__) && defined(__linux__)
-#   define __STL_PTHREADS
-#   include <k3stl.h>
-#   include <pthread_alloc>
+#define __STL_PTHREADS
+#  include <k3stl.h>
+#  include <pthread_alloc>
 #endif
-
 #define  __NUMBERVECTOR__
-
 /** \def ADUNCONST(type,obj)
   Creates a shallow copy of obj that is not CONST
 */
 #define ADUNCONST(type,obj) type & obj = (type&) _##obj;
 
+#define __ADMBTHREAD__ __thread
+
 #define my_off_t long int
-
 #ifdef __BORLANDC__
-#   define my_u_off_t unsigned long int
+#define my_u_off_t unsigned long int
 #else
-#   define my_u_off_t unsigned long long int
+#define my_u_off_t unsigned long long int
 #endif
 
 #define  MFCL2_CONSTRUCTORS
 
 #if (defined(__GNUDOS__))
-#   if (  (__GNUC__>3) || (__GNUC__==3 && __GNUC_MINOR__>=0)  )
-#      define __GNU_NEWER__
-#      define GCC3
-#   endif
+#  if (  (__GNUC__>3) || (__GNUC__==3 && __GNUC_MINOR__>=0)  )
+#    define __GNU_NEWER__
+#    define GCC3
+#  endif
 #endif
 
+#if (defined(__MSVC32__))
+#  if (__MSVC32__>=7)
+#    define __MSC_NEWER__
+#  endif
+#endif
+
+#if defined(__MINGW32__)
+#  include <conio.h>
+#endif
+//#define USE_ADPVM 1
+//#define AD_DEMO
 #if defined(_ADEXEP)
-#   define USE_EXECPTIONS
+#  define USE_EXECPTIONS
 #endif
-
+//#define CHK_ID_STRING
+//#define SAFE_ALL
 #define DOS386
+//#define AD_FAST_ASSIGN
+// file fvar.hpp
+// try to just use BOR_CONST = const
 #define __USE_IOSTREAM__
-
 #if defined(__BORLANDC__)
-#   if (__BORLANDC__  >= 0x0550)
-#      include <fcntl.h>
-#   endif
-#   if (__BORLANDC__  >= 0x0520)
-#      define BOR_CONST const
-#   else
-#      define BOR_CONST
-#   endif
+#  if (__BORLANDC__  >= 0x0550) 
+#    include <fcntl.h>
+#  endif
+#  if (__BORLANDC__  >= 0x0520) 
+#    define BOR_CONST const
+// #    define __USING_STD_NAMES__
+#  else
+#  define BOR_CONST
+#endif
 #else
-#   define BOR_CONST
+#  define BOR_CONST
 #endif
-
 #define USE_HIGHER_ARRAYS
-
+#define MFCL2constRUCTORS
 #if defined(__BORLANDC__) || defined (__MSVC32__) || defined(__WAT32__)
-#   include <io.h>
+#  include <io.h>
 #endif
 
+// test
+//#if defined (__MSVC32__) 
+#  if defined (BOR_CONST) 
+#    undef BOR_CONST
+#  endif
+#  define BOR_CONST const
+//#endif
+
 #if defined(linux) || defined (__GNUDOS__)
-#   define AD_LONG_INT long int
+#define AD_LONG_INT long int
+//#define AD_LONG_INT long long int
 #else
-#   define AD_LONG_INT long int
+#define AD_LONG_INT long int
 #endif
 
 #if defined(linux) || defined (__GNUDOS__)
@@ -174,110 +193,119 @@
 #endif
 
 #if defined(linux) || defined(__ADSGI__) || defined(__linux__)
-#   include <fcntl.h>		// to get fstreambase
-#   if !defined(O_BINARY)
-#      define O_BINARY 0
-#   endif
-#   define UNIXKLUDGE
+#include <fcntl.h> // to get fstreambase
+#  if !defined(O_BINARY)
+#    define O_BINARY 0
+#  endif
+  #define UNIXKLUDGE
 #endif
 
-#if !defined(linux)
-#   include <dos.h>
-#   if !defined(__MSVC32__) && !defined(__BORLANDC__) && !defined (__GNUDOS__)
-#      include <pc.h>
-#   endif
+#if !defined(linux) 
+#  include <dos.h>
+#  if !defined(__MSVC32__) && !defined(__BORLANDC__) && !defined (__GNUDOS__)
+#    include <pc.h>
+#  endif
 #endif
-
 #define AD_VERSION 7
 
 #if defined(__GNUDOS__)
-   extern "C"
-   {
+extern "C" {
       void clrscr(void);
-   }
-   #define CGNU_DOUBLE double
+}
+  #define CGNU_DOUBLE double 
 #else
-#   if defined(__BORLANDC__)
-#      if (__BORLANDC__  > 0x0520)
-#         define CGNU_DOUBLE double
-#      else
-#         define CGNU_DOUBLE  double
-#      endif
-#   else
-#      define CGNU_DOUBLE  double
-#   endif
+#  if defined(__BORLANDC__)
+#    if (__BORLANDC__  > 0x0520) 
+#      define CGNU_DOUBLE double 
+#    else
+#      define CGNU_DOUBLE  double 
+#    endif
+#  else
+#    define CGNU_DOUBLE  double 
+#  endif
 #endif
 
 #ifdef __GNUDOS__
-#   define DOS386
-#   define __GNU__
-#   ifdef OLDGNU
-#      include <gccmanip.h>
-#   endif
+  #define DOS386 
+  #define __GNU__
+  #ifdef OLDGNU
+  #include <gccmanip.h>
+  #endif
+//#define HUGE_VAL  1.7976931348623158E+308
 #endif
 
+// for compilers that have trouble with const
 #define USE_CONST
+#ifdef USE_CONST
+  #define _CONST const
+#else
+  #define _CONST 
+#endif
+#ifdef __GNUDOS__
+ // #include <admanip.h>
+#endif
 
-#define _CONST const
-
-#ifdef _SNGL_
-   #define double float
+#ifdef _SNGL_ 
+  #define double float
 #endif
 
 #ifndef NO_DERIVS
-#   define  NO_DERIVS
+  #define  NO_DERIVS
 #endif
 
 #ifdef SAFE_ALL
-#   define CHK_ID_STRING
-#   define DSAFE_ALLOCATE
-#   define SAFE_ARRAYS
+//#define INCLUDE_BLOCKSIZE       // add size info to df1b2variable
+  #define CHK_ID_STRING
+  #define DSAFE_ALLOCATE
+//  #define SAFE_INITIALIZE
+  #define SAFE_ARRAYS
+#endif 
+
+#ifdef __NDP486__
+#include "short.def"
 #endif
 
-// C language function prototypes
-extern "C"
-{
-   typedef int (*fptr) (const char *format, ...);
-   extern fptr ad_printf;
-   typedef void (*exitptr) (int);
-   extern exitptr ad_exit;
+#ifdef USE_ASSEMBLER
+  #include "adass.h"
+#endif
 
-   void spdll_exit(int);
+extern "C" {
+typedef int (* fptr) (const char * format, ...) ;
+extern fptr ad_printf;
+typedef void (*exitptr)(int);
+extern exitptr ad_exit;
+
+void spdll_exit(int);
 }
 
 /**
  * Description not yet available.
  * \param
  */
-class smart_counter
-{
-   int *ncopies;
- public:
-   int *get_ncopies(void);
+  class smart_counter
+  {
+    int * ncopies;
+  public:
+    int * get_ncopies(void);
     smart_counter(void);
     smart_counter(const smart_counter & sc);
-   ~smart_counter(void);
-};
+    ~smart_counter(void);
+  };
 
 /**
   Holds the data for the prevariable class.
   \ingroup BAD
  */
-class double_and_int
-{
- public:
-   double x;			///< value of the variable
+  class double_and_int
+  {
+  public:
+    double x; ///< value of the variable
     /** Return the value of the variable.
     \return double reference containing the value of the variable.
     */
-   inline double &xvalue(void)
-   {
-      return x;
-   }
-};
+    inline double& xvalue(void){return x;}
+  };
 
-
-// "forward" class definitions
 class banded_symmetric_dvar_matrix;
 class banded_symmetric_dmatrix;
 class banded_lower_triangular_dmatrix;
@@ -324,122 +352,152 @@
 dvector restore_dvar_vector_derivatives(void);
 class gradient_structure;
 class dependent_variables_information;
-class vector_shapex;
-class predvar_vector;
-class independent_variables;
-
-#if defined(__GNUC__)
-#   if (__GNUC__  >= 3)
-#      include <fstream>
-#   else
-#      include <fstream.h>
-#   endif
-#elif defined(__MSVC32__)
-#   if (__MSVC32__  >= 7)
-#      include <fstream>
-#   else
-#      include <fstream.h>
-#   endif
+#if defined(__GNUC__) 
+#  if (__GNUC__  >= 3) 
+#    include <fstream>
+#  else
+#    include <fstream.h>
+#  endif
+#elif defined(__MSVC32__) 
+#  if (__MSVC32__  >= 7)
+#    include <fstream>
+#  else
+#    include <fstream.h>
+#  endif
 #else
-#   include <fstream.h>
+#  include <fstream.h>
 #endif
-
 #include <stdio.h>
+//#define __SUN__ 1
+# if defined (__WAT32__)
+#  if defined (max)
+#    undef max
+#  endif
+#  if defined (min)
+#    undef min
+#  endif
+#endif
+#if defined (__TURBOC__) || defined (__WAT32__) 
+#include <mem.h>  // to get memcpy and NULL
+#include <fstream.h> // to get fstreambase
+#include <iostream.h>
+#include <dos.h>
+#undef __ZTC__
+#define __USE_IOSTREAM__
+#undef __SUN__
+#endif
 
 #if ( defined(__GNUC__) && __GNUC__<3) || defined(__SUNPRO_CC)
-#   if defined(linux) || defined(__CYGWIN__) || defined(__SUNPRO_CC)
-#      include <strstream.h>
-#   else
-#      include <strstrea.h>
-#   endif
+#if defined(linux) || defined(__CYGWIN__) || defined(__SUNPRO_CC)
+#   include <strstream.h>
+#  else
+#   include <strstrea.h>
+#  endif
 #endif
 
 #if defined(__BORLANDC__)
-#   if (__BORLANDC__  < 0x0550)
-#      include <fcntl.h>		// to get fstreambase
-#      include <strstrea.h>
-#   else
-#      include <strstream>
-#   endif
+#  if (__BORLANDC__  < 0x0550) 
+#    include <fcntl.h> // to get fstreambase
+#    include <strstrea.h>
+#  else
+#    include <strstream>
+#  endif
 #endif
 
-#if defined(__MSVC32__ )
-#   if (__MSVC32__  >= 7)
-#     include <iostream>
-#   else
-#      include <iostream.h>
-#      include <strstrea.h>
-#   endif
-#   include <stddef.h>
-#   include <fcntl.h>		// to get fstreambase
-#   include <dos.h>
-#   undef __ZTC__
-#   define __USE_IOSTREAM__
-#   undef __SUN__
+#if defined(__MSVC32__ ) 
+#  if (__MSVC32__  >= 7)
+#    include <iostream>
+#  else
+#    include <iostream.h>
+#    include <strstrea.h>
+#  endif
+#include <stddef.h>
+#include <fcntl.h> // to get fstreambase
+#include <dos.h>
+#undef __ZTC__
+#define __USE_IOSTREAM__
+#undef __SUN__
 #endif
 
 #ifdef __ZTC__
-#   include <fstream.hpp>		// to get fstreambase
-#   include <iostream.hpp>
-#   define __USE_IOSTREAM__
-#   include <dos.h>
-#   undef __SUN__
+#include <fstream.hpp> // to get fstreambase
+#include <iostream.hpp>
+#define __USE_IOSTREAM__
+#include <dos.h>
+#undef __SUN__
 #endif
 
+#ifdef __NDPX__
+#include <fstream.h>
+#include <iostream.h>
+#define __USE_IOSTREAM__
+#undef __SUN__
+#endif
+
 #ifdef __SUN__
-#   undef __NDPX__
-#   include <fstream.h>
-#   include <iostream.h>
-#   define __USE_IOSTREAM__
-#   ifndef _FPOS_T_DEFINED
-#      ifdef __GNUDOS__
-#         if defined(linux) || defined(__ADSGI__)|| defined(__CYGWIN32__)
-             typedef long int fpos_t;
-#         else
-             typedef unsigned long int fpos_t;
-#         endif
-#         undef __SUN__
-          typedef int fpos_t;
-#      endif
-#      define _FPOS_T_DEFINED
-#   endif
+#undef __NDPX__
+#include <fstream.h>
+#include <iostream.h>
+#define __USE_IOSTREAM__
+
+#ifndef _FPOS_T_DEFINED
+#ifdef __GNUDOS__
+#  if defined(linux) || defined(__ADSGI__)|| defined(__CYGWIN32__)
+      typedef long int fpos_t;
+#  else
+      typedef unsigned long int fpos_t;
+#  endif
+# undef __SUN__
+#elif defined (__WAT32__)
+  typedef long fpos_t;
+#else
+  typedef int fpos_t;
 #endif
+  #define _FPOS_T_DEFINED
+#endif
 
-//#include <math.h>
+#if defined(__GNUC__)
+extern "C" int getch(void);
+#else
+int getch(void);
+#endif
 
+#endif
+#include <math.h>
+
 #if defined(__BORLANDC__)
-#   if (__BORLANDC__  > 0x0520)
-       using std::ofstream;
-       using std::ifstream;
-#   endif
+#  if (__BORLANDC__  > 0x0520) 
+     using std::ofstream;
+     using std::ifstream;
+#  endif
 #endif
 
 #if ( (defined(__GNUC__) && __GNUC__>=3)   \
     || (defined(__MSVC32__) && __MSVC32__>=7)  \
     || (defined(__BORLANDC__) && __BORLANDC__>=0x0570  && defined(__linux__)) )
-#   include <iostream>
-#   include <iomanip>
-#   include <sstream>
-#   include <istream>
-#   include <sstream>
-    using std::ofstream;
-    using std::ostream;
-    using std::ifstream;
-    using std::istream;
-    using std::istringstream;
-    using std::streampos;
-    using std::streambuf;
-    using std::setw;
-    using std::setprecision;
-    using std::istringstream;
-    using std::ios;
-    using std::cerr;
-    using std::cin;
-    using std::cout;
-    using std::endl;
+#  include <iostream>
+#  include <iomanip>
+#  include <sstream>
+#  include <istream>
+#  include <sstream>
+     using std::ofstream;
+     using std::ostream;
+     using std::ifstream;
+     using std::istream;
+     using std::istringstream;
+     using std::streampos;
+     using std::streambuf;
+     using std::setw;
+     using std::setprecision;
+     using std::istringstream;
+     using std::ios;
+     using std::cerr;
+     using std::cin;
+     using std::cout;
+     using std::endl;
 #else
-#   include <iomanip.h>
-#endif
+#  include <iomanip.h>     
+#endif     
 
 #define BEGIN_MINIMIZATION(nvar, objective_function, ind_vars, gradient, cntrl) \
 gradient_structure gs; \
@@ -454,7 +512,6 @@
   } \
 }
 
-
 void default_evaluation4ind(void);
 void default_evaluation(void);
 void default_evaluation0(void);
@@ -465,67 +522,67 @@
 void default_evaluation4(void);
 void default_evaluation4m(void);
 
-void myheapcheck(char *);
+void myheapcheck( char *);
 
 void RETURN_ARRAYS_INCREMENT(void);
 void RETURN_ARRAYS_DECREMENT(void);
 
-void *farptr_norm(void *);
-long int farptr_tolong(void *);
+void * farptr_norm(void *);
+long int farptr_tolong(void *) ;
 #if (!defined(__ZTC__) || defined(DOS386))
-long int _farptr_tolong(void *);
+  long int _farptr_tolong(void *);
 #endif
-void denormalize_ptr(void *, unsigned int byte_offset);
+void denormalize_ptr(void * , unsigned int byte_offset);
 
 class i3_array;
 
-ostream & operator<<(const ostream & ostr, const dmatrix & z);
-istream & operator>>(const istream & istr, const dmatrix & z);
-uostream & operator<<(const uostream & ostr, const dmatrix & z);
-uistream & operator>>(const uistream & istr, const dmatrix & z);
+ostream& operator<<(const ostream& ostr,const dmatrix& z);
+istream& operator>>(const istream& istr,const dmatrix& z);
+uostream& operator<<(const uostream& ostr,const dmatrix& z);
+uistream& operator>>(const uistream& istr,const dmatrix& z);
 
-ostream & operator<<(const ostream & ostr, const d3_array & z);
-istream & operator>>(const istream & istr, const d3_array & z);
-uostream & operator<<(const uostream & ostr, const d3_array & z);
-uistream & operator>>(const uistream & istr, const d3_array & z);
+ostream& operator<<(const ostream& ostr,const d3_array& z);
+istream& operator>>(const istream& istr,const d3_array& z);
+uostream& operator<<(const uostream& ostr,const d3_array& z);
+uistream& operator>>(const uistream& istr,const d3_array& z);
 
-ostream & operator<<(const ostream & ostr, const dvar3_array & z);
-istream & operator>>(const istream & istr, const dvar3_array & z);
-uostream & operator<<(const uostream & ostr, const dvar3_array & z);
-uistream & operator>>(const uistream & istr, const dvar3_array & z);
+ostream& operator<<(const ostream& ostr,const dvar3_array& z);
+istream& operator>>(const istream& istr,const dvar3_array& z);
+uostream& operator<<(const uostream& ostr,const dvar3_array& z);
+uistream& operator>>(const uistream& istr,const dvar3_array& z);
 
-ostream & operator<<(const ostream & ostr, const ivector & z);
-istream & operator>>(const istream & istr, const ivector & z);
-uostream & operator<<(const uostream & ostr, const ivector & z);
-uistream & operator>>(const uistream & istr, const ivector & z);
+ostream& operator<<(const ostream& ostr,const ivector& z);
+istream& operator>>(const istream& istr,const ivector& z);
+uostream& operator<<(const uostream& ostr,const ivector& z);
+uistream& operator>>(const uistream& istr,const ivector& z);
 
-ostream & operator<<(const ostream & ostr, const lvector & z);
-istream & operator>>(const istream & istr, const lvector & z);
-uostream & operator<<(const uostream & ostr, const lvector & z);
-uistream & operator>>(const uistream & istr, const lvector & z);
+ostream& operator<<(const ostream& ostr,const lvector& z);
+istream& operator>>(const istream& istr,const lvector& z);
+uostream& operator<<(const uostream& ostr,const lvector& z);
+uistream& operator>>(const uistream& istr,const lvector& z);
 
-ostream & operator<<(const ostream & ostr, const dvector & z);
-istream & operator>>(const istream & istr, const dvector & z);
-uostream & operator<<(const uostream & ostr, const dvector & z);
-uistream & operator>>(const uistream & istr, const dvector & z);
+ostream& operator<<(const ostream& ostr,const dvector& z);
+istream& operator>>(const istream& istr,const dvector& z);
+uostream& operator<<(const uostream& ostr,const dvector& z);
+uistream& operator>>(const uistream& istr,const dvector& z);
 
-ostream & operator<<(const ostream & ostr, const dvar_vector & z);
-istream & operator>>(const istream & istr, const dvar_vector & z);
-uostream & operator<<(const uostream & ostr, const dvar_vector & z);
-uistream & operator>>(const uistream & istr, const dvar_vector & z);
+ostream& operator<<(const ostream& ostr,const dvar_vector& z);
+istream& operator>>(const istream& istr,const dvar_vector& z);
+uostream& operator<<(const uostream& ostr,const dvar_vector& z);
+uistream& operator>>(const uistream& istr,const dvar_vector& z);
 
-ostream & operator<<(const ostream & ostr, const dvar_matrix & z);
-istream & operator>>(const istream & istr, const dvar_matrix & z);
-uostream & operator<<(const uostream & ostr, const dvar_matrix & z);
-uistream & operator>>(const uistream & istr, const dvar_matrix & z);
+ostream& operator<<(const ostream& ostr,const dvar_matrix& z);
+istream& operator>>(const istream& istr,const dvar_matrix& z);
+uostream& operator<<(const uostream& ostr,const dvar_matrix& z);
+uistream& operator>>(const uistream& istr,const dvar_matrix& z);
 
 
-ostream & operator<<(const ostream & ostr, const prevariable & z);
-istream & operator>>(const istream & istr, const prevariable & z);
-uostream & operator<<(const uostream & ostr, const prevariable & z);
-uistream & operator>>(const uistream & istr, const prevariable & z);
+ostream& operator<<(const ostream& ostr,const prevariable& z);
+istream& operator>>(const istream& istr,const prevariable& z);
+uostream& operator<<(const uostream& ostr,const prevariable& z);
+uistream& operator>>(const uistream& istr,const prevariable& z);
 
-ostream & setscientific(const ostream & s);
+ostream& setscientific(const ostream& s);
 
 //ostream& setshowpoint(const ostream& s);
 
@@ -535,29 +592,29 @@
  */
 class preshowpoint
 {
-   int x;
+  int x;
 };
-preshowpoint setshowpoint(void);
-ostream & operator <<(const ostream &, preshowpoint);
+preshowpoint  setshowpoint(void);
+ostream& operator << (const ostream&,preshowpoint);
 
-#if (__MSVC32__>=7 || __BORLANDC__  >= 0x0560)
+#if (__MSVC32__>=7 || __BORLANDC__  >= 0x0560) 
 #   define setfixed() std::fixed
 #else
-ostream & setfixed(const ostream & s);
+  ostream& setfixed(const ostream& s);
 
 /**
  * Description not yet available.
  * \param
  */
-class prefixed
-{
-   int x;
-};
-prefixed setfixed(void);
-ostream & operator<<(const ostream &, prefixed);
+  class prefixed
+  {
+    int x;
+  };
+  prefixed  setfixed(void);
+  ostream& operator << (const ostream&,prefixed);
 #endif
-
-#if (__MSVC32__>=7 || __BORLANDC__  >= 0x0560)
+  
+#if (__MSVC32__>=7 || __BORLANDC__  >= 0x0560) 
 #   define setscientific() std::scientific
 #else
 
@@ -565,387 +622,299 @@
  * Description not yet available.
  * \param
  */
-class prescientific
-{
-   int x;
-};
-prescientific setscientific(void);
-ostream & operator<<(const ostream &, prescientific);
+  class prescientific
+  {
+    int x;
+  };
+  prescientific  setscientific(void);
+  ostream& operator << (const ostream&,prescientific);
 #endif
 
-istream & operator>>(const istream & istr, const imatrix & z);
-ostream & operator<<(const ostream & istr, const imatrix & z);
-istream & operator>>(const istream & istr, const i3_array & z);
-ostream & operator<<(const ostream & istr, const i3_array & z);
-class grad_stack;
+istream& operator>>(const istream& istr,const imatrix& z);
+ostream& operator<<(const ostream& istr,const imatrix& z);
+istream& operator>>(const istream& istr,const i3_array& z);
+ostream& operator<<(const ostream& istr,const i3_array& z);
+  class grad_stack;
 
 /**
  * Description not yet available.
  * \param
  */
-class kkludge_object
-{
-   char u;
-};
+  class kkludge_object
+  {
+    char u;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class humungous_pointer
-{
- public:
-#if defined(__BORLANDC__ ) && !defined(DOS386) && !defined(__WIN32__)
-   char huge *ptr;
-#else
-   char *ptr;
-#endif
-   int adjustment;
-   void free(void);
-   ~humungous_pointer()
-   {;
-   }
-   void adjust(int);
-   humungous_pointer();
-   humungous_pointer operator +(unsigned long int &offset);
-   humungous_pointer & operator +=(unsigned long int &offset);
-   humungous_pointer & operator =(void *p);
-   int operator ==(void *p);
-   int operator !=(void *p);
-   operator  char *();
-   operator  void *();
-   operator  double_and_int *();
-   operator  double *();
-};
+      class humungous_pointer
+      {
+      public:
+        #if defined(__BORLANDC__ ) && !defined(DOS386) && !defined(__WIN32__)
+	  char huge * ptr;
+	#else
+	  char * ptr;
+	#endif
+          int adjustment;
+        void free(void);
+	~humungous_pointer(){;}
+        void adjust(int);
+	humungous_pointer();
+	humungous_pointer operator + (unsigned long int& offset);
+	humungous_pointer& operator += (unsigned long int& offset);
+	humungous_pointer& operator = (void * p);
+	int operator == (void * p);
+	int operator != (void * p); 
+        operator char* (); 
+        operator void* (); 
+        operator double_and_int* ();
+        operator double* ();
+      };
 
 #ifndef _VECTOR_SHAPE
-#define _VECTOR_SHAPE
+  #define _VECTOR_SHAPE
 #include <dfpool.h>
 
 /**
  * Description not yet available.
  * \param
  */
-class vector_shape_pool:public dfpool
-{
- public:
-   vector_shape_pool(void);
-   vector_shape_pool(int);
-};
+  class vector_shape_pool : public dfpool
+  {
+  public:
+    vector_shape_pool(void);
+    vector_shape_pool(int);
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class ts_vector_shape_pool:public tsdfpool
-{
- public:
-   ts_vector_shape_pool(void);
-   ts_vector_shape_pool(int);
-};
-#endif
+  class ts_vector_shape_pool : public tsdfpool
+  {
+  public:
+    ts_vector_shape_pool(void);
+    ts_vector_shape_pool(int);
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class vector_shape
-{
- public:
+  class vector_shape
+  {
+  public:
 #if defined(USE_VECTOR_SHAPE_POOL)
-   static vector_shape_pool *xpool;
-   void *operator  new(size_t);
-   void operator  delete(void *ptr, size_t n)
-   {
-      xpool->free(ptr);
-   }
+    static __ADMBTHREAD__ vector_shape_pool * xpool;
+    void * operator new(size_t);
+    void operator delete(void * ptr,size_t n)
+    {  xpool->free(ptr); }
 #endif
-   unsigned int ncopies;
-   void shift(int min);
-   int index_min;
-   int index_max;
- private:
-   friend class dvector;
-   //friend class tdvector;
-   friend class subdvector;
-   friend class dvar_vector;
-   friend class ivector;
-   friend class lvector;
-   friend class ptr_vector;
- public:
-   int decr_ncopies(void)
-   {
-      return --ncopies;
-   }
-   int get_ncopies(void)
-   {
-      return ncopies;
-   }
-   int incr_ncopies(void)
-   {
-      return ++ncopies;
-   }
-   vector_shape(int lb, int lu)
-   {
-      index_min = lb;
-      index_max = lu;
-      ncopies = 0;
-   }
-   int indexmin()
-   {
-      return index_min;
-   }
-   int indexmax()
-   {
-      return index_max;
-   }
-};
+    unsigned int ncopies;
+    void shift(int min);
+    int index_min;
+    int index_max;
+  private:
+    friend class dvector;
+    //friend class tdvector;
+    friend class subdvector;
+    friend class dvar_vector;
+    friend class ivector;
+    friend class lvector;
+    friend class ptr_vector;
+  public:
+    int decr_ncopies(void) {return --ncopies;}
+    int get_ncopies(void) {return ncopies;}
+    int incr_ncopies(void) {return ++ncopies;}
+    vector_shape(int lb, int lu) {index_min=lb;index_max=lu;ncopies=0;}
+    int indexmin(){return index_min;}
+    int indexmax(){return index_max;}
+  };
+#endif
 
-
 /**
  * Description not yet available.
  * \param
  */
-class ptr_vector
-{
-   void **v;
-   vector_shape *shape;
+  class ptr_vector
+  {
+    void ** v;
+    vector_shape * shape;
 
- public:
+  public:
 
-   int indexmin() const
-   {
-      return shape->index_min;
-   }				// returns the minimum allowable index
-   int indexmax() const
-   {
-      return shape->index_max;
-   }				// returns the maximum allowable index
-   int size() const
-   {
-      return shape->index_max - shape->index_min + 1;
-   }				// returns the maximum allowable index
+    int indexmin() const {return shape->index_min;} // returns the minimum allowable index
+    int indexmax() const  {return shape->index_max;} // returns the maximum allowable index
+    int size() const {return shape->index_max - shape->index_min+1;} // returns the maximum allowable index
 
-   void shift(int min);
-   ptr_vector(int ncl, int ncu);
-   ptr_vector();
-   void allocate(int, int);
-   //operator void ** ();
+    void shift(int min);
+    ptr_vector( int ncl,  int ncu);
+    ptr_vector();
+    void allocate(int,int);
+    //operator void ** ();
    ~ptr_vector();
-   void *&operator[] (int i);
-   void *&operator() (int i);
-   //void*& elem(int i);
-   void *&elem(int i)
-   {
-      return (*(v + i));
-   }
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   int operator() (void) const
-   {
-      return (shape != NULL);
-   }
+    void*& operator[] (int i);
+    void*& operator() (int i);
+    //void*& elem(int i);
+    void*& elem(int i) { return(*(v+i)); }
+    int operator ! (void) const {return (shape == NULL);}
+    int operator () (void) const {return (shape != NULL);}
 
-   ptr_vector(const ptr_vector & t);
-   ptr_vector & operator=(const ptr_vector & t);
-   void initialize();
-};				// end of class ptr_vector
+    ptr_vector(const ptr_vector& t);
+    ptr_vector& operator = (const ptr_vector& t);
+    void initialize();
+ }; // end of class ptr_vector
 
 /**
  * Description not yet available.
  * \param
  */
-class preivector
-{
-   ivector *p;
-   int lb;
-   int ub;
-   inline preivector(ivector * _p, int _lb, int _ub)
-   {
-      p = _p;
-      lb = _lb, ub = _ub;
-   }
-   friend class ivector;
-};
+  class preivector
+  {
+    ivector * p;
+    int lb;
+    int ub;
+    inline preivector(ivector * _p,int _lb,int _ub) {p=_p;lb=_lb,ub=_ub;}
+    friend class ivector;
+  };
 
+  class vector_shapex;
 
 /**
  * Description not yet available.
  * \param
  */
-class ivector
-{
- protected:
-   int index_min;
-   int index_max;
-   int *v;
-   vector_shapex *shape;
 
- public:
-   int allocated(void) const
-   {
-      return (shape != NULL);
-   }
+  class ivector
+  {
+  protected:
+    int index_min;
+    int index_max;
+    int * v;
+    vector_shapex * shape;
 
-   ivector & operator --(void)
-   {
-      index_min--;
-      index_max--;
-      v++;
-      return *this;
-   }
-   void reallocate(double size);
+  public:
+    int allocated(void) const { return (shape != NULL); }
 
-   ivector & operator ++(void)
-   {
-      index_min++;
-      index_max++;
-      v--;
-      return *this;
-   }
-   friend class vector_index;
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+    ivector& operator -- (void) 
+    { 
+      index_min--;index_max--;v++; return *this;
+    }
+    void reallocate(double size);
 
-   int &elem(int i)
-   {
-      return (v[i]);
-   }
+    ivector& operator ++ (void)  
+    { 
+      index_min++;index_max++;v--; return *this;
+    }
+    friend class vector_index;
+    int operator!(void) const { return (shape == NULL); }
+
+        int& elem(int i) { return(v[i]); }
 #ifdef USE_CONST
-   const int &elem(int i) const
-   {
-      return v[i];
-   }
+    const int& elem(int i) const { return v[i]; }
 #endif
-   int indexmin() const
-   {
-      return index_min;
-   }				// returns the minimum allowable index
-   int indexmax() const
-   {
-      return index_max;
-   }				// returns the maximum allowable index
-   int size() const
-   {
-      return index_max - index_min + 1;
-   }				// returns the maximum allowable index
-   int *get_v(void) const
-   {
-      return v;
-   }
-   ivector & shift(int min);
-   //ivector(unsigned int sz); //makes an array [0..sz]
-   //inline allocated(void) {return ::allocated(this);}
-   ivector(const lvector &);
-   ivector(void);
+    int indexmin() const { return index_min; } // returns the minimum allowable index
+    int indexmax() const { return index_max; } // returns the maximum allowable index
+    int size() const { return index_max - index_min + 1; } // returns the maximum allowable index
+    int* get_v(void) const { return v; }
+    ivector& shift(int min);
+    //ivector(unsigned int sz); //makes an array [0..sz]
+    //inline allocated(void) {return ::allocated(this);}
+    ivector(const lvector&);
+    ivector(void);
 
-   ivector(const dvector &);
+    ivector(const dvector&);
 
-   void fill(const char *s);
-   void fill_seqadd(int, int);
-   void fill_multinomial(const int &seed, const dvector & p);
-   void fill_multinomial(const random_number_generator & rng,
-			 const dvector & p);
-   ivector(int ncl, int ncu);
-   ivector(const ad_integer & ncl, const index_type & ncu);
-   void allocate(const ad_integer & ncl, const index_type & ncu);
-   // makes an array [ncl..ncu]
+    void fill(const char * s);
+    void fill_seqadd(int, int);
+    void fill_multinomial(const int& seed, const dvector& p);
+    void fill_multinomial(const random_number_generator& rng, const dvector& p);
+    ivector( int ncl,  int ncu);
+    ivector(const ad_integer& ncl,const index_type& ncu);
+    void allocate(const ad_integer& ncl,const index_type& ncu);
+             // makes an array [ncl..ncu]
 
-   ivector(unsigned int sz, long int *x);
+    ivector( unsigned int sz, long int * x);
 
-   void safe_allocate(int ncl, int ncu);
-   void allocate(int ncl, int ncu);
-   void allocate(const ivector & iv);
-   void allocate(const dvector & dv);
-   void allocate(const char *);
-   void allocate(void);
-   void deallocate(void);
-   void safe_deallocate(void);
+      void safe_allocate(int ncl,int ncu);
+      void allocate(int ncl,int ncu);
+      void allocate(const ivector& iv);
+      void allocate(const dvector& dv);
+      void allocate(const char *);
+      void allocate(void);
+      void deallocate(void);
+      void safe_deallocate(void);
 
-   //operator int* () {return v;}
+    //operator int* () {return v;}
 
    ~ivector();
 
-   void save_ivector_position(void) const;
+    void save_ivector_position(void) const;
 
-   void save_ivector_value(void) const;
+    void save_ivector_value(void) const;
 
-   void write_on(const ostream & s) const;
+    void write_on(const ostream& s) const;
 
-   void read_from(const istream & s);
+    void read_from(const istream& s);
 
-   void write_on(const uostream & s) const;
+    void write_on(const uostream& s) const;
 
-   void read_from(const uistream & s);
+    void read_from(const uistream& s);
 
-#ifdef OPT_LIB
-   inline int &operator[] (int i)
-   {
-      return (*(v + i));
-   }
-   inline int &operator() (int i)
-   {
-      return (*(v + i));
-   }
-#else
-   int &operator[] (int i);
-   int &operator() (int i);
-#endif
+ #ifdef OPT_LIB
+    inline int& operator[] (int i) {return(*(v+i));}
+    inline int& operator() (int i) {return(*(v+i));}
+ #else
+    int& operator[] (int i);
+    int& operator() (int i);
+ #endif
 
 #ifdef USE_CONST
-#ifdef OPT_LIB
-   inline const int &operator[] (int i) const
-   {
-      return (*(v + i));
-   }
-   inline const int &operator() (int i) const
-   {
-      return (*(v + i));
-   }
-#else
-   const int &operator[] (int i) const;
-   const int &operator() (int i) const;
+ #ifdef OPT_LIB
+    inline const int& operator[](int i) const { return (*(v+i)); }
+    inline const int& operator() (int i) const { return (*(v+i)) ; }
+ #else
+    const int& operator[](int i) const;
+    const int& operator()(int i) const;
+ #endif
 #endif
-#endif
 
-   ivector sub(int lb, int ub)
-   {
-      return preivector(this, lb, ub);
-   }
-   ivector operator () (int lb, int ub)
-   {
-      return preivector(this, lb, ub);
-   }
-   ivector(const preivector & pd);
+    ivector sub(int lb,int ub)
+    {
+      return preivector(this,lb,ub);
+    }
+    ivector operator () (int lb,int ub)
+    {
+      return preivector(this,lb,ub);
+    }
+    ivector(const preivector& pd);
 
-   ivector operator() (const ivector & u);
+    ivector operator()(const ivector& u);
 
-   ivector(const ivector & t);
-   void shallow_copy(const ivector & t);
+    ivector(const ivector& t);
+    void shallow_copy(const ivector& t);
 
-   ivector & operator=(const ivector & t);
-   ivector & operator =(int t);
+    ivector& operator=(const ivector& t);
+    ivector& operator = (int t);
 
-   ivector & operator=(const lvector & t);
+    ivector& operator=(const lvector& t);
 
-   friend class imatrix;
-   friend class i3_array;
-   void initialize(void);
-   ivector & operator+=(const ivector & t);
-   ivector & operator +=(int t);
+    friend class imatrix;
+    friend class i3_array;
+    void initialize(void);
+    ivector& operator+=(const ivector& t);
+    ivector& operator += (int t);
 
-};				// end of class ivector
+ }; // end of class ivector
 
-ivector operator+(const ivector & v, const ivector & w);
-ivector operator-(const ivector & v, const ivector & w);
-ivector operator+(const ivector & v, int w);
-ivector operator-(const ivector & v, int w);
-ivector operator+(int v, const ivector & w);
-ivector operator-(int v, const ivector & w);
+  ivector operator + (const ivector& v,const ivector& w);
+  ivector operator - (const ivector& v,const ivector& w);
+  ivector operator + (const ivector& v,int w);
+  ivector operator - (const ivector& v,int w);
+  ivector operator + (int v,const ivector& w);
+  ivector operator - (int v,const ivector& w);
 
 /**
  * Description not yet available.
@@ -953,577 +922,529 @@
  */
 class lvector_position
 {
-   int min;
-   int max;
-   int *v;
- public:
-   lvector_position(void);
-   lvector_position(const lvector & v);
-   lvector_position(const lvector_position & dvp);
+  int min;
+  int max;
+  int * v;
+public:
+  lvector_position(void);
+  lvector_position(const lvector& v);
+  lvector_position(const lvector_position& dvp);
 };
 
 /**
  * Description not yet available.
  * \param
  */
-class lvector
-{
-   AD_LONG_INT *v;
-   vector_shape *shape;
 
- public:
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+  class lvector
+  {
+     AD_LONG_INT * v;
+    vector_shape * shape;
 
-   inline AD_LONG_INT & elem(int i)
-   {
-      return (v[i]);
-   }
+  public:
+    int operator!(void) const { return (shape == NULL); }
+
+        inline AD_LONG_INT& elem(int i) { return(v[i]); }
 #ifdef USE_CONST
-   inline const AD_LONG_INT & elem(int i) const
-   {
-      return v[i];
-   }
+    inline const AD_LONG_INT& elem(int i) const { return v[i]; }
 #endif
-   int indexmin() const
-   {
-      return shape->index_min;
-   }				// returns the minimum allowable index
-   int indexmax() const
-   {
-      return shape->index_max;
-   }				// returns the maximum allowable index
-   int size() const
-   {
-      return shape->index_max - shape->index_min + 1;
-   }				// returns the maximum allowable index
-   void shift(int min);
+    int indexmin() const { return shape->index_min; } // returns the minimum allowable index
+    int indexmax() const { return shape->index_max; } // returns the maximum allowable index
+    int size() const { return shape->index_max - shape->index_min + 1; } // returns the maximum allowable index
+    void shift(int min);
 
-   void fill(const char *s);
-   void fill_seqadd(const AD_LONG_INT &, const AD_LONG_INT &);
-   void fill_multinomial(const int &seed, const dvector & p);
-   void fill_multinomial(const random_number_generator & rng,
-			 const dvector & p);
+    void fill(const char * s);
+    void fill_seqadd(const AD_LONG_INT&, const AD_LONG_INT&);
+    void fill_multinomial(const int& seed, const dvector& p);
+    void fill_multinomial(const random_number_generator& rng, const dvector& p);
 
-   //lvector(unsigned int sz); //makes an array [0..sz]
+    //lvector(unsigned int sz); //makes an array [0..sz]
 
-   lvector(const lvector &);
+    lvector(const lvector&);
 
-   lvector(const dvector &);
+    lvector(const dvector&);
 
-   lvector(const ivector &);
+    lvector(const ivector&);
 
-   lvector(void);
+    lvector(void);
 
-   lvector(int ncl, int ncu);
-   void allocate(int ncl, int ncu);
-   void allocate(const lvector &);
-   void allocate(void);
-   // makes an array [ncl..ncu]
+    lvector( int ncl,  int ncu);
+    void allocate( int ncl,  int ncu);
+    void allocate(const lvector&);
+    void allocate(void);
+                                           // makes an array [ncl..ncu]
 
-   lvector(unsigned int sz, AD_LONG_INT * x);
+    lvector( unsigned int sz,  AD_LONG_INT * x);
 
-   operator   AD_LONG_INT *();
+    operator  AD_LONG_INT* ();
 
    ~lvector();
 
-   void write_on(const ostream & s) const;
+    void write_on(const ostream& s) const;
 
-   void read_from(const istream & s);
+    void read_from(const istream& s);
 
-   void write_on(const uostream & s) const;
+    void write_on(const uostream& s) const;
 
-   void read_from(const uistream & s);
+    void read_from(const uistream& s);
 
 #ifdef OPT_LIB
-   inline AD_LONG_INT & operator[] (int i)
-   {
-      return v[i];
-   }
-   inline AD_LONG_INT & operator() (int i)
-   {
-      return v[i];
-   }
+    inline  AD_LONG_INT& operator[] (int i) {return v[i];}
+    inline  AD_LONG_INT& operator() (int i) {return v[i];}
 #else
-   AD_LONG_INT & operator[](int i);
-   AD_LONG_INT & operator()(int i);
+     AD_LONG_INT& operator[] (int i);
+     AD_LONG_INT& operator() (int i);
 #endif
 
 #ifdef USE_CONST
 #ifdef OPT_LIB
-   inline const AD_LONG_INT & operator[] (int i) const
-   {
-      return v[i];
-   }
-   inline const AD_LONG_INT & operator() (int i) const
-   {
-      return v[i];
-   }
+    inline const AD_LONG_INT& operator[](int i) const { return v[i]; }
+    inline const AD_LONG_INT& operator()(int i) const { return v[i]; }
 #else
-   const AD_LONG_INT & operator[] (int i) const;
-   const AD_LONG_INT & operator() (int i) const;
+    const AD_LONG_INT& operator[](int i) const;
+    const AD_LONG_INT& operator()(int i) const;
 #endif
 #endif
 
-   lvector operator() (const lvector & u);
+    lvector operator()(const lvector& u);
 
-   lvector & operator=(const lvector & t);
+    lvector& operator=(const lvector& t);
 
-   void initialize(void);
-   friend class lmatrix;
-};				// end of class lvector
+    void initialize(void);
+    friend class lmatrix;
+ }; // end of class lvector
 
-AD_LONG_INT sum(const lvector &);
+  AD_LONG_INT sum(const lvector&);
 
 /**
  * Description not yet available.
  * \param
  */
-class dependent_variables_information
-{
-   int max_num_dependent_variables;
-   int depvar_count;
-   ptr_vector grad_buffer_position;
-   lvector cmpdif_buffer_position;
-   lvector grad_file_position;
-   lvector cmpdif_file_position;
-   lvector grad_file_count;
-   lvector cmpdif_file_count;
-   dependent_variables_information(int ndv);
-   friend class gradient_structure;
-};
-dvar_vector_position restore_dvar_vector_position(void);
-dvector restore_dvar_vector_value(const dvar_vector_position & tmp);
-void arr_free(double_and_int *);
-double_and_int *arr_new(unsigned int sz);
+  class dependent_variables_information
+  {
+    int max_num_dependent_variables;
+    int depvar_count;
+    ptr_vector grad_buffer_position;
+    lvector cmpdif_buffer_position;
+    lvector grad_file_position;
+    lvector cmpdif_file_position;
+    lvector grad_file_count;
+    lvector cmpdif_file_count;
+    dependent_variables_information(int ndv);
+    friend class gradient_structure;
+  };
+  dvar_vector_position restore_dvar_vector_position(void);
+  dvector restore_dvar_vector_value(const dvar_vector_position& tmp);
+  void arr_free(double_and_int *);
+  double_and_int * arr_new(unsigned int sz); 
 
 /**
  * class for things related to the gradient structures, including dimension of 
  * arrays, size of buffers, etc.
  */
-class gradient_structure
-{
-   static char cmpdif_file_name[61];
-   static DF_FILE *fp;
- public:
-#if defined(NO_DERIVS)
-   static int no_derivatives;
-#endif
- private:
-   static long int USE_FOR_HESSIAN;
-   static long int NVAR;
-   static int NUM_RETURN_ARRAYS;
-   static dvariable **RETURN_ARRAYS;
-   static int RETURN_ARRAYS_PTR;
-   static dvariable **RETURN_PTR_CONTAINER;
-   static long int TOTAL_BYTES;
-   static long int PREVIOUS_TOTAL_BYTES;
-   static unsigned long ARRAY_MEMBLOCK_SIZE;	//js
-   static humungous_pointer ARRAY_MEMBLOCK_BASE;
-   static humungous_pointer ARRAY_MEMBLOCK_BASEA;
-   static humungous_pointer ARRAY_MEMBLOCK_SAVE;
- public:
-   static double *get_ARRAY_MEMBLOCK_BASE()
-   {
-      return (double *) ARRAY_MEMBLOCK_BASE;
-   }
- private:
-   static double *variables_save;
+  class gradient_structure
+  {
+      static __ADMBTHREAD__ char cmpdif_file_name[101];
+      static __ADMBTHREAD__ DF_FILE * fp;
+public:
+      #if defined(NO_DERIVS)
+        static int no_derivatives;
+      #endif
+private:
+      static long int USE_FOR_HESSIAN;
+      static __ADMBTHREAD__ long int NVAR;
+      static int NUM_RETURN_ARRAYS;
+      static __ADMBTHREAD__ dvariable** RETURN_ARRAYS;
+      static __ADMBTHREAD__ int RETURN_ARRAYS_PTR;
+      static __ADMBTHREAD__ dvariable ** RETURN_PTR_CONTAINER;
+      static __ADMBTHREAD__ long int TOTAL_BYTES;
+      static __ADMBTHREAD__ long int PREVIOUS_TOTAL_BYTES;
+      static __ADMBTHREAD__ unsigned long ARRAY_MEMBLOCK_SIZE; //js
+      //static humungous_pointer ARRAY_MEMBLOCK_BASE;
+      //static humungous_pointer ARRAY_MEMBLOCK_BASEA;
+      //static humungous_pointer ARRAY_MEMBLOCK_SAVE;
+      static __ADMBTHREAD__ char * ARRAY_MEMBLOCK_BASE;
+      static __ADMBTHREAD__ char * ARRAY_MEMBLOCK_BASEA;
+      static __ADMBTHREAD__ char * ARRAY_MEMBLOCK_SAVE;
+public:    
+      static double * get_ARRAY_MEMBLOCK_BASE() 
+      { 
+        return (double*) ARRAY_MEMBLOCK_BASE;
+      }
+private:
+      static __ADMBTHREAD__ double * variables_save;
 #ifdef __BORLANDC__
-   static long int CMPDIF_BUFFER_SIZE;
-   static long int GRADSTACK_BUFFER_SIZE;
+      static long int CMPDIF_BUFFER_SIZE;
+      static long int GRADSTACK_BUFFER_SIZE;
 #else
-   static long long int CMPDIF_BUFFER_SIZE;
-   static long long int GRADSTACK_BUFFER_SIZE;
+      static long long int CMPDIF_BUFFER_SIZE;
+      static long long int GRADSTACK_BUFFER_SIZE;
 #endif
-   static unsigned int MAX_NVAR_OFFSET;
-   static int save_var_file_flag;
-   static int save_var_flag;
+      static __ADMBTHREAD__ unsigned int MAX_NVAR_OFFSET;
+      static int save_var_file_flag;
+      static int save_var_flag;
 
-   static int MAX_DLINKS;
-   static indvar_offset_list *INDVAR_LIST;
-   static int NUM_DEPENDENT_VARIABLES;
-   static dependent_variables_information *DEPVARS_INFO;
+      static int MAX_DLINKS;
+      static __ADMBTHREAD__ indvar_offset_list * INDVAR_LIST;
+      static int NUM_DEPENDENT_VARIABLES;
+      static __ADMBTHREAD__ dependent_variables_information * DEPVARS_INFO;
 
-   // this needs to be a static member function so other static
-   // member functions can call it
-   static void check_set_error(const char *variable_name);
+      // this needs to be a static member function so other static
+      // member functions can call it
+      static void check_set_error(const char* variable_name);
 
-   static int instances;
-   int x;
+      static __ADMBTHREAD__ int instances;
+      int   x;
 
- public:
-   class arrmemblerr
-   {
-   };				// exception class
+    public:
+      class arrmemblerr{}; // exception class
+   
+      static __ADMBTHREAD__ int Hybrid_bounded_flag;
+      static __ADMBTHREAD__ double * hessian_ptr;
+      static int get_USE_FOR_HESSIAN(void) {return USE_FOR_HESSIAN;}
+      static void set_USE_FOR_HESSIAN(int i) {USE_FOR_HESSIAN=i;}
+      friend class dfsdmat;
+      gradient_structure(long int size=100000L);  // constructor
+      ~gradient_structure(void); // destructor
+      static void save_variables(void);
+      static void restore_variables(void);
+      static void save_arrays(void);
+      static void restore_arrays(void);
+      static long int totalbytes(void);
+      friend dvector restore_dvar_vector_value(const dvar_vector_position& tmp);
+      friend void cleanup_temporary_files();
+      //friend dvector restore_dvar_vector_value(const dvar_vector_position&);
+      friend dvector restore_dvar_vector_derivatives(void);
+      friend dmatrix restore_dvar_matrix_derivatives(void);
+      friend dmatrix restore_dvar_matrix_value(void);
+      //friend dmatrix restore_derivatives(void);
+      friend void gradfree(dlink * v);
+      friend double_and_int * arr_new(unsigned int sz); //js
+      friend void arr_free(double_and_int *);
+      friend void RETURN_ARRAYS_DECREMENT(void);
+      friend void RETURN_ARRAYS_INCREMENT(void);
+      friend void make_indvar_list(const dvar_vector& t);
+      //friend void gradcalc( int , double *);
+      friend void gradcalc(int nvar,const dvector& g);
+      friend void slave_gradcalc(void);
+      friend void funnel_gradcalc(void);
+      friend void allocate_dvariable_space(void);
+      friend void wide_funnel_gradcalc(void);
+      friend dvar_vector_position restore_dvar_vector_position(void);
+      static __ADMBTHREAD__ grad_stack  * GRAD_STACK1;
+      friend double_and_int * gradnew();
+      static __ADMBTHREAD__ dlist * GRAD_LIST;
+      static __ADMBTHREAD__ int RETURN_ARRAYS_SIZE;
+      //static int RETURN_INDEX;
+      static __ADMBTHREAD__ dvariable * RETURN_PTR;
+      static __ADMBTHREAD__ dvariable * MIN_RETURN;
+      static __ADMBTHREAD__ dvariable * MAX_RETURN;
+      static __ADMBTHREAD__ arr_list * ARR_LIST1;
+      static __ADMBTHREAD__ arr_list * ARR_FREE_LIST1;
+      //static void funnel_jacobcalc(void);
+      static void jacobcalc(int nvar,const dmatrix& jac);
+      static void jacobcalc(int nvar,const ofstream& jac);
+      static void jacobcalc(int nvar,const uostream& jac);
 
-   static int Hybrid_bounded_flag;
-   static double *hessian_ptr;
-   static int get_USE_FOR_HESSIAN(void)
-   {
-      return USE_FOR_HESSIAN;
-   }
-   static void set_USE_FOR_HESSIAN(int i)
-   {
-      USE_FOR_HESSIAN = i;
-   }
-   friend class dfsdmat;
-   gradient_structure(long int size = 100000L);	// constructor
-   ~gradient_structure(void);	// destructor
-   static void save_variables(void);
-   static void restore_variables(void);
-   static void save_arrays(void);
-   static void restore_arrays(void);
-   static long int totalbytes(void);
-   friend dvector restore_dvar_vector_value(const dvar_vector_position &
-					    tmp);
-   friend void cleanup_temporary_files();
-   //friend dvector restore_dvar_vector_value(const dvar_vector_position&);
-   friend dvector restore_dvar_vector_derivatives(void);
-   friend dmatrix restore_dvar_matrix_derivatives(void);
-   friend dmatrix restore_dvar_matrix_value(void);
-   //friend dmatrix restore_derivatives(void);
-   friend void gradfree(dlink * v);
-   friend double_and_int *arr_new(unsigned int sz);	//js
-   friend void arr_free(double_and_int *);
-   friend void RETURN_ARRAYS_DECREMENT(void);
-   friend void RETURN_ARRAYS_INCREMENT(void);
-   friend void make_indvar_list(const dvar_vector & t);
-   //friend void gradcalc( int , double *);
-   friend void gradcalc(int nvar, const dvector & g);
-   friend void slave_gradcalc(void);
-   friend void funnel_gradcalc(void);
-   friend void allocate_dvariable_space(void);
-   friend void wide_funnel_gradcalc(void);
-   friend dvar_vector_position restore_dvar_vector_position(void);
-   static grad_stack *GRAD_STACK1;
-   friend double_and_int *gradnew();
-   static dlist *GRAD_LIST;
-   static int RETURN_ARRAYS_SIZE;
-   //static int RETURN_INDEX;
-   static dvariable *RETURN_PTR;
-   static dvariable *MIN_RETURN;
-   static dvariable *MAX_RETURN;
-   static arr_list *ARR_LIST1;
-   static arr_list *ARR_FREE_LIST1;
-   //static void funnel_jacobcalc(void);
-   static void jacobcalc(int nvar, const dmatrix & jac);
-   static void jacobcalc(int nvar, const ofstream & jac);
-   static void jacobcalc(int nvar, const uostream & jac);
+      friend void default_evaluation(void);
+      //access functions
 
-   friend void default_evaluation(void);
-   //access functions
-
-   friend class DF_FILE;
-   static DF_FILE *get_fp(void)
-   {
-      return fp;
-   }
-   static void set_NUM_RETURN_ARRAYS(int i);
-#if defined(NO_DERIVS)
-   static void set_NO_DERIVATIVES(void);
-   static void set_YES_DERIVATIVES(void);
-#endif
-   static void set_YES_SAVE_VARIABLES_VALUES();
-   static void set_NO_SAVE_VARIABLES_VALUES();
-   //static int _GRADFILE_PTR; // should be int gradfile_handle;
-   //static int _GRADFILE_PTR1; // should be int gradfile_handle;
-   //static int _GRADFILE_PTR2; // should be int gradfile_handle;
-   //static int _VARSSAV_PTR; // should be int gradfile_handle;
-   static void set_NUM_DEPENDENT_VARIABLES(int i);
-   static void set_RETURN_ARRAYS_SIZE(int i);
-   static void set_ARRAY_MEMBLOCK_SIZE(unsigned long i);
+      friend class DF_FILE;
+      static DF_FILE * get_fp(void){return fp;}
+      static void set_NUM_RETURN_ARRAYS(int i);
+     #if defined(NO_DERIVS)
+      static void set_NO_DERIVATIVES(void);
+      static void set_YES_DERIVATIVES(void);
+     #endif
+      static void set_YES_SAVE_VARIABLES_VALUES();
+      static void set_NO_SAVE_VARIABLES_VALUES();
+      //static int _GRADFILE_PTR; // should be int gradfile_handle;
+      //static int _GRADFILE_PTR1; // should be int gradfile_handle;
+      //static int _GRADFILE_PTR2; // should be int gradfile_handle;
+      //static int _VARSSAV_PTR; // should be int gradfile_handle;
+      static void set_NUM_DEPENDENT_VARIABLES(int i);
+      static void set_RETURN_ARRAYS_SIZE(int i);
+      static void set_ARRAY_MEMBLOCK_SIZE(unsigned long i);
 #ifdef __BORLANDC__
-   static void set_CMPDIF_BUFFER_SIZE(long int i);
-   static void set_GRADSTACK_BUFFER_SIZE(long int i);
-   static void set_GRADSTACK_BUFFER_BYTES(long int i);
+      static void set_CMPDIF_BUFFER_SIZE(long int i);
+      static void set_GRADSTACK_BUFFER_SIZE(long int i);
+      static void set_GRADSTACK_BUFFER_BYTES(long int i);
 #else
-   static void set_CMPDIF_BUFFER_SIZE(long long int i);
-   static void set_GRADSTACK_BUFFER_SIZE(long long int i);
-   static void set_GRADSTACK_BUFFER_BYTES(long long int i);
+      static void set_CMPDIF_BUFFER_SIZE(long long int i);
+      static void set_GRADSTACK_BUFFER_SIZE(long long int i);
+      static void set_GRADSTACK_BUFFER_BYTES(long long int i);
 #endif
-   static void set_MAX_NVAR_OFFSET(unsigned int i);
-   static void set_MAX_DLINKS(int i);
-   static long int NUM_GRADSTACK_BYTES_WRITTEN(void);
-   friend class dlist;
-   friend class grad_stack;
-   static void save_dependent_variable_position(const prevariable & v1);
-   static long int max_last_offset;
-   friend class function_minimizer;
-   friend void funnel_derivatives(void);
-};
+      static void set_MAX_NVAR_OFFSET(unsigned int i);
+      static void set_MAX_DLINKS(int i);
+      static long int NUM_GRADSTACK_BYTES_WRITTEN(void);
+      friend class dlist;
+      friend class grad_stack;
+      static void save_dependent_variable_position
+        (const prevariable& v1);
+      static __ADMBTHREAD__ long int max_last_offset;
+      friend class function_minimizer;
+      friend void funnel_derivatives(void);
+  };
 
-void jacobcalc(int nvar, const dmatrix & g);
-void jacobcalc(int nvar, const ofstream & ofs);
-void jacobcalc(int nvar, const uostream & ofs);
+  void jacobcalc(int nvar,const dmatrix& g);
+  void jacobcalc(int nvar,const ofstream& ofs);
+  void jacobcalc(int nvar,const uostream& ofs);
 
 #if defined(__BORLANDC__ )
-#if defined(__GNUC__)
-#if (__GNUC__ < 3)
-#pragma interface
+  #if defined(__GNUC__)
+    #if (__GNUC__ < 3)
+      #pragma interface
+    #endif
+  #else
+    #pragma interface
+  #endif
 #endif
-#else
-#pragma interface
-#endif
-#endif
 
 /**
  * Description not yet available.
  * \param
  */
-class dvect_ptr_ptr
-{
-   dvector **m;
-};
+    class dvect_ptr_ptr
+    {
+      dvector ** m;
+    };
 
 /**
  * Description not yet available.
  * \param
  */
-class dlink
-{
-   double_and_int di;
-   dlink *prev;
- public:			// comments
-   dlink * previous();
-   inline double_and_int *get_address()
-   {
-      return &di;
-   }				//access function
+    class dlink
+    {
+       double_and_int  di;
+       dlink *       prev;
+    public:  // comments
+      dlink * previous();
+      inline double_and_int * get_address()
+      {
+        return &di;
+      } //access function
 
-   //friend tempvar();
-   //friend class prevariable;
-   //friend class tempvar;
-   friend class dlist;
-   friend void gradcalc(int nvar, const dvector & g);
-   friend void slave_gradcalc(void);
-   friend void gradloop();
-   friend double_and_int *gradnew();
-   friend void allocate_dvariable_space(void);
-};
+      //friend tempvar();
+      //friend class prevariable;
+      //friend class tempvar;
+      friend class dlist;
+      friend void gradcalc(int nvar,const dvector& g);
+      friend void slave_gradcalc(void);
+      friend void gradloop();
+      friend double_and_int * gradnew();
+      friend void allocate_dvariable_space(void);
+    };
 
 /**
  * Description not yet available.
  * \param
  */
-class dlist
-{
-   dlink *last;
-   unsigned int last_offset;
-   unsigned int nlinks;
-   dlink **dlink_addresses;
-   friend double_and_int *gradnew();
-   friend void df_check_derivative_values(void);
-   friend void df_check_derivative_values_indexed(void);
-   friend void df_check_derivative_values_indexed_break(void);
+    class dlist
+    {
+      dlink * last;
+      unsigned int last_offset;
+      unsigned int nlinks;
+      dlink ** dlink_addresses;
+      friend double_and_int * gradnew();
+      friend void df_check_derivative_values(void);
+      friend void df_check_derivative_values_indexed(void);
+      friend void df_check_derivative_values_indexed_break(void);
 
- public:
-   dlist();			// constructor
-   void check_list(void);	// check list integrity
-   ~dlist();			// destructor
-   dlink *create();		//create a new link 
-   void free_remove(dlink * rem);
-   dlink *append(dlink *);	// add a link
-   dlink *last_remove();
-   friend void funnel_gradcalc(void);
-   friend void slave_gradcalc(void);
-   friend void gradcalc(int nvar, const dvector & g);
-   friend void gradloop();
-   friend void gradient_structure::restore_variables();
-   friend void gradient_structure::save_variables();
-   friend void gradient_structure::jacobcalc(int nvar,
-					     const dmatrix & jac);
-   friend void allocate_dvariable_space(void);
-   //friend void gradient_structure::funnel_jacobcalc(void);
-   friend void gradient_structure::jacobcalc(int nvar,
-					     const ofstream & jac);
-   friend void gradient_structure::jacobcalc(int nvar,
-					     const uostream & jac);
-   friend void funnel_derivatives(void);
-};
+    public:
+      dlist();  // constructor
+      void check_list(void);  // check list integrity
+     ~dlist();  // destructor
+      dlink * create();     //create a new link 
+      void free_remove(dlink * rem);
+      dlink * append(dlink *);  // add a link
+      dlink* last_remove();
+      friend void funnel_gradcalc(void);
+      friend void slave_gradcalc(void);
+      friend void gradcalc(int nvar,const dvector& g);
+      friend void gradloop();
+      friend void gradient_structure::restore_variables();
+      friend void gradient_structure::save_variables();
+      friend void gradient_structure::jacobcalc(int nvar,const dmatrix& jac);
+      friend void allocate_dvariable_space(void);
+      //friend void gradient_structure::funnel_jacobcalc(void);
+      friend void gradient_structure::jacobcalc(int nvar,const ofstream& jac);
+      friend void gradient_structure::jacobcalc(int nvar,const uostream& jac);
+      friend void funnel_derivatives(void);
+    };
 
-class indvar_offset_list;
+    class indvar_offset_list;
 
 /**
  * Description not yet available.
  * \param
  */
-class grad_stack_entry
-{
- public:
-   void (*func) (void);
-   double *dep_addr;
-   double *ind_addr1;
-   double mult1;
-   double *ind_addr2;
-   double mult2;
- public:
-   friend void gradcalc(int nvar, const dvector & g);
-   friend void slave_gradcalc(void);
-   friend void gradloop();
-   friend void default_evaluation(void);
-   friend class grad_stack;
-   friend void gradient_structure::jacobcalc(int nvar,
-					     const dmatrix & jac);
-   //friend void gradient_structure::funnel_jacobcalc(void);
-};
-void default_evaluation3ind(void);
+    class grad_stack_entry
+    {
+    public:
+      void (* func) (void);
+      double * dep_addr;
+      double * ind_addr1;
+      double  mult1;
+      double * ind_addr2;
+      double  mult2;
+    public:
+      friend void gradcalc(int nvar,const dvector& g);
+      friend void slave_gradcalc(void);
+      friend void gradloop();
+      friend void default_evaluation(void);
+      friend class grad_stack;
+      friend void gradient_structure::jacobcalc(int nvar,const dmatrix& jac);
+      //friend void gradient_structure::funnel_jacobcalc(void);
+    };
+    void default_evaluation3ind(void);
 
 /**
  * Description not yet available.
  * \param
  */
-class grad_stack
-{
-   grad_stack_entry *true_ptr_first;
-   grad_stack_entry *ptr_first;
-   grad_stack_entry *ptr_last;
+    class grad_stack
+    {
+      grad_stack_entry * true_ptr_first;
+      grad_stack_entry * ptr_first;
+      grad_stack_entry * ptr_last;
 #ifdef __BORLANDC__
-   long int length;
-   long int true_length;
+      long int length;
+      long int true_length;
 #else
-   long long int length;
-   long long int true_length;
+      long long int length;
+      long long int true_length;
 #endif
- public:
-   grad_stack_entry * ptr;
- private:
-   //lvector * table;
-   // js
-   int _GRADFILE_PTR;		// should be int gradfile_handle;
-   int _GRADFILE_PTR1;		// should be int gradfile_handle;
-   int _GRADFILE_PTR2;		// should be int gradfile_handle;
-   int _VARSSAV_PTR;		// should be int gradfile_handle;
-   char gradfile_name[61];
-   char gradfile_name1[61];
-   char gradfile_name2[61];
-   char var_store_file_name[61];
-   void create_gradfile();
+    public:
+      grad_stack_entry * ptr;
+    private:
+      //lvector * table;
+      // js
+      int _GRADFILE_PTR; // should be int gradfile_handle;
+      int _GRADFILE_PTR1; // should be int gradfile_handle;
+      int _GRADFILE_PTR2; // should be int gradfile_handle;
+      int _VARSSAV_PTR; // should be int gradfile_handle;
+      char gradfile_name[101];
+      char gradfile_name1[101];
+      char gradfile_name2[101];
+      char var_store_file_name[101];
+      void create_gradfile();
 #ifdef __BORLANDC__
-   long end_pos;
-   long end_pos1;
-   long end_pos2;
+      long end_pos;
+      long end_pos1;
+      long end_pos2;
 #else
-   long long end_pos;
-   long long end_pos1;
-   long long end_pos2;
+      long long end_pos;
+      long long end_pos1;
+      long long end_pos2;
 #endif
-   dmatrix *table;
- public:
-   friend void gradcalc(int nvar, const dvector & g);
-   friend void slave_gradcalc(void);
-   friend void funnel_gradcalc(void);
-   friend void default_evaluation(void);
-   friend void default_evaluation3ind(void);
-   friend void reset_gradient_stack(void);
-   friend void default_evaluation4ind(void);
-   friend void grad_chk(void);
-   friend void gradloop();
-   friend void cleanup_temporary_files();
-   ostream & operator  <<(grad_stack);
-   void print();
-   grad_stack();
-   ~grad_stack();
-   void write_grad_stack_buffer(void);
+      dmatrix * table;
+    public:
+      friend void gradcalc(int nvar,const dvector& g);
+      friend void slave_gradcalc(void);
+      friend void funnel_gradcalc(void);
+      friend void default_evaluation(void);
+      friend void default_evaluation3ind(void);
+      friend void reset_gradient_stack(void);
+      friend void default_evaluation4ind(void);
+      friend void grad_chk(void);
+      friend void gradloop();
+      friend void cleanup_temporary_files();
+      ostream& operator  <<(grad_stack);
+     void print();
+      grad_stack();
+     ~grad_stack();
+      void write_grad_stack_buffer(void);
 
-   void set_gradient_stack(void (*func) (void),
-			   double *dep_addr, double *ind_addr1 =
-			   NULL, double mult1 = 0, double *ind_addr2 =
-			   NULL, double mult2 = 0);
+       void set_gradient_stack(void (* func) (void),
+	 double * dep_addr,double * ind_addr1=NULL, double mult1=0,
+	 double * ind_addr2=NULL, double mult2=0);
 
-   void set_gradient_stack(void (*func) (void),
-			   double *dep_addr, double *ind_addr1,
-			   double *ind_addr2);
+       void set_gradient_stack(void (* func) (void),
+	 double * dep_addr,double * ind_addr1,double * ind_addr2);
 
 
-   void set_gradient_stack0(void (*func) (void), double *dep_addr);
+      void set_gradient_stack0(void (* func)(void),
+        double * dep_addr);
 
-   void set_gradient_stack1(void (*func) (void),
-			    double *dep_addr, double *ind_addr1);
+       void set_gradient_stack1(void (* func) (void),
+	 double * dep_addr,double * ind_addr1);
 
-   void set_gradient_stack2(void (*func) (void),
-			    double *dep_addr, double *ind_addr1,
-			    double mult1);
+       void set_gradient_stack2(void (* func) (void),
+	 double * dep_addr,double * ind_addr1, double mult1);
 
-   void set_gradient_stack4(void (*func) (void),
-			    double *dep_addr, double *ind_addr1,
-			    double *ind_addr2);
+       void set_gradient_stack4(void (* func) (void),
+	 double * dep_addr,double * ind_addr1, double * ind_addr2);
 
-   void set_gradient_stack(void (*func) (void),
-			   double *dep_addr, double *ind_addr1,
-			   double mult1, double *ind_addr2, double mult2,
-			   double *ind_addr3, double mult3,
-			   double *ind_addr4, double mult4);
+       void set_gradient_stack(void (* func)(void),
+        double * dep_addr,double * ind_addr1, double mult1, double * ind_addr2,
+        double mult2,double * ind_addr3, double mult3,double * ind_addr4,
+        double mult4);
+    
+       void set_gradient_stack(void (* func)(void),
+        double * dep_addr,double * ind_addr1, double mult1, double * ind_addr2,
+        double mult2,double * ind_addr3, double mult3);
+    
+      int read_grad_stack_buffer(my_off_t& lpos);
+      void set_gradient_stack(void (*ptr)(void));
+      void set_gbuffer_pointers(void);
+       //js
+      void increment_current_gradfile_ptr(void);
+      int decrement_current_gradfile_ptr(void);
+      //void open_gradfile();
+      //void close_gradfile();
+      #ifndef __MSC__
+	int& gradfile_handle();
+      #else
+	int gradfile_handle();
+      #endif
+      char* get_gradfile_name();
+      friend class gradient_structure;
+      //int get_ngradfiles();
+    }; // end of grad_stack
 
-   void set_gradient_stack(void (*func) (void),
-			   double *dep_addr, double *ind_addr1,
-			   double mult1, double *ind_addr2, double mult2,
-			   double *ind_addr3, double mult3);
 
-   int read_grad_stack_buffer(my_off_t & lpos);
-   void set_gradient_stack(void (*ptr) (void));
-   void set_gbuffer_pointers(void);
-   //js
-   void increment_current_gradfile_ptr(void);
-   int decrement_current_gradfile_ptr(void);
-   //void open_gradfile();
-   //void close_gradfile();
-#ifndef __MSC__
-   int &gradfile_handle();
-#else
-   int gradfile_handle();
-#endif
-   char *get_gradfile_name();
-   friend class gradient_structure;
-   //int get_ngradfiles();
-};				// end of grad_stack
-
-
 #ifdef OPT_LIB
 /**
  * Description not yet available.
  * \param
  */
-inline void grad_stack::set_gradient_stack(void (*func) (void),
-					   double *dep_addr,
-					   double *ind_addr1, double mult1,
-					   double *ind_addr2, double mult2)
-{
-#ifdef NO_DERIVS
-   if (!gradient_structure::no_derivatives)
-   {
-#endif
+    inline void grad_stack::set_gradient_stack(void (* func)(void),
+      double * dep_addr,double * ind_addr1, double mult1, double * ind_addr2,
+      double mult2)
+    {
+      #ifdef NO_DERIVS
+	if (!gradient_structure::no_derivatives)
+	{
+      #endif
 #     if defined(MYDEBUG)
-      int wrote_buffer = 0;
+          int wrote_buffer=0;
 #     endif
-      if (ptr > ptr_last)
-      {
-	 // current buffer is full -- write it to disk and reset pointer
-	 // and counter
-	 this->write_grad_stack_buffer();
+	  if (ptr > ptr_last)
+	  {
+	     // current buffer is full -- write it to disk and reset pointer
+	     // and counter
+	     this->write_grad_stack_buffer();
 #     if defined(MYDEBUG)
-	 wrote_buffer = 1;
+             wrote_buffer=1;
 #     endif
-      }
+	  }
 #     if defined(MYDEBUG)
-      if (wrote_buffer == 1)
-      {
-	 cout << "WROTE BUFFER" << endl;
-      }
+          if (wrote_buffer==1)
+          {
+            cout << "WROTE BUFFER" << endl;
+          }
 #     endif
-      ptr->func = func;
-      ptr->dep_addr = dep_addr;
-      ptr->ind_addr1 = ind_addr1;
-      ptr->mult1 = mult1;
-      ptr->ind_addr2 = ind_addr2;
-      ptr->mult2 = mult2;
-      ptr++;
-#ifdef NO_DERIVS
-   }
-#endif
-}
+	  ptr->func = func;
+	  ptr->dep_addr = dep_addr;
+	  ptr->ind_addr1 = ind_addr1;
+	  ptr->mult1=mult1;
+	  ptr->ind_addr2 = ind_addr2;
+	  ptr->mult2=mult2;
+	  ptr++;
+      #ifdef NO_DERIVS
+	}
+      #endif
+    }
 #else
   //  void grad_stack::set_gradient_stack(void (* func)(void),
    //   double * dep_addr,double * ind_addr1, double mult1, double * ind_addr2,
@@ -1534,320 +1455,419 @@
  * Description not yet available.
  * \param
  */
-inline void grad_stack::set_gradient_stack(void (*func) (void),
-					   double *dep_addr,
-					   double *ind_addr1, double mult1,
-					   double *ind_addr2, double mult2,
-					   double *ind_addr3, double mult3)
-{
-#ifdef NO_DERIVS
-   if (!gradient_structure::no_derivatives)
-   {
-#endif
-      if (ptr > ptr_last)
-      {
-	 // current buffer is full -- write it to disk and reset pointer
-	 // and counter
-	 this->write_grad_stack_buffer();
-      }
-      ptr->func = NULL;
-      ptr->dep_addr = dep_addr;
-      ptr->ind_addr1 = ind_addr1;
-      ptr->mult1 = mult1;
-      ptr->ind_addr2 = ind_addr2;
-      ptr->mult2 = mult2;
-      ptr++;
-      if (ptr > ptr_last)
-      {
-	 // current buffer is full -- write it to disk and reset pointer
-	 // and counter
-	 this->write_grad_stack_buffer();
-      }
-      ptr->func = func;
-      ptr->ind_addr1 = ind_addr3;
-      ptr->mult1 = mult3;
-      ptr++;
-#ifdef NO_DERIVS
-   }
-#endif
-}
+    inline void grad_stack::set_gradient_stack(void (* func)(void),
+      double * dep_addr,double * ind_addr1, double mult1, double * ind_addr2,
+      double mult2,double * ind_addr3, double mult3)
+    {
+      #ifdef NO_DERIVS
+	if (!gradient_structure::no_derivatives)
+	{
+      #endif
+	  if (ptr > ptr_last)
+	  {
+	     // current buffer is full -- write it to disk and reset pointer
+	     // and counter
+	     this->write_grad_stack_buffer();
+	  }
+	  ptr->func = NULL;
+	  ptr->dep_addr = dep_addr;
+	  ptr->ind_addr1 = ind_addr1;
+	  ptr->mult1=mult1;
+	  ptr->ind_addr2 = ind_addr2;
+	  ptr->mult2=mult2;
+	  ptr++;
+	  if (ptr > ptr_last)
+	  {
+	     // current buffer is full -- write it to disk and reset pointer
+	     // and counter
+	     this->write_grad_stack_buffer();
+	  }
+	  ptr->func = func;
+	  ptr->ind_addr1 = ind_addr3;
+	  ptr->mult1=mult3;
+	  ptr++;
+      #ifdef NO_DERIVS
+	}
+      #endif
+    }
 
 /**
  * Description not yet available.
  * \param
  */
-inline void grad_stack::set_gradient_stack(void (*func) (void),
-					   double *dep_addr,
-					   double *ind_addr1, double mult1,
-					   double *ind_addr2, double mult2,
-					   double *ind_addr3, double mult3,
-					   double *ind_addr4, double mult4)
-{
-#ifdef NO_DERIVS
-   if (!gradient_structure::no_derivatives)
-   {
-#endif
-      if (ptr > ptr_last)
-      {
-	 // current buffer is full -- write it to disk and reset pointer
-	 // and counter
-	 this->write_grad_stack_buffer();
-      }
-      ptr->func = NULL;
-      ptr->dep_addr = dep_addr;
-      ptr->ind_addr1 = ind_addr1;
-      ptr->mult1 = mult1;
-      ptr->ind_addr2 = ind_addr2;
-      ptr->mult2 = mult2;
-      ptr++;
-      if (ptr > ptr_last)
-      {
-	 // current buffer is full -- write it to disk and reset pointer
-	 // and counter
-	 this->write_grad_stack_buffer();
-      }
-      ptr->func = func;
-      ptr->ind_addr1 = ind_addr3;
-      ptr->mult1 = mult3;
-      ptr->ind_addr2 = ind_addr4;
-      ptr->mult2 = mult4;
-      ptr++;
-#ifdef NO_DERIVS
-   }
-#endif
-}
+    inline void grad_stack::set_gradient_stack(void (* func)(void),
+      double * dep_addr,double * ind_addr1, double mult1, double * ind_addr2,
+      double mult2,double * ind_addr3, double mult3,double * ind_addr4,
+      double mult4)
+    {
+      #ifdef NO_DERIVS
+	if (!gradient_structure::no_derivatives)
+	{
+      #endif
+	  if (ptr > ptr_last)
+	  {
+	     // current buffer is full -- write it to disk and reset pointer
+	     // and counter
+	     this->write_grad_stack_buffer();
+	  }
+	  ptr->func = NULL;
+	  ptr->dep_addr = dep_addr;
+	  ptr->ind_addr1 = ind_addr1;
+	  ptr->mult1=mult1;
+	  ptr->ind_addr2 = ind_addr2;
+	  ptr->mult2=mult2;
+	  ptr++;
+	  if (ptr > ptr_last)
+	  {
+	     // current buffer is full -- write it to disk and reset pointer
+	     // and counter
+	     this->write_grad_stack_buffer();
+	  }
+	  ptr->func = func;
+	  ptr->ind_addr1 = ind_addr3;
+	  ptr->mult1=mult3;
+	  ptr->ind_addr2 = ind_addr4;
+	  ptr->mult2=mult4;
+	  ptr++;
+      #ifdef NO_DERIVS
+	}
+      #endif
+    }
 
 /**
  * Description not yet available.
  * \param
  */
-inline void grad_stack::set_gradient_stack(void (*func) (void),
-					   double *dep_addr,
-					   double *ind_addr1,
-					   double *ind_addr2)
-{
-#ifdef NO_DERIVS
-   if (!gradient_structure::no_derivatives)
-   {
-#endif
-      if (ptr > ptr_last)
-      {
-	 // current buffer is full -- write it to disk and reset pointer
-	 // and counter
-	 this->write_grad_stack_buffer();
-      }
-      ptr->func = func;
-      ptr->dep_addr = dep_addr;
-      ptr->ind_addr1 = ind_addr1;
-      ptr->ind_addr2 = ind_addr2;
-      ptr++;
-#ifdef NO_DERIVS
-   }
-#endif
-}
+    inline void grad_stack::set_gradient_stack(void (* func)(void),
+      double * dep_addr,double * ind_addr1,double * ind_addr2)
+    {
+      #ifdef NO_DERIVS
+	if (!gradient_structure::no_derivatives)
+	{
+      #endif
+	  if (ptr > ptr_last)
+	  {
+	     // current buffer is full -- write it to disk and reset pointer
+	     // and counter
+	     this->write_grad_stack_buffer();
+	  }
+	  ptr->func = func;
+	  ptr->dep_addr = dep_addr;
+	  ptr->ind_addr1 = ind_addr1;
+	  ptr->ind_addr2 = ind_addr2;
+	  ptr++;
+      #ifdef NO_DERIVS
+	}
+      #endif
+    }
 
 /**
  * Description not yet available.
  * \param
  */
-inline void grad_stack::set_gradient_stack2(void (*func) (void),
-					    double *dep_addr,
-					    double *ind_addr1,
-					    double mult1)
-{
-#ifdef NO_DERIVS
-   if (!gradient_structure::no_derivatives)
-   {
-#endif
-      if (ptr > ptr_last)
-      {
-	 // current buffer is full -- write it to disk and reset pointer
-	 // and counter
-	 this->write_grad_stack_buffer();
-      }
-      ptr->func = func;
-      ptr->dep_addr = dep_addr;
-      ptr->ind_addr1 = ind_addr1;
-      ptr->mult1 = mult1;
-      ptr++;
-#ifdef NO_DERIVS
-   }
-#endif
-}
+    inline void grad_stack::set_gradient_stack2(void (* func)(void),
+      double * dep_addr,double * ind_addr1, double mult1)
+    {
+      #ifdef NO_DERIVS
+        if (!gradient_structure::no_derivatives)
+        {
+      #endif
+          if (ptr > ptr_last)
+          {
+             // current buffer is full -- write it to disk and reset pointer
+             // and counter
+             this->write_grad_stack_buffer();
+          }
+          ptr->func = func;
+          ptr->dep_addr = dep_addr;
+          ptr->ind_addr1 = ind_addr1;
+          ptr->mult1=mult1;
+          ptr++;
+      #ifdef NO_DERIVS
+        }
+      #endif
+    }
 
 /**
  * Description not yet available.
  * \param
  */
-inline void grad_stack::set_gradient_stack4(void (*func) (void),
-					    double *dep_addr,
-					    double *ind_addr1,
-					    double *ind_addr2)
-{
-#ifdef NO_DERIVS
-   if (!gradient_structure::no_derivatives)
-   {
-#endif
-      if (ptr > ptr_last)
-      {
-	 // current buffer is full -- write it to disk and reset pointer
-	 // and counter
-	 this->write_grad_stack_buffer();
-      }
-      ptr->func = func;
-      ptr->dep_addr = dep_addr;
-      ptr->ind_addr1 = ind_addr1;
-      ptr->ind_addr2 = ind_addr2;
-      ptr++;
-#ifdef NO_DERIVS
-   }
-#endif
-}
+    inline void grad_stack::set_gradient_stack4(void (* func)(void),
+      double * dep_addr,double * ind_addr1, double * ind_addr2)
+    {
+      #ifdef NO_DERIVS
+	if (!gradient_structure::no_derivatives)
+	{
+      #endif
+	  if (ptr > ptr_last)
+	  {
+	     // current buffer is full -- write it to disk and reset pointer
+	     // and counter
+	     this->write_grad_stack_buffer();
+	  }
+	  ptr->func = func;
+	  ptr->dep_addr = dep_addr;
+	  ptr->ind_addr1 = ind_addr1;
+	  ptr->ind_addr2 = ind_addr2;
+	  ptr++;
+      #ifdef NO_DERIVS
+	}
+      #endif
+    }
 
+
+
+   /*
+    inline void grad_stack::set_gradient_stack(void (* func)(void),
+      double * dep_addr,double * ind_addr1, double mult1)
+    {
+      #ifdef NO_DERIVS
+	if (!gradient_structure::no_derivatives)
+	{
+      #endif
+	  if (ptr > ptr_last)
+	  {
+	     // current buffer is full -- write it to disk and reset pointer
+	     // and counter
+	     this->write_grad_stack_buffer();
+	  }
+	  ptr->func = func;
+	  ptr->dep_addr = dep_addr;
+	  ptr->ind_addr1 = ind_addr1;
+	  ptr->mult1=mult1;
+          ptr++;
+      #ifdef NO_DERIVS
+        }
+      #endif
+    }
+    */
+   /*
+    void grad_stack::set_gradient_stack1(void (* func)(void),
+      double * dep_addr,double * ind_addr1)
+    {
+      #ifdef NO_DERIVS
+        if (!gradient_structure::no_derivatives)
+        {
+      #endif
+          if (ptr > ptr_last)
+          {
+             // current buffer is full -- write it to disk and reset pointer
+             // and counter
+             this->write_grad_stack_buffer();
+          }
+          ptr->func = func;
+          ptr->dep_addr = dep_addr;
+          ptr->ind_addr1 = ind_addr1;
+          ptr++;
+      #ifdef NO_DERIVS
+        }
+      #endif
+    }
+  */
+
+   /*
+    inline void grad_stack::set_gradient_stack(void (* func)(void),
+      double * dep_addr,double * ind_addr1)
+    {
+      #ifdef NO_DERIVS
+        if (!gradient_structure::no_derivatives)
+        {
+      #endif
+          if (ptr > ptr_last)
+          {
+             // current buffer is full -- write it to disk and reset pointer
+             // and counter
+             this->write_grad_stack_buffer();
+          }
+          ptr->func = func;
+          ptr->dep_addr = dep_addr;
+          ptr->ind_addr1 = ind_addr1;
+          ptr++;
+      #ifdef NO_DERIVS
+        }
+      #endif
+    }
+   */
+
+   /*
+    inline void grad_stack::set_gradient_stack0(void (* func)(void),
+      double * dep_addr)
+    {
+      #ifdef NO_DERIVS
+        if (!gradient_structure::no_derivatives)
+        {
+      #endif
+          if (ptr > ptr_last)
+          {
+             // current buffer is full -- write it to disk and reset pointer
+             // and counter
+             this->write_grad_stack_buffer();
+          }
+          ptr->func = func;
+          ptr->dep_addr = dep_addr;
+          ptr++;
+      #ifdef NO_DERIVS
+        }
+      #endif
+    }
+   */
+
+   /*
+    inline void grad_stack::set_gradient_stack(void (* func)(void),
+      double * dep_addr)
+    {
+      #ifdef NO_DERIVS
+        if (!gradient_structure::no_derivatives)
+        {
+      #endif
+          if (ptr > ptr_last)
+          {
+             // current buffer is full -- write it to disk and reset pointer
+             // and counter
+             this->write_grad_stack_buffer();
+          }
+          ptr->func = func;
+          ptr->dep_addr = dep_addr;
+          ptr++;
+      #ifdef NO_DERIVS
+        }
+      #endif
+    }
+*/
+
 /**
  * Description not yet available.
  * \param
  */
-inline void grad_stack::set_gradient_stack(void (*func) (void))
-{
-#ifdef NO_DERIVS
-   if (!gradient_structure::no_derivatives)
-   {
-#endif
-      if (ptr > ptr_last)
-      {
-	 // current buffer is full -- write it to disk and reset pointer
-	 // and counter
-	 this->write_grad_stack_buffer();
-      }
+    inline void grad_stack::set_gradient_stack(void (*func)(void))
+    {
+      #ifdef NO_DERIVS
+        if (!gradient_structure::no_derivatives)
+        {
+      #endif
+          if (ptr > ptr_last)
+          {
+            // current buffer is full -- write it to disk and reset pointer
+            // and counter
+            this->write_grad_stack_buffer();
+          }
 
-      ptr->dep_addr = NULL;
-      ptr->func = func;
-      ptr->ind_addr2 = NULL;	// want to put a long int                                            //into the memory space of a double
-      ptr->mult2 = 0;
-      ptr++;
-#ifdef NO_DERIVS
-   }
-#endif
-}
+          ptr->dep_addr = NULL;
+          ptr->func = func;
+          ptr->ind_addr2 = NULL ;// want to put a long int                                            //into the memory space of a double
+          ptr->mult2=0;
+          ptr++;
+      #ifdef NO_DERIVS
+        }
+      #endif
+    }
 
 /**
  * Description not yet available.
  * \param
  */
-class indvar_offset_list
-{
-   int nvar;			// The number of independent variables
-   double **address;
+    class indvar_offset_list
+    {
+      int nvar; // The number of independent variables
+      double **  address;
+  
+    public:
+      friend class gradient_structure;
+      inline double * get_address(const int& i) { return(address[i]);}
+      void put_address(unsigned int& i, double * iaddress) 
+      { 
+        address[i] = iaddress;
+        //  cerr << "In put_address i = " << i << "\n";
+      }
+    };
 
- public:
-   friend class gradient_structure;
-   inline double *get_address(const int &i)
-   {
-      return address[i];
-   }
-   void put_address(unsigned int &i, double *iaddress)
-   {
-      address[i] = iaddress;
-      //  cerr << "In put_address i = " << i << "\n";
-   }
-};
+    void gradfree(dlink *);
 
-void gradfree(dlink *);
+  class prevariable_position;
 
-class prevariable_position;
-
 /**
   Base class for dvariable.
   Basis for reverse mode automatic differentiation.
   \ingroup BAD
  */
-class prevariable
-{
- protected:
+  class prevariable
+  {
+  protected:
 #ifndef __SUN__
-   prevariable(void)
-   {
-   }
+    prevariable(void) { }
 #endif
 #ifndef __NDPX__
-   prevariable(double_and_int * u)
-   {
-      v = u;
-   }
+    prevariable(double_and_int * u) {v=u;}
 #endif
 
- public:
-   double_and_int * v;		///< pointer to the data
-   friend class dvar_vector_iterator;
-   friend class dvar_vector;
-   friend class dvar_matrix;
-   friend class dvar3_array;
-   //shclass sc;
-   friend class indvar_offset_list;
-   friend class gradient_structure;
-   friend double_and_int *gradnew();
-   friend void make_indvar_list(int, dvariable *);
+  public:
+    double_and_int * v; ///< pointer to the data
+    friend class dvar_vector_iterator;
+    friend class dvar_vector;
+    friend class dvar_matrix;
+    friend class dvar3_array;
+    //shclass sc;
+    friend class indvar_offset_list;
+    friend class gradient_structure;
+    friend double_and_int * gradnew();
+    friend void make_indvar_list(int ,dvariable *);
 
-   friend class banded_symmetric_dvar_matrix;
-   friend class banded_lower_triangular_dvar_matrix;
-   friend double &value(const prevariable & v1);
+    friend class banded_symmetric_dvar_matrix;
+    friend class banded_lower_triangular_dvar_matrix;
+    friend double& value(const prevariable& v1);
 
-   friend double *address(const prevariable & v1);
+    friend double * address(const prevariable& v1);
 
-   //void gradfree(dlink * v)
+    //void gradfree(dlink * v)
 
-   friend prevariable & operator*(const prevariable & v1,
-				  const prevariable & v2);
+    friend prevariable& operator *(const prevariable& v1,const prevariable& v2);
 
-   friend prevariable & operator*(double v1, const prevariable & v2);
+    friend prevariable& operator *( double v1,const prevariable& v2);
 
-   friend prevariable & operator*(const prevariable & v1, double v2);
+    friend prevariable& operator *(const prevariable& v1, double v2);
 
-   friend prevariable & operator/(const prevariable & t1,
-				  const prevariable & t2);
+    friend prevariable& operator / (const prevariable& t1,const prevariable& t2);
 
-   friend prevariable & operator/(double t1, const prevariable & t2);
+    friend prevariable& operator / ( double t1,const prevariable& t2);
 
-   friend prevariable & operator/(const prevariable & t1, double t2);
+    friend prevariable& operator / (const prevariable& t1, double t2);
 
-   friend prevariable & sin(const prevariable & t1);
+    friend prevariable& sin(const prevariable& t1);
 
-   friend prevariable & fabs(const prevariable & t1);
-   friend prevariable & sigmoid(const prevariable & t1);
+    friend prevariable& fabs(const prevariable& t1);
+    friend prevariable& sigmoid(const prevariable& t1);
 
-   friend prevariable & sfabs(const prevariable & t1);	//"smoothed absolute value function
+    friend prevariable& sfabs(const prevariable& t1); //"smoothed absolute value function
 
-   friend prevariable & sqrt(const prevariable & t1);
-   friend prevariable & sqr(const prevariable & t1);
+    friend prevariable& sqrt(const prevariable& t1);
+    friend prevariable& sqr(const prevariable& t1);
 
-   friend prevariable & exp(const prevariable & t1);
+    friend prevariable& exp(const prevariable& t1);
 
-   friend prevariable & atan(const prevariable & t1);
+    friend prevariable& atan(const prevariable& t1);
 
-   friend prevariable & tan(const prevariable & t1);
-   friend prevariable & tanh(const prevariable & t1);
+    friend prevariable& tan(const prevariable& t1);
+    friend prevariable& tanh(const prevariable& t1);
 
-   friend prevariable & atan2(const prevariable & t1,
-			      const prevariable & t2);
-   friend prevariable & atan2(const prevariable & t1, double t2);
-   friend prevariable & atan2(double t1, const prevariable & t2);
+    friend prevariable& atan2(const prevariable& t1,const prevariable& t2);
+    friend prevariable& atan2(const prevariable& t1, double t2);
+    friend prevariable& atan2( double t1,const prevariable& t2);
 
-   friend prevariable & acos(const prevariable & t1);
+    friend prevariable& acos(const prevariable& t1);
 
-   friend prevariable & asin(const prevariable & t1);
+    friend prevariable& asin(const prevariable& t1);
 
-   friend prevariable & cos(const prevariable & t1);
-   friend prevariable & sinh(const prevariable & t1);
-   friend prevariable & cosh(const prevariable & t1);
+    friend prevariable& cos(const prevariable& t1);
+    friend prevariable& sinh(const prevariable& t1);
+    friend prevariable& cosh(const prevariable& t1);
 
-   friend prevariable & log(const prevariable & t1);
-   friend prevariable & log10(const prevariable & t1);
+    friend prevariable& log(const prevariable& t1);
+    friend prevariable& log10(const prevariable& t1);
 
-   friend prevariable & ldexp(const prevariable &, const int &);
+    friend prevariable& ldexp(const prevariable&, const int&);
 
 
- public:
+  public:
 
    void save_prevariable_position(void) const;
    prevariable_position restore_prevariable_position(void);
@@ -1856,157 +1876,136 @@
    double restore_prevariable_derivative(void);
 
 
-   inline double *xadr()
-   {
-      return (&(v->x));
-   }
-   inline double &xval()
-   {
-      return ((v->x));
-   }
+   inline double * xadr() { return( &(v->x) ); }
+   inline double& xval() { return( (v->x) ); }
 
-   inline double_and_int *&get_v()
+   inline double_and_int * & get_v()
    {
-      return v;
+     return v;
    }
-#ifdef USE_CONST
-   inline double_and_int *get_v() const
-   {
-      return v;
-   }
-#endif
+   #ifdef USEconst
+     inline double_and_int *  get_v() const 
+     {
+       return v;
+     }
+   #endif
 
-   prevariable & operator=(const prevariable &);
-   prevariable & operator=(double);
-#if (__BORLANDC__  >= 0x0540)
-   prevariable & operator=(const prevariable &) const;
-   prevariable & operator=(double) const;
+   prevariable& operator=(const prevariable&);
+   prevariable& operator=( double );
+#if (__BORLANDC__  >= 0x0540) 
+   prevariable& operator=(const prevariable&)const ;
+   prevariable& operator=( double )const ;
 #endif
 
-   int operator==(const prevariable & v1) const;
-   int operator<=(const prevariable & v1) const;
-   int operator>=(const prevariable & v1) const;
-   int operator>(const prevariable & v1) const;
-   int operator<(const prevariable & v1) const;
-   int operator!=(const prevariable & v1) const;
+   int operator ==(const prevariable& v1) const;
+   int operator <=(const prevariable& v1) const;
+   int operator >=(const prevariable& v1) const;
+   int operator >(const prevariable& v1) const;
+   int operator <(const prevariable& v1) const;
+   int operator !=(const prevariable& v1) const;
 
-   int operator==(double v1) const;
-   int operator<=(double v1) const;
-   int operator>=(double v1) const;
-   int operator>(double v1) const;
-   int operator<(double v1) const;
-   int operator!=(double v1) const;
+   int operator ==( double v1) const;
+   int operator <=( double v1) const;
+   int operator >=( double v1) const;
+   int operator >( double v1) const;
+   int operator <( double v1) const;
+   int operator !=( double v1) const;
 #if defined(USE_DDOUBLE)
-   int operator==(int v1) const;
-   int operator<=(int v1) const;
-   int operator>=(int v1) const;
-   int operator>(int v1) const;
-   int operator<(int v1) const;
-   int operator!=(int v1) const;
+   int operator ==( int v1) const;
+   int operator <=( int v1) const;
+   int operator >=( int v1) const;
+   int operator >( int v1) const;
+   int operator <( int v1) const;
+   int operator !=( int v1) const;
 #endif
 
- public:
+  public:
 #ifdef __SUN__
-   prevariable(void)
-   {
-   }
+    prevariable(void) { }
 #endif
 #ifdef __NDPX__
-   prevariable(double_and_int * u)
-   {
-      v = u;
-   }
+    prevariable(double_and_int * u) {v=u;}
 #endif
 
-   void initialize(void);
+    void initialize(void);
 
-   friend char *fform(const char *, const prevariable &);
+    friend char* fform(const char*,const prevariable&);
 
-   void operator+=(const prevariable & t1);
-   void operator +=(double t1);
+    void operator +=(const prevariable& t1);
+    void operator +=( double t1);
 
-   void operator-=(const prevariable & t1);
-   void operator -=(double t1);
+    void operator -=(const prevariable& t1);
+    void operator -=( double t1);
 
-   void operator/=(const prevariable & v1);
-   void operator /=(double v1);
+    void operator /=(const prevariable& v1);
+    void operator /=( double v1);
 
-   void operator*=(const prevariable & v1);
-   void operator *=(double v1);
+    void operator *=(const prevariable& v1);
+    void operator *=( double v1);
 
-   friend prevariable & operator+(const prevariable & v1,
-				  const prevariable & v2);
+    friend prevariable& operator +(const prevariable& v1,const prevariable& v2);
 
-   friend prevariable & operator+(double v1, const prevariable & v2);
+    friend prevariable& operator +( double v1,const prevariable& v2);
 
-   friend prevariable & operator+(const prevariable & v1, double v2);
+    friend prevariable& operator +(const prevariable& v1, double v2);
 
-   friend prevariable & operator-(const prevariable & v1);
+    friend prevariable& operator -(const prevariable& v1);
 
-   friend prevariable & operator-(const prevariable & v1,
-				  const prevariable & v2);
+    friend prevariable& operator -(const prevariable& v1,const prevariable& v2);
 
-   friend prevariable & operator-(double v1, const prevariable & v2);
+    friend prevariable& operator -( double v1,const prevariable& v2);
 
-   friend prevariable & operator-(const prevariable & v1, double v2);
+    friend prevariable& operator -(const prevariable& v1, double v2);
 
-   friend prevariable & pow(const prevariable & t1,
-			    const prevariable & t2);
+    friend prevariable& pow(const prevariable& t1,const prevariable& t2);
 
-   friend prevariable & pow(const prevariable & t1, double t2);
+    friend prevariable& pow(const prevariable& t1, double t2);
 
-   friend prevariable & pow(double t1, const prevariable & t2);
+    friend prevariable& pow( double t1,const prevariable& t2);
 
-};				// end of class prevariable
+  }; // end of class prevariable
 
-inline double &value(const prevariable & v1)
-{
-   return v1.v->x;
-}
+  inline double& value(const prevariable& v1) { return(v1.v->x); }
+  inline double * address(const prevariable& v1) { return(&(v1.v->x)); }
 
-inline double *address(const prevariable & v1)
-{
-   return (&(v1.v->x));
-}
 
+  prevariable& operator << (const prevariable& v1,const prevariable& v2);
+  dvar_vector& operator << (const dvar_vector& v1,const dvar_vector& v2);
+  dvar_matrix& operator << (const dvar_matrix& v1,const dvar_matrix& v2);
 
-prevariable & operator<<(const prevariable & v1, const prevariable & v2);
-dvar_vector & operator<<(const dvar_vector & v1, const dvar_vector & v2);
-dvar_matrix & operator<<(const dvar_matrix & v1, const dvar_matrix & v2);
+  class df1_one_variable;
+  class df1_two_variable;
+  class df1_three_variable;
 
-class df1_one_variable;
-class df1_two_variable;
-class df1_three_variable;
-
   /**
   Fundamental data type for reverse mode automatic differentiation.
   \ingroup BAD
  */
-class dvariable:public prevariable
-{
- public:
-   dvariable();
-   ~dvariable();
-   dvariable(double t);
-   dvariable(const int &t);
-   dvariable(kkludge_object);
-   dvariable(const prevariable &);
-   dvariable & operator=(const prevariable &);
-   dvariable & operator =(const df1_one_variable & v);
-   dvariable & operator =(const df1_two_variable & v);
-   dvariable & operator =(const df1_three_variable & v);
-   dvariable & operator=(double);
+  class dvariable : public prevariable
+  {
+  public:
+     dvariable();
+     ~dvariable();
+     dvariable( double t);
+     dvariable(const int& t);
+     dvariable(kkludge_object);
+     dvariable(const prevariable&);
+     dvariable& operator=(const prevariable&);
+     dvariable& operator = (const df1_one_variable& v);
+     dvariable& operator = (const df1_two_variable& v);
+     dvariable& operator = (const df1_three_variable& v);
+     dvariable& operator=( double);
 #if defined(USE_DDOUBLE)
 #  undef double
-   dvariable & operator=(double);
+     dvariable& operator=( double);
 #  define double dd_real
 #endif
-   dvariable(const dvariable &);
+     dvariable(const dvariable&);
 //#  if (__BORLANDC__  > 0x0520) 
 //     dvariable& operator+=(const prevariable&);
 //#  endif
 
-};				// end of class dvariable
+  }; // end of class dvariable
 
 #if defined(max)
 #undef max
@@ -2019,730 +2018,588 @@
  * Description not yet available.
  * \param
  */
-class funnel_dvariable:public dvariable
-{
- public:
-   dvariable & operator=(const prevariable &);
-};
+  class funnel_dvariable : public dvariable
+  {
+  public:
+     dvariable& operator=(const prevariable&);
+  };
 
-dvar_vector operator*(const dvar_vector & t1, double x);
-dvar_vector operator/(double x, const dvar_vector & t1);
-dvar_vector operator/(const dvar_vector & t1, double x);
-dvar_vector operator+(double x, const dvar_vector & t1);
-dvar_vector operator+(const dvar_vector & t1, double x);
-dvar_vector operator-(double x, const dvar_vector & t1);
-dvar_vector operator-(const dvar_vector & t1, double x);
-dvar_vector operator-(const dvar_vector & t1);
-dvar_vector operator*(const dvar_vector & t1, const prevariable & x);
-dvar_vector operator/(const prevariable & x, const dvar_vector & t1);
-dvar_vector operator/(const dvar_vector & t1, const prevariable & x);
-dvar_vector operator+(const prevariable & x, const dvar_vector & t1);
-dvar_vector operator+(const dvar_vector & t1, const prevariable & x);
-dvar_vector operator-(const prevariable & x, const dvar_vector & t1);
-dvar_vector operator-(const dvar_vector & t1, const prevariable & x);
-dvar_vector operator-(const dvector & t1, const prevariable & x);
-dvar_vector operator*(const dvector & t1, const prevariable & x);
-dvar_vector operator*(const prevariable & x, const dvector & t1);
+ // spreadsheet like element wise operations
 
-dvector operator*(const dvector & t1, double x);
-dvector operator/(double x, const dvector & t1);
-dvector operator/(const dvector & t1, double x);
-dvector operator+(double x, const dvector & t1);
-dvector operator+(const dvector & t1, double x);
-dvector operator-(double x, const dvector & t1);
-dvector operator-(const dvector & t1, double x);
-dvector operator-(const dvector & t1);
+  dvar_vector operator * (const dvar_vector& t1, double x);
+  dvar_vector operator / ( double x,const dvar_vector& t1);
+  dvar_vector operator / (const dvar_vector& t1, double x);
+  dvar_vector operator + ( double x,const dvar_vector& t1);
+  dvar_vector operator + (const dvar_vector& t1, double x);
+  dvar_vector operator - ( double x,const dvar_vector& t1);
+  dvar_vector operator - (const dvar_vector& t1, double x);
+  dvar_vector operator - (const dvar_vector& t1);
+  dvar_vector operator * (const dvar_vector& t1,const prevariable& x);
+  dvar_vector operator / (const prevariable& x,const dvar_vector& t1);
+  dvar_vector operator / (const dvar_vector& t1,const prevariable& x);
+  dvar_vector operator + (const prevariable& x,const dvar_vector& t1);
+  dvar_vector operator + (const dvar_vector& t1,const prevariable& x);
+  dvar_vector operator - (const prevariable& x,const dvar_vector& t1);
+  dvar_vector operator - (const dvar_vector& t1,const prevariable& x);
+  dvar_vector operator - (const dvector& t1,const prevariable& x);
+  dvar_vector operator * (const dvector& t1,const prevariable& x);
+  dvar_vector operator * (const prevariable& x,const dvector& t1);
 
-double min(const dmatrix &);
-double max(const dmatrix &);
-int max(const imatrix &);
-double max(const dvector &);
-dvariable max(const dvar_vector &);
-dvariable min(const dvar_vector &);
+  dvector operator * (const dvector& t1, double x);
+  dvector operator / ( double x,const dvector& t1);
+  dvector operator / (const dvector& t1, double x);
+  dvector operator + ( double x,const dvector& t1);
+  dvector operator + (const dvector& t1, double x);
+  dvector operator - ( double x,const dvector& t1);
+  dvector operator - (const  dvector& t1, double x);
+  dvector operator - (const dvector& t1);
 
-dmatrix symmetrize(const dmatrix & m1);
-dvector eigenvalues(const dmatrix & m1);
-dmatrix eigenvectors(const dmatrix & m1);
-dmatrix eigenvectors(const dmatrix & m1, const dvector & eigenvalues);
+  double min(const dmatrix&);
+  double max(const dmatrix&);
+  int max(const imatrix&);
+  double max(const dvector&);
+  dvariable max(const dvar_vector&);
+  dvariable min(const dvar_vector&);
 
-dvar_matrix symmetrize(const dvar_matrix & m1);
-dvar_vector eigenvalues(const dvar_matrix & m1);
-dvar_matrix eigenvectors(const dvar_matrix & m1);
+  dmatrix symmetrize(const dmatrix& m1);
+  dvector eigenvalues(const dmatrix& m1);
+  dmatrix eigenvectors(const dmatrix& m1);
+  dmatrix eigenvectors(const dmatrix& m1,const dvector& eigenvalues);
 
-dmatrix outer_prod(const dvector & t1, const dvector & t2);
-dvar_matrix outer_prod(const dvar_vector & t1, const dvar_vector & t2);
-dvar_matrix outer_prod(const dvector & t1, const dvar_vector & t2);
-dvar_matrix outer_prod(const dvar_vector & t1, const dvector & t2);
-dmatrix operator*(double x, const dmatrix & m);
-dmatrix operator*(const dmatrix & m, double d);
-dmatrix operator/(const dmatrix & m, double d);
-dmatrix operator/(double d, const dmatrix & m);
-dmatrix operator+(double x, const dmatrix & m);
-dvar_matrix operator +(const dvariable & x, const dmatrix & m);
-dvar_matrix operator -(const dvariable & x, const dmatrix & m);
-dmatrix operator+(const dmatrix & m, double d);
-dmatrix operator-(double x, const dmatrix & m);
-dmatrix operator-(const dmatrix & m, double d);
-dvar_matrix operator/(const dvar_matrix & m, const prevariable & x);
-dvar_matrix operator/(const dmatrix & m, const prevariable & x);
-dvar_matrix operator/(const dvar_matrix & m, double x);
-dvar_matrix operator/(double x, const dvar_matrix & m);
-dvar_matrix operator/(const prevariable & x, const dvar_matrix & m);
+  dvar_matrix symmetrize(const dvar_matrix& m1);
+  dvar_vector eigenvalues(const dvar_matrix& m1);
+  dvar_matrix eigenvectors(const dvar_matrix& m1);
 
-dvar_matrix operator*(const prevariable & x, const dmatrix & m);
-dvar_matrix operator*(const dvar_matrix & m, const prevariable & x);
-dvar_matrix operator*(const prevariable & x, const dvar_matrix & m);
-dvar_matrix operator*(double x, const dvar_matrix & m);
+  dmatrix outer_prod(const dvector& t1 ,const dvector& t2 );
+  dvar_matrix outer_prod(const dvar_vector& t1 ,const dvar_vector& t2 );
+  dvar_matrix outer_prod(const dvector& t1 ,const dvar_vector& t2 );
+  dvar_matrix outer_prod(const dvar_vector& t1 ,const dvector& t2 );
+  //double trace(const dmatrix&);
+  //dvariable trace(const dvar_matrix&);
+  dmatrix operator * ( double x,const dmatrix& m);
+  dmatrix operator * (const dmatrix& m, double d);
+  dmatrix operator / (const dmatrix& m, double d);
+  dmatrix operator / ( double d,const dmatrix& m);
+  dmatrix operator + ( double x,const dmatrix& m);
+  dvar_matrix operator + ( const dvariable& x,const dmatrix& m);
+  dvar_matrix operator - ( const dvariable& x,const dmatrix& m);
+  dmatrix operator + (const dmatrix& m, double d);
+  dmatrix operator - ( double x,const dmatrix& m);
+  dmatrix operator - (const dmatrix& m, double d);
+  dvar_matrix operator / (const dvar_matrix& m,const prevariable& x);
+  dvar_matrix operator / (const dmatrix& m,const prevariable& x);
+  dvar_matrix operator / (const dvar_matrix& m, double x);
+  dvar_matrix operator / ( double x,const dvar_matrix& m);
+  dvar_matrix operator / (const prevariable& x,const dvar_matrix& m);
 
-dvector operator&(const dvector & t1, const dvector & t2);
-dvar_vector operator&(const dvar_vector & t1, const dvar_vector & t2);
+  dvar_matrix operator * (const prevariable& x,const dmatrix& m);
+  dvar_matrix operator * (const dvar_matrix& m,const prevariable& x);
+  dvar_matrix operator * (const prevariable& x,const dvar_matrix& m);
+  dvar_matrix operator * ( double x,const dvar_matrix& m);
 
-ivector column(const imatrix & m, int i);
-dvector extract_column(const dmatrix & m, int i);
-dvector column(const dmatrix & m, int i);
-dvector extract_row(const dmatrix & m, int j);
-dvector row(const dmatrix & m, int j);
-dvar_vector extract_column(const dvar_matrix & m, int i);
-dvar_vector column(const dvar_matrix & m, int i);
-dvector column_value(const dvar_matrix & m, int i);
-dvar_vector extract_row(const dvar_matrix & m, int j);
-dvar_vector row(const dvar_matrix & m, int j);
+  dvector operator & (const dvector& t1,const dvector& t2);
+  dvar_vector operator & (const dvar_vector& t1,const dvar_vector& t2);
 
+
+  ivector column(const imatrix& m,int i);
+  dvector extract_column(const dmatrix& m,int i);
+  dvector column(const dmatrix& m,int i);
+  dvector extract_row(const dmatrix& m, int j);
+  dvector row(const dmatrix& m, int j);
+  dvar_vector extract_column(const dvar_matrix& m, int i);
+  dvar_vector column(const dvar_matrix& m, int i);
+  dvector column_value(const dvar_matrix& m, int i);
+  dvar_vector extract_row(const dvar_matrix& m, int j);
+  dvar_vector row(const dvar_matrix& m, int j);
+
 // dvector mathematical functions
-dvector sin(const dvector & t1);
-dvector sqrt(const dvector & t1);
-dvector sqr(const dvector & t1);
-dvector exp(const dvector & t1);
-dvector mfexp(const dvector & t1);
-dvector mfexp(const dvector & t1, double d);
-dvector atan(const dvector & t1);
-dvector tan(const dvector & t1);
-dvector tanh(const dvector & t1);
-dvector atan2(const dvector & t1, const dvector & t2);
-dvector atan2(const dvector & t1, double t2);
-dvector atan2(double t1, const dvector & t2);
-dvector acos(const dvector & t1);
-dvector asin(const dvector & t1);
-dvector cos(const dvector & t1);
-dvector sinh(const dvector & t1);
-dvector cosh(const dvector & t1);
-dvector log(const dvector & t1);
-dvector log10(const dvector & t1);
-dvector pow(const dvector & t1, double);
-dvector pow(const dvector & t1, int);
-dvector pow(double, const dvector & t1);
-ivector pow(const ivector & v1, int x);
-ivector pow(int x, const ivector & v1);
+
+     dvector sin(const dvector& t1);
+     dvector sqrt(const dvector& t1);
+     dvector sqr(const dvector& t1);
+     dvector exp(const dvector& t1);
+     dvector mfexp(const dvector& t1);
+     dvector mfexp(const dvector& t1, double d);
+     dvector atan(const dvector& t1);
+     dvector tan(const dvector& t1);
+     dvector tanh(const dvector& t1);
+     dvector atan2(const dvector& t1,const dvector& t2);
+     dvector atan2(const dvector& t1, double t2);
+     dvector atan2( double t1,const dvector& t2);
+     dvector acos(const dvector& t1);
+     dvector asin(const dvector& t1);
+     dvector cos(const dvector& t1);
+     dvector sinh(const dvector& t1);
+     dvector cosh(const dvector& t1);
+     dvector log(const dvector& t1);
+     dvector log10(const dvector& t1);
+     dvector pow(const dvector& t1, double);
+     dvector pow(const dvector& t1,int);
+     dvector pow( double,const dvector& t1);
+     ivector pow(const ivector& v1, int x); 
+     ivector pow(int x,const ivector& v1); 
+
 // end of dvector mathematical functions
 
 // dvar_vector mathematical functions
-dvar_vector sin(const dvar_vector & t1);
-dvar_vector sqrt(const dvar_vector & t1);
-dvar_vector sqr(const dvar_vector & t1);
-dvar_vector exp(const dvar_vector & t1);
-dvar_vector mfexp(const dvar_vector & t1);
-dvar_vector mfexp(const dvar_vector & t1, double d);
-dvar_vector atan(const dvar_vector & t1);
-dvar_vector tan(const dvar_vector & t1);
-dvar_vector tanh(const dvar_vector & t1);
-dvar_vector atan2(const dvar_vector & t1, const dvar_vector & t2);
-dvar_vector atan2(const dvar_vector & t1, double t2);
-dvar_vector atan2(double t1, const dvar_vector & t2);
-dvar_vector acos(const dvar_vector & t1);
-dvar_vector asin(const dvar_vector & t1);
-dvar_vector cos(const dvar_vector & t1);
-dvar_vector sinh(const dvar_vector & t1);
-dvar_vector cosh(const dvar_vector & t1);
-dvar_vector log(const dvar_vector & t1);
-dvar_vector log10(const dvar_vector & t1);
-dvar_vector pow(const dvar_vector &, const dvar_vector & t1);
-dvar_vector pow(const dvar_vector &, const dvector & t1);
-dvar_vector pow(const dvector &, const dvar_vector & t1);
-dvector pow(const dvector &, const dvector & t1);
-dvar_vector pow(const dvar_vector & t1, double);
-dvar_vector pow(const dvar_vector & t1, int);
-dvar_vector pow(const dvar_vector & t1, const prevariable &);
-dvar_vector pow(const dvector & t1, const prevariable &);
-dvar_vector pow(const prevariable &, const dvar_vector & t1);
-dvar_vector pow(const dvector & x, const dvar_vector & a);
+
+     dvar_vector sin(const dvar_vector& t1);
+     dvar_vector sqrt(const dvar_vector& t1);
+     dvar_vector sqr(const dvar_vector& t1);
+     dvar_vector exp(const dvar_vector& t1);
+     dvar_vector mfexp(const dvar_vector& t1);
+     dvar_vector mfexp(const dvar_vector& t1, double d);
+     dvar_vector atan(const dvar_vector& t1);
+     dvar_vector tan(const dvar_vector& t1);
+     dvar_vector tanh(const dvar_vector& t1);
+     dvar_vector atan2(const dvar_vector& t1,const dvar_vector& t2);
+     dvar_vector atan2(const dvar_vector& t1, double t2);
+     dvar_vector atan2( double t1,const dvar_vector& t2);
+     dvar_vector acos(const dvar_vector& t1);
+     dvar_vector asin(const dvar_vector& t1);
+     dvar_vector cos(const dvar_vector& t1);
+     dvar_vector sinh(const dvar_vector& t1);
+     dvar_vector cosh(const dvar_vector& t1);
+     dvar_vector log(const dvar_vector& t1);
+     dvar_vector log10(const dvar_vector& t1);
+     dvar_vector pow(const dvar_vector&,const dvar_vector& t1);
+     dvar_vector pow(const dvar_vector&,const dvector& t1);
+     dvar_vector pow(const dvector&,const dvar_vector& t1);
+     dvector pow(const dvector&,const dvector& t1);
+     dvar_vector pow(const dvar_vector& t1, double);
+     dvar_vector pow(const dvar_vector& t1,int);
+     dvar_vector pow(const dvar_vector& t1,const prevariable&);
+     dvar_vector pow(const dvector& t1,const prevariable&);
+     dvar_vector pow(const prevariable&,const dvar_vector& t1);
+	dvar_vector pow(const dvector& x,const dvar_vector& a);
+
 // end of dvar_vector mathematical functions
 
 // dmatrix mathematical functions
-dmatrix exp(const dmatrix & m);
-dmatrix mfexp(const dmatrix & m);
-dmatrix mfexp(const dmatrix & m, double d);
-dmatrix sqrt(const dmatrix & m);
-dmatrix sqr(const dmatrix & m);
-dmatrix pow(const dmatrix & m, double e);
-dmatrix pow(const dmatrix & m, int e);
-dmatrix log(const dmatrix & m);
-dmatrix sin(const dmatrix & m);
-dmatrix cos(const dmatrix & m);
-dmatrix tan(const dmatrix & m);
-dmatrix elem_div(const dmatrix & m, const dmatrix & m2);
-dmatrix elem_prod(const dmatrix & m, const dmatrix & m2);
+    dmatrix exp(const dmatrix& m);
+    dmatrix mfexp(const dmatrix& m);
+    dmatrix mfexp(const dmatrix& m, double d);
+    dmatrix sqrt(const dmatrix& m);
+    dmatrix sqr(const dmatrix& m);
+    dmatrix pow(const dmatrix& m, double e);
+    dmatrix pow(const dmatrix& m,int e);
+    dmatrix log(const dmatrix& m);
+    dmatrix sin(const dmatrix& m);
+    dmatrix cos(const dmatrix& m);
+    dmatrix tan(const dmatrix& m);
+    dmatrix elem_div(const dmatrix& m,const dmatrix& m2);
+    dmatrix elem_prod(const dmatrix& m,const dmatrix& m2);
 // end of dmatrix mathematical functions
 
 //  dvar_matrix mathematical functions
-dvar_matrix exp(const dvar_matrix & m);
-dvar_matrix mfexp(const dvar_matrix & m);
-dvar_matrix mfexp(const dvar_matrix & m, double d);
-dvar_matrix sqrt(const dvar_matrix & m);
-dvar_matrix sqr(const dvar_matrix & m);
-dvar_matrix log(const dvar_matrix & m);
-dvar_matrix sin(const dvar_matrix & m);
-dvar_matrix cos(const dvar_matrix & m);
-dvar_matrix tan(const dvar_matrix & m);
-dvar_matrix pow(const dvar_matrix & m, double e);
-dvar_matrix pow(const dvar_matrix & m, const prevariable & e);
-dvar_matrix pow(const dmatrix & m, const prevariable & e);
-dvar_matrix pow(const dvar_matrix & m, int e);
-dvar_matrix elem_prod(const dvar_matrix & m, const dvar_matrix & m2);
-dvar_matrix elem_prod(const dvar_matrix & m, const dmatrix & m2);
-dvar_matrix elem_prod(const dmatrix & m, const dvar_matrix & m2);
-dvar_matrix elem_div(const dvar_matrix & m, const dvar_matrix & m2);
-dvar_matrix elem_div(const dvar_matrix & m, const dmatrix & m2);
-dvar_matrix elem_div(const dmatrix & m, const dvar_matrix & m2);
+    dvar_matrix exp(const dvar_matrix& m);
+    dvar_matrix mfexp(const dvar_matrix& m);
+    dvar_matrix mfexp(const dvar_matrix& m, double d);
+    dvar_matrix sqrt(const dvar_matrix& m);
+    dvar_matrix sqr(const dvar_matrix& m);
+    dvar_matrix log(const dvar_matrix& m);
+    dvar_matrix sin(const dvar_matrix& m);
+    dvar_matrix cos(const dvar_matrix& m);
+    dvar_matrix tan(const dvar_matrix& m);
+    dvar_matrix pow(const dvar_matrix& m, double e);
+    dvar_matrix pow(const dvar_matrix& m,const prevariable& e);
+    dvar_matrix pow(const dmatrix& m,const prevariable& e);
+    dvar_matrix pow(const dvar_matrix& m,int e);
+    dvar_matrix elem_prod(const dvar_matrix& m,const dvar_matrix& m2);
+    dvar_matrix elem_prod(const dvar_matrix& m,const dmatrix& m2);
+    dvar_matrix elem_prod(const dmatrix& m,const dvar_matrix& m2);
+    dvar_matrix elem_div(const dvar_matrix& m,const dvar_matrix& m2);
+    dvar_matrix elem_div(const dvar_matrix& m,const dmatrix& m2);
+    dvar_matrix elem_div(const dmatrix& m,const dvar_matrix& m2);
 //  end of dvar_matrix mathematical functions
 
-int min(const ivector & t1);
-int max(const ivector & t1);
-int Max(const ivector & t1);
+  int min(const ivector& t1);
+  int max(const ivector& t1);
+  int Max(const ivector& t1);
 
-double mfexp(double);
-double mfexp(double, double bound);
-dvariable mfexp(const prevariable &);
-dvariable mfexp(const prevariable &, double bound);
+     double mfexp(double);
+     double mfexp(double,double bound);
+     dvariable mfexp(const prevariable&);
+     dvariable mfexp(const prevariable&,double bound);
 
+#ifndef DVEC_ARR_HPP
+#define DVEC_ARR_HPP
+
 #if defined(THREAD_SAFE)
 /**
  * Description not yet available.
+ * \param
  */
-class ts_vector_shapex
-{
- public:
-   void *trueptr;
-   ts_vector_shapex(int lb, int ub, void *p):index_min(lb),
-      index_max(ub), ncopies(0), trueptr(p)
-   {
-   }
-   void *get_truepointer(void)
-   {
-      return trueptr;
-   }
-   //friend class dvector;
-   friend class ivector;
-   //friend class tdvector;
-   friend class dvar_vector;
+  class ts_vector_shapex 
+  {
+  public:
+    void * trueptr;
+    ts_vector_shapex(int lb,int ub,void * p) : index_min(lb), 
+      index_max(ub), ncopies(0), trueptr(p) {}
+    void * get_truepointer(void){ return trueptr; }
+    //friend class dvector;
+    friend class ivector;
+    //friend class tdvector;
+    friend class dvar_vector;
 
-#  if defined(USE_VECTOR_SHAPE_POOL)
-   static ts_vector_shape_pool **xpool;
-   void *operator  new(size_t);
-   void operator  delete(void *ptr, size_t n);
-#  endif
+#if defined(USE_VECTOR_SHAPE_POOL)
+    static __ADMBTHREAD__ ts_vector_shape_pool ** xpool;
+    void * operator new(size_t);
+    void operator delete(void * ptr,size_t n);
+#endif
 
-   unsigned int ncopies;
-   void shift(int min);
-   int index_min;
-   int index_max;
- private:
-   friend class subdvector;
-   friend class lvector;
-   friend class ptr_vector;
- public:
-   int decr_ncopies(void)
-   {
-      return --ncopies;
-   }
-   int get_ncopies(void)
-   {
-      return ncopies;
-   }
-   int incr_ncopies(void)
-   {
-      return ++ncopies;
-   }
-   int indexmin()
-   {
-      return index_min;
-   }
-   int indexmax()
-   {
-      return index_max;
-   }
-};
+    unsigned int ncopies;
+    void shift(int min);
+    int index_min;
+    int index_max;
+  private:
+    friend class subdvector;
+    friend class lvector;
+    friend class ptr_vector;
+  public:
+    int decr_ncopies(void) {return --ncopies;}
+    int get_ncopies(void) {return ncopies;}
+    int incr_ncopies(void) {return ++ncopies;}
+    int indexmin(){return index_min;}
+    int indexmax(){return index_max;}
+  };
 #endif
 
 /**
-  Holds "shape" information for vector objects.
+ * Description not yet available.
+ * \param
  */
-class vector_shapex
-{
- public:
-   vector_shapex(int lb, int ub, void *p):index_min(lb),
-      index_max(ub), ncopies(0), trueptr(p)
-   {
-   }
-   /// Returns address of first element in the vector. 
-   void *get_truepointer(void) 
-   {
-      return trueptr;
-   }
-   friend class dvector;
-   friend class ivector;
-   friend class dvar_vector;
+  class vector_shapex 
+  {
+  public:
+    vector_shapex(int lb,int ub,void * p) : index_min(lb), 
+      index_max(ub), ncopies(0), trueptr(p) {}
+    void * get_truepointer(void){ return trueptr; }
+    friend class dvector;
+    friend class ivector;
+    //friend class tdvector;
+    friend class dvar_vector;
 #if defined(USE_VECTOR_SHAPE_POOL)
-   static vector_shape_pool *xpool;
-   void *operator  new(size_t);
-   void operator  delete(void *ptr, size_t n)
-   {
-      xpool->free(ptr);
-   }
+    static __ADMBTHREAD__ vector_shape_pool * xpool;
+    void * operator new(size_t);
+    void operator delete(void * ptr,size_t n)
+    {  xpool->free(ptr); }
 #endif
-   void shift(int min);
-   int index_min;  ///< Minimum valid subscript
-   int index_max;  ///< Maximum valid subscript
-   /** Copy counter to enable shallow copies.
-   Initialized to zero in constructor.
-   Incremented by 1 in copy constructor.
-   Decremented by 1 in destructor.
-   Memory is freed when value of ncopies reaches zero
-   in the destructor.
-   */
-   unsigned int ncopies;
-   /** Address of first element in the vector. 
-   Value set in allocate(...) function. */
-   void *trueptr;
-   
- private:
-   friend class subdvector;
-   friend class lvector;
-   friend class ptr_vector;
- public:
-   int decr_ncopies(void)  ///< Decrement copy counter by 1.
-   {
-      return --ncopies;
-   }
-   int get_ncopies(void) ///< Return value of copy counter
-   {
-      return ncopies;
-   }
-   int incr_ncopies(void)  ///< Increment copy counter by 1.
-   {
-      return ++ncopies;
-   }
-   int indexmin() ///< Return value of minimum valid subscript.
-   {
-      return index_min;
-   }
-   int indexmax() ///< Return value of maximum valid subscript.
-   {
-      return index_max;
-   }
-};
+    void shift(int min);
+    int index_min;
+    int index_max;
+    unsigned int ncopies;
+    void * trueptr;
+  private:
+    friend class subdvector;
+    friend class lvector;
+    friend class ptr_vector;
+  public:
+    int decr_ncopies(void) {return --ncopies;}
+    int get_ncopies(void) {return ncopies;}
+    int incr_ncopies(void) {return ++ncopies;}
+    int indexmin(){return index_min;}
+    int indexmax(){return index_max;}
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class predvector
-{
-   dvector *p;
-   int lb;
-   int ub;
-   inline predvector(dvector * _p, int _lb, int _ub)
-   {
-      p = _p;
-      lb = _lb, ub = _ub;
-   }
-   friend class dvector;
-};
+  class predvector
+  {
+    dvector * p;
+    int lb;
+    int ub;
+    inline predvector(dvector * _p,int _lb,int _ub) {p=_p;lb=_lb,ub=_ub;}
+    friend class dvector;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class predvar_vector
-{
-   dvar_vector *p;
-   int lb;
-   int ub;
-   inline predvar_vector(dvar_vector * _p, int _lb, int _ub)
-   {
-      p = _p;
-      lb = _lb, ub = _ub;
-   }
-   friend class dvar_vector;
-};
+  class predvar_vector
+  {
+    dvar_vector * p;
+    int lb;
+    int ub;
+    inline predvar_vector(dvar_vector * _p,int _lb,int _ub) {p=_p;lb=_lb,ub=_ub;}
+    friend class dvar_vector;
+  };
 
-
-/** Vector of double precision numbers.
-A basic container class for a one dimensional array of double precision
-floating point numbers. 
-Fundamental building block for higher dimensional arrays.
-All ADMB vector classes have similar functionality.
-*/
-class dvector
-{
- protected:
-   double *v;			///< pointer to the data
-   int index_min;		///< minimum valid subscript 
-   int index_max;		///< maximum valid subscript
-   /// pointer to vector "shape"
+  class dvector /// Vector of double precision numbers
+  {
+  protected:
+    double * v;    ///< pointer to the data
+    int index_min; ///< minimum valid subscript 
+    int index_max; ///< maximum valid subscript
+    /// pointer to general vector housekeeping object
 #if defined(THREAD_SAFE)
-   ts_vector_shapex *shape;
+    ts_vector_shapex * shape;
 #else
-   vector_shapex *shape;
+    vector_shapex * shape;
 #endif
 
- public:
-   dvector operator -();
-   /// Returns 1 (TRUE) if memory is NOT allocated
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   /// Returns 1 (TRUE) if memory is allocated.
-   int allocated(void) const
-   {
-      return (shape != NULL);
-   }
-   /// Decrement vector indices array pointer.
-   dvector & operator --(void)
-   {
-      index_min--;
-      index_max--;
-      v++;
-      return *this;
-   }
-   /// Increment vector indices array pointer.
-   dvector & operator ++(void)
-   {
-      index_min++;
-      index_max++;
-      v--;
-      return *this;
-   }
-   void reallocate(double size);
-   /** Get subvector.
-   \param lb starting index of subvector
-   \param ub ending index of subvector
-   \return dvector contining a shallow copy of calling instance of dvector
-    with valid subscripts from lb to ub.
-   */
-   dvector sub(int lb, int ub)
-   {
-      return predvector(this, lb, ub);
-   }
-   /** Get subvector.
-   \param lb starting index of subvector
-   \param ub ending index of subvector
-   \return dvector contining a shallow copy of calling instance of dvector
-    with valid subscripts from lb to ub.
-   */
-   dvector operator () (int lb, int ub)
-   {
-      return predvector(this, lb, ub);
-   }
+  public:
+    dvector operator -();
+    int operator!(void) const { return (shape == NULL); }
+    int allocated(void) const { return (shape != NULL); }
+    dvector& operator -- (void) 
+    { 
+      index_min--;index_max--;v++; return *this;
+    }
+    dvector& operator ++ (void)  
+    { 
+      index_min++;index_max++;v--; return *this;
+    }
+    void reallocate(double size);
+  dvector sub(int lb,int ub)
+  {
+    return predvector(this,lb,ub);
+  }
+  dvector operator () (int lb,int ub)
+  {
+    return predvector(this,lb,ub);
+  }
+  dvector(const predvector& pd);
+  //virtual void write_message(void) { cout << " This is a dvector" << endl; }
+  
+  void fill_randpoisson(double lambda, const random_number_generator& rng);
+  void fill_randnegbinomial(double lambda,double tau,
+   const random_number_generator& rng);
+  void shallow_copy(const dvector&);
 
-   dvector(const predvector & pd);
+    friend class banded_symmetric_dvar_matrix;
+    friend class banded_lower_triangular_dvar_matrix;
+    friend class banded_symmetric_dmatrix;
+    friend class banded_lower_triangular_dmatrix;
+    
+      void allocate(int ncl,int ncu);
+      void allocate(const dvector& dv);
+      void allocatec(const dvector& dv);
+      void allocate(const dvar_vector&);
+      void allocate(const char *);
+      void allocate(void);
+      void deallocate(void);
+      void safe_deallocate(void);
+      void safe_allocate(int,int);
 
-   void fill_randpoisson(double lambda,
-			 const random_number_generator & rng);
-   void fill_randnegbinomial(double lambda, double tau,
-			     const random_number_generator & rng);
-   void shallow_copy(const dvector &);
+    const double* address() const { return v; }
+    double*& get_v(void) { return (v); }
+    double& elem(int i) { return(v[i]); }
+    double* initpointer(void) { return (v+indexmin()); }
+    #ifdef USE_CONST
+      const double* initpointer(void) const { return (v + indexmin()); }
+      double* get_v(void) const { return v; }
+      const double& elem(int i) const { return v[i]; }
+    #endif
 
-   friend class banded_symmetric_dvar_matrix;
-   friend class banded_lower_triangular_dvar_matrix;
-   friend class banded_symmetric_dmatrix;
-   friend class banded_lower_triangular_dmatrix;
+    void fill(const char * s);
+    void fill_randu_ni(long int& n);
+    void fill_randn_ni(long int& n);
+    void fill_randbi_ni(long int& n,double);
 
-   void allocate(int ncl, int ncu);
-   void allocate(const dvector & dv);
-   void allocatec(const dvector & dv);
-   void allocate(const dvar_vector &);
-   void allocate(const char *);
-   void allocate(void);
-   void deallocate(void);
-   void safe_deallocate(void);
-   void safe_allocate(int, int);
+    void fill_randu(long int& n);
+    void fill_randn(long int& n);
+    void fill_randbi(long int& n,double);
 
-   const double *address() const
-   {
-      return v;
-   }
-   double *&get_v(void)
-   {
-      return (v);
-   }
-   double &elem(int i)
-   {
-      return (v[i]);
-   }
-   double *initpointer(void)
-   {
-      return (v + indexmin());
-   }
-#ifdef USE_CONST
-   const double *initpointer(void) const
-   {
-      return (v + indexmin());
-   }
-   double *get_v(void) const
-   {
-      return v;
-   }
-   const double &elem(int i) const
-   {
-      return v[i];
-   }
-#endif
 
-   void fill(const char *s);
-   void fill_randu_ni(long int &n);
-   void fill_randn_ni(long int &n);
-   void fill_randbi_ni(long int &n, double);
+    void fill_randbi(double p, const random_number_generator& rng);
+    void fill_randu(const random_number_generator& rng);
+    void fill_randn(const random_number_generator& rng);
+    void fill_randcau(const random_number_generator& rng);
 
-   void fill_randu(long int &n);
-   void fill_randn(long int &n);
-   void fill_randbi(long int &n, double);
+    void fill_seqadd( double, double);
+    void fill_multinomial(const int& seed, const dvector& p);
+    void fill_multinomial(const random_number_generator& rng, const dvector& p);
+    void initialize(void);
 
+    int& testmin()  {return shape->index_min;} // returns the minimum allowable index
 
-   void fill_randbi(double p, const random_number_generator & rng);
-   void fill_randu(const random_number_generator & rng);
-   void fill_randn(const random_number_generator & rng);
-   void fill_randcau(const random_number_generator & rng);
+    int& testmax() {return shape->index_max;} // returns the minimum allowable index
 
-   void fill_seqadd(double, double);
-   void fill_multinomial(const int &seed, const dvector & p);
-   void fill_multinomial(const random_number_generator & rng,
-			 const dvector & p);
-   void initialize(void);
+    int indexmin() const { return index_min; } // returns the minimum allowable index
 
-   int &testmin()
-   {
-      return shape->index_min;
-   }				// returns the minimum allowable index
+    int indexmax() const { return index_max; } // returns the maximum allowable index
+    int size() const { return (index_max - index_min + 1); } // returns the number of elements
+    dvector& shift(int min);
 
-   int &testmax()
-   {
-      return shape->index_max;
-   }				// returns the minimum allowable index
+    dvector(const dvar_vector_position& dvp, const kkludge_object&);
 
-   /// Get minimum valid index.
-   int indexmin() const
-   {
-      return index_min;
-   }
+    dvector(const ad_integer&,const index_type&);
+    void allocate(const ad_integer&,const index_type&);
+    dvector(void);
+    dvector(const dvector&);
+    //dvector(const dvector&,int lb,int ub);
 
-   /// Get maximum valid index.
-   int indexmax() const
-   {
-      return index_max;
-   }
+    dvector(const ivector&);
 
-   /// Get number of elements in array.
-   int size() const
-   {
-      return (index_max - index_min + 1);
-   }
+    dvector(const lvector&);
 
-   dvector & shift(int min);
+    dvector(const char *);
 
-   dvector(const dvar_vector_position & dvp, const kkludge_object &);
+    dvector( int ncl,  int ncu);
+                                           // makes an array [ncl..ncu]
 
-   dvector(const ad_integer &, const index_type &);
-   void allocate(const ad_integer &, const index_type &);
-   dvector(void);
-   dvector(const dvector &);
-   //dvector(const dvector&,int lb,int ub);
+    dvector( unsigned int sz, double * x);
 
-   dvector(const ivector &);
+    dvector(char * filename, const int& column);
 
-   dvector(const lvector &);
+    //operator double* () { return v;}
 
-   dvector(const char *);
-
-   dvector(int ncl, int ncu);
-   // makes an array [ncl..ncu]
-
-   dvector(unsigned int sz, double *x);
-
-   dvector(char *filename, const int &column);
-
-   //operator double* () { return v;}
-
    ~dvector();
 
-   void save_dvector_position(void) const;
-   void save_dvector_derivatives(const dvar_vector_position & pos) const;
-   void save_dvector_derivatives_na(const dvar_vector_position & pos)
-      const;
-   void save_dvector_derivatives(void) const;
-   void save_dvector_value(void) const;
+    void save_dvector_position(void) const;
+    void save_dvector_derivatives(const dvar_vector_position& pos) const;
+    void save_dvector_derivatives_na(const dvar_vector_position& pos) const;
+    void save_dvector_derivatives(void) const;
+    void save_dvector_value(void) const;
 
-   //dvector operator()(int,int);
-   dvector operator() (const lvector &);
-   dvector operator() (const ivector & u);
+    //dvector operator()(int,int);
+    dvector operator()(const lvector&);
+    dvector operator()(const ivector& u);
 
-   dvector & operator+=(const dvector & v1);
-   dvector & operator-=(const dvector & v1);
-   dvector & operator +=(double v1);
-   dvector & operator /=(double v1);
-   dvector & operator *=(double v1);
-   dvector & operator -=(double v1);
+    dvector& operator+=(const dvector& v1);
+    dvector& operator-=(const dvector& v1);
+    dvector& operator += ( double v1);
+    dvector& operator /= ( double v1);
+    dvector& operator *= ( double v1);
+    dvector& operator -= ( double v1);
 
-   void read_from(const uistream &);
+    void read_from(const uistream&);
 
-   friend class sdmatrix;
-   friend double norm(const dvector &);
-   friend double norm2(const dvector &);
-   friend double sumsq(const dvector &);
-   friend class dvar_vector;
-   friend class dmatrix;
-   friend class d3_array;
-   friend char *fform(const char *, const dvector &);
+    friend class sdmatrix;
+    friend double norm(const dvector&);
+    friend double norm2(const dvector&);
+    friend double sumsq(const dvector&);
+    friend class dvar_vector;
+    friend class dmatrix;
+    friend class d3_array;
+    friend char* fform(const char*, const dvector&);
 
-   void write_on(const ostream &) const;
-   void write_on(const uostream &) const;
-   void read_from(const istream &);
-   friend double operator*(const dvector &, const dvector &);
+    void write_on(const ostream&) const;
+    void write_on(const uostream&) const;
+    void read_from(const istream&);
+    friend double operator*(const dvector&, const dvector&);
 
-   friend dvariable operator*(const dvector &, const dvar_vector &);
+    friend dvariable operator*(const dvector&, const dvar_vector&);
 
-   friend dvariable operator*(const dvar_vector &, const dvector &);
+    friend dvariable operator*(const dvar_vector&, const dvector&);
 
-   friend dvar_vector operator*(const prevariable &, const dvector &);
+    friend dvar_vector operator*(const prevariable&, const dvector&);
 
-   friend dvector operator*(double, const dvector &);
+    friend dvector operator*(double, const dvector&);
 
-   friend dvector operator+(const dvector &, const dvector &);
+    friend dvector operator+(const dvector&, const dvector&);
 
-   friend dvector elem_prod(const dvector &, const dvector &);
+    friend dvector elem_prod(const dvector&, const dvector&);
 
-   friend dvector first_difference(const dvector &);
-   friend dvector second_difference(const dvector &);
+    friend dvector first_difference(const dvector&);
+    friend dvector second_difference(const dvector&);
 
-   friend dvector elem_div(const dvector &, const dvector &);
+    friend dvector elem_div(const dvector&, const dvector&);
 
-   friend dvar_vector elem_prod(const dvector &, const dvar_vector &);
+    friend dvar_vector elem_prod(const dvector&, const dvar_vector&);
 
-   friend dvar_vector elem_div(const dvector &, const dvar_vector &);
+    friend dvar_vector elem_div(const dvector&, const dvar_vector&);
 
-   friend dvar_vector elem_prod(const dvar_vector &, const dvector &);
+    friend dvar_vector elem_prod(const dvar_vector&, const dvector&);
 
-   friend dvar_vector elem_div(const dvar_vector &, const dvector &);
+    friend dvar_vector elem_div(const dvar_vector&, const dvector&);
 
-   friend dvar_vector operator+(const dvar_vector &, const dvector &);
+    friend dvar_vector operator+(const dvar_vector&, const dvector&);
 
-   friend dvar_vector operator+(const dvector &, const dvar_vector &);
+    friend dvar_vector operator+(const dvector&, const dvar_vector&);
 
-   friend dvector operator-(const dvector &, const dvector &);
+    friend dvector operator-(const dvector&, const dvector&);
 
-   friend dvar_vector operator-(const dvar_vector &, const dvector &);
+    friend dvar_vector operator-(const dvar_vector&, const dvector&);
 
-   friend dvar_vector operator-(const dvector &, const dvar_vector &);
+    friend dvar_vector operator-(const dvector&, const dvar_vector&);
 
-   friend dvector operator*(const dvector & x, const dmatrix & m);
+    friend dvector operator*(const dvector& x, const dmatrix& m);
 
-   friend dvector operator*(const dmatrix & x, const dvector & m);
+    friend dvector operator*(const dmatrix& x, const dvector& m);
 
-   friend dvar_vector operator*(const dvector & x, const dvar_matrix & m);
+    friend dvar_vector operator*(const dvector& x, const dvar_matrix& m);
 
-   friend dvar_vector operator*(const dvar_matrix & x, const dvector & m);
+    friend dvar_vector operator*(const dvar_matrix& x, const dvector& m);
 
 
 #ifdef OPT_LIB
-   inline double &operator[] (register int i)
-   {
-      return (*(v + i));
-   }
-   inline double &operator() (register int i)
-   {
-      return (*(v + i));
-   }
+      inline double& operator[] (register int i) { return(*(v+i)); }
+      inline double& operator() (register int i) { return(*(v+i)); }
 #else
-   double &operator[] (int i);
-   double &operator() (int i);
+      double& operator[] (int i);
+      double& operator() (int i);
 #endif
 
 #ifdef USE_CONST
-#ifdef OPT_LIB
-   inline const double &operator[] (register int i) const
-   {
-      return (*(v + i));
-   }
-   inline const double &operator() (register int i) const
-   {
-      return (*(v + i));
-   }
-#else
-   const double &operator[] (int i) const;
-   const double &operator() (int i) const;
+  #ifdef OPT_LIB
+    inline const double& operator[](register int i) const { return(*(v+i)); }
+    inline const double& operator()(register int i) const { return(*(v+i)); }
+  #else
+      const double& operator[](int i) const;
+      const double& operator()(int i) const;
+  #endif
 #endif
-#endif
 
 
-   dvector & operator=(const dvector & t);
+    dvector& operator=(const dvector& t);
 
-   dvector & operator =(double x);
+    dvector& operator = ( double x);
 
-   friend dvector exp(const dvector &);
+    friend dvector exp(const dvector&);
 
-   friend dvector log(const dvector &);
+    friend dvector log(const dvector&);
 
-   friend dvector fabs(const dvector &);
+    friend dvector fabs(const dvector&);
 
-   friend double max(const dvector &);
+    friend double max(const dvector&);
 
-   friend double min(const dvector &);
+    friend double min(const dvector&);
 
-};				// end of class dvector
+ }; // end of class dvector
 
 /**
  * Description not yet available.
  * \param
  */
-class independent_variables:public dvector
+class independent_variables : public dvector 
 {
- public:
+  public:
 
-   independent_variables(const independent_variables & v):dvector(v)
-   {
-   }
+    independent_variables(const independent_variables& v) : dvector(v) {}
 
-   independent_variables(int ncl, int ncu):dvector(ncl, ncu)
-   {
-   }
-   // makes an array [ncl..ncu]
+    independent_variables( int ncl,  int ncu) :
+      dvector(ncl,ncu) {}
+                                           // makes an array [ncl..ncu]
 
-   independent_variables(unsigned int sz, double *x):dvector(sz, x)
-   {
-   }
+    independent_variables( unsigned int sz, double * x) :
+      dvector(sz, x) {}
 
-   independent_variables & operator=(const dvector & t);
+    independent_variables& operator = (const dvector& t);
 
 };
+     
 
+#endif
 
+dvariable dfatan1( dvariable , double , double ,const prevariable&fpen);
 
-dvariable dfatan1(dvariable, double, double, const prevariable & fpen);
+double boundp( double x, double fmin, double fmax,const double& fpen);
+double boundp( double x, double fmin, double fmax);
 
-double boundp(double x, double fmin, double fmax, const double &fpen);
-double boundp(double x, double fmin, double fmax);
+dvariable boundp(const prevariable & x, double fmin, double fmax,const prevariable& fpen);
+dvariable boundp(const prevariable & x, double fmin, double fmax,const prevariable& fpen,double s);
 
-dvariable boundp(const prevariable & x, double fmin, double fmax,
-		 const prevariable & fpen);
-dvariable boundp(const prevariable & x, double fmin, double fmax,
-		 const prevariable & fpen, double s);
-
-double nd2fboundp(double x, double minb, double maxb, const double &pen);
+double nd2fboundp(double x,double minb,double maxb,const double& pen);
 double boundpin(double x, double fmin, double fmax);
-double boundpin(const prevariable & x, double fmin, double fmax);
-double boundpin(const prevariable & x, double fmin, double fmax, double s);
+double boundpin(const prevariable& x, double fmin, double fmax);
+double boundpin(const prevariable& x, double fmin, double fmax,double s);
 
-double dmin(double, double);
+double dmin(double, double );
 
 double dmax(double i, double j);
 
@@ -2757,1150 +2614,924 @@
 #endif
 
 
-double sigmoid(double t1);
+   double sigmoid( double t1);
 
 /**
  * Description not yet available.
  * \param
  */
-class mat_shape
-{
-   unsigned int ncopies;
-   unsigned int nrows;
-   unsigned int ncols;
-   int row_min;
-   int row_max;
-   int col_min;
-   int col_max;
-   mat_shape(int rl, int ru, int cl = 0, int cu = -1);
-   mat_shape()
-   {
-   };
-   void colshift(int min);
-   void rowshift(int min);
+  class mat_shape 
+  {
+    unsigned int ncopies;
+    unsigned int nrows;
+    unsigned int ncols; 
+    int row_min;
+    int row_max;
+    int col_min;
+    int col_max;
+    mat_shape(int rl,int ru,int cl=0,int cu=-1);
+    mat_shape(){};
+    void colshift(int min);
+    void rowshift(int min);
 
-   //friend class const_dmatrix;
-   friend class dmatrix;
-   friend class sdmatrix;
-   friend class dvar_matrix;
-   friend class imatrix;
-   friend class lmatrix;
-   friend class i3_array;
-};
+    //friend class const_dmatrix;
+    friend class dmatrix;
+    friend class sdmatrix;
+    friend class dvar_matrix;
+    friend class imatrix;
+    friend class lmatrix;
+    friend class i3_array;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class mat_shapex
-{
- public:
-   void *trueptr;
-   unsigned int ncopies;
-   mat_shapex(const void *m)
-   {
-      trueptr = (void *) m;
-      ncopies = 0;
-   }
-   mat_shapex()
-   {
-      trueptr = NULL;
-      ncopies = 0;
-   };
+  class mat_shapex 
+  {
+  public:
+    void * trueptr;
+    unsigned int ncopies;
+    mat_shapex(const void * m) { trueptr=(void*)m;ncopies=0;}
+    mat_shapex(){trueptr=NULL;ncopies=0;};
 
-   void *get_pointer(void)
-   {
-      return trueptr;
-   }
-   friend class dmatrix;
-   friend class sdmatrix;
-   friend class dvar_matrix;
-   friend class imatrix;
-   friend class i3_array;
-   friend class lmatrix;
-};
+    void * get_pointer (void) {return trueptr;}
+    friend class dmatrix;
+    friend class sdmatrix;
+    friend class dvar_matrix;
+    friend class imatrix;
+    friend class i3_array;
+    friend class lmatrix;
+  };
 
-class arr_link;
+    class arr_link;
 
 /**
  * Description not yet available.
  * \param
  */
-class arr_list
-{
-   arr_link *last;
-   arr_link *free_last;
-   unsigned long int last_offset;
-   unsigned long int max_last_offset;
- public:
-   long int number_arr_links;
-   friend class arr_link;
+    class arr_list
+    {
+      arr_link * last;
+      arr_link * free_last;
+      unsigned long int last_offset;
+      unsigned long int max_last_offset;
+    public:
+      long int number_arr_links;
+      friend class arr_link;
+  
+    public:
+    
+      arr_list(void)
+      {
+        last = 0;
+        free_last = 0;
+        last_offset = 0;
+        max_last_offset = 0;
+        number_arr_links = 0;
+      }
+      unsigned long int get_last_offset() { return last_offset;}
+      unsigned long int get_number_arr_links(){ return(number_arr_links);}
+      unsigned long int get_max_last_offset() { return (max_last_offset);}
+      void reset_max_last_offset() {max_last_offset=0;}
+      friend double_and_int * arr_new(unsigned int);
+      friend void arr_free(double_and_int *);
+      friend void arr_remove(arr_link **);
+      friend void arr_free_list_remove(arr_link **);
+      friend void arr_free_add(arr_link *);
+      friend void arr_free_remove(arr_link *);
+    };
 
- public:
-
-   arr_list(void)
-   {
-      last = 0;
-      free_last = 0;
-      last_offset = 0;
-      max_last_offset = 0;
-      number_arr_links = 0;
-   }
-   unsigned long int get_last_offset()
-   {
-      return last_offset;
-   }
-   unsigned long int get_number_arr_links()
-   {
-      return (number_arr_links);
-   }
-   unsigned long int get_max_last_offset()
-   {
-      return (max_last_offset);
-   }
-   void reset_max_last_offset()
-   {
-      max_last_offset = 0;
-   }
-   friend double_and_int *arr_new(unsigned int);
-   friend void arr_free(double_and_int *);
-   friend void arr_remove(arr_link **);
-   friend void arr_free_list_remove(arr_link **);
-   friend void arr_free_add(arr_link *);
-   friend void arr_free_remove(arr_link *);
-};
-
 /**
  * Description not yet available.
  * \param
  */
-class arr_link
-{
+    class arr_link
+    {
 #if defined(USE_VECTOR_SHAPE_POOL)
-   static vector_shape_pool *xpool;
-   void *operator  new(size_t);
-   void operator  delete(void *ptr, size_t n)
-   {
-      xpool->free(ptr);
-   }
+     public:
+    static __ADMBTHREAD__ vector_shape_pool * xpool;
+    void * operator new(size_t);
+    void operator delete(void * ptr,size_t n) 
+    {  xpool->free(ptr); }
 #endif
-   arr_link *prev;
-   arr_link *next;
-   arr_link *free_prev;
-   arr_link *free_next;
-   unsigned int status;
-   // unsigned int     free_list_status;
-   unsigned int size;
-   unsigned long int offset;
- public:
-   arr_link();
+       arr_link *          prev;
+       arr_link *          next;
+       arr_link *          free_prev;
+       arr_link *          free_next;
+       unsigned int        status;
+       // unsigned int     free_list_status;
+       unsigned int        size;
+       unsigned long int   offset;
+     public:
+       arr_link();
+    
+       friend double_and_int * arr_new(unsigned int);
+       friend void arr_free(double_and_int *);
+       friend void arr_remove(arr_link **);
+       friend void arr_free_remove(arr_link *);
+       friend void arr_free_add(arr_link *);
+    };
 
-   friend double_and_int *arr_new(unsigned int);
-   friend void arr_free(double_and_int *);
-   friend void arr_remove(arr_link **);
-   friend void arr_free_remove(arr_link *);
-   friend void arr_free_add(arr_link *);
-};
-
 #if defined(__NUMBERVECTOR__)
-class param_init_number_vector;
-class param_init_bounded_number_vector;
-class param_init_bounded_number_matrix;
-class param_init_vector_vector;
-class param_init_bounded_vector_vector;
+  class param_init_number_vector;
+  class param_init_bounded_number_vector;
+  class param_init_bounded_number_matrix;
+  class param_init_vector_vector;
+  class param_init_bounded_vector_vector;
 #endif
 
 /**
  * Description not yet available.
  * \param
  */
-class dvar_vector
-{
+
+ class dvar_vector
+ {
  public:
    double_and_int * va;
    int index_min;
    int index_max;
-   arr_link *link_ptr;
-   vector_shapex *shape;
+   arr_link * link_ptr;
+   vector_shapex * shape;
  public:
-   dvar_vector operator -();
+    dvar_vector operator -();
 
-   dvar_vector & operator --(void)
-   {
-      index_min--;
-      index_max--;
-      va++;
-      return *this;
-   }
-   dvar_vector & operator ++(void)
-   {
-      index_min++;
-      index_max++;
-      va--;
-      return *this;
-   }
-   dvar_vector sub(int lb, int ub)
-   {
-      return predvar_vector(this, lb, ub);
-   }
-   dvar_vector operator () (int lb, int ub)
-   {
-      return predvar_vector(this, lb, ub);
-   }
-   void shallow_copy(const dvar_vector &);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   friend class dvar_matrix;
-   friend class dvar3_array;
-   friend class banded_symmetric_dvar_matrix;
-   friend class banded_lower_triangular_dvar_matrix;
-   friend class banded_symmetric_dmatrix;
-   friend class banded_lower_triangular_dmatrix;
+    dvar_vector& operator -- (void) 
+    { 
+      index_min--;index_max--;va++; return *this;
+    }
+    dvar_vector& operator ++ (void)  
+    { 
+      index_min++;index_max++;va--; return *this;
+    }
+  dvar_vector sub(int lb,int ub)
+  {
+    return predvar_vector(this,lb,ub);
+  }
+  dvar_vector operator () (int lb,int ub)
+  {
+    return predvar_vector(this,lb,ub);
+  }
+  void shallow_copy(const dvar_vector&);
+ int operator!(void) const { return (shape == NULL); }
+ friend class dvar_matrix;
+ friend class dvar3_array;
+    friend class banded_symmetric_dvar_matrix;
+    friend class banded_lower_triangular_dvar_matrix;
+    friend class banded_symmetric_dmatrix;
+    friend class banded_lower_triangular_dmatrix;
 
-   void fill_randpoisson(double lambda,
-			 const random_number_generator & rng);
-   void fill_randnegbinomial(double lambda, double tau,
-			     const random_number_generator & rng);
-   prevariable elem(int i)
-   {
-      return (va + i);
-   }
+ void fill_randpoisson(double lambda, const random_number_generator& rng);
+ void fill_randnegbinomial(double lambda,double tau,
+  const random_number_generator& rng);
+ prevariable elem(int i) { return (va+i); }
 
-   double &elem_value(int i)
-   {
-      return (va[i].x);
-   }
+ double& elem_value(int i) { return (va[i].x); }
 
-   double_and_int *get_va()
-   {
-      return va;
-   }
+ double_and_int * get_va(){return va;}
 
 #ifdef USE_CONST
-   prevariable elem(int i) const
-   {
-      return (va + i);
-   }
+  prevariable elem(int i) const { return (va + i); }
 
-   double &elem_value(int i) const
-   {
-      return (va[i].x);
-   }
+  double& elem_value(int i) const { return (va[i].x); }
 
-   double_and_int *get_va() const
-   {
-      return va;
-   }
+  double_and_int* get_va() const { return va; }
 #endif
 
 
-   friend dvar_matrix operator*(const dvar_matrix & m1,
-				const dmatrix & m2);
+    friend dvar_matrix operator*(const dvar_matrix& m1, const dmatrix& m2);
 
-   void deallocate();
-   dvar_vector(const dvar_vector &);
-   dvar_vector(const predvar_vector &);
-   dvar_vector();
-   dvar_vector(int ncl, int ncu);	// makes an array [ncl..ncu]
-   dvar_vector(int ncl, int ncu, kkludge_object);
+    void deallocate();
+    dvar_vector(const dvar_vector&);
+    dvar_vector(const predvar_vector&);
+    dvar_vector();
+    dvar_vector(int ncl,int ncu); // makes an array [ncl..ncu]
+    dvar_vector(int ncl,int ncu,kkludge_object);
 
-   //dvar_vector(const ad_integer&,const ad_integer&);
-   dvar_vector(unsigned int sz, double *x);
-   dvar_vector(const independent_variables &);
-   friend char *fform(const char *, const dvar_vector &);
+    //dvar_vector(const ad_integer&,const ad_integer&);
+    dvar_vector( unsigned int sz, double * x);
+    dvar_vector(const independent_variables&);
+    friend char* fform(const char*, const dvar_vector&);
 #   if defined(__NUMBERVECTOR__)
-   dvar_vector(const param_init_number_vector &);
-   dvar_vector(const param_init_bounded_number_vector &);
+    dvar_vector(const param_init_number_vector&);
+    dvar_vector(const param_init_bounded_number_vector&);
 #   endif
-   dvar_vector(const dvector &);
-   dvar_vector(const char *);
+    dvar_vector(const dvector&);
+    dvar_vector(const char *);
    ~dvar_vector();
-   void allocate(int, int);
-   void allocate(void);
-   void allocate(const dvector &);
-   void allocatec(const dvar_vector &);
-   void allocate(const dvar_vector &);
+    void allocate(int,int);
+    void allocate(void);
+    void allocate(const dvector&);
+    void allocatec(const dvar_vector&);
+    void allocate(const dvar_vector&);
 
-   void allocate(const ad_integer &, const ad_integer &);
-   void initialize(const dvector & ww);
-   void initialize(void);
-   void save_dvar_vector_position(void) const;
-   void save_dvar_vector_value(void) const;
-   void write_on(const ostream &) const;
-   void write_on(const uostream &) const;
-   void read_from(const istream &);
-   void read_from(const uistream &);
-   int indexmin() const
-   {
-      return index_min;
-   }				// returns the minimum allowable index
-   int indexmax() const
-   {
-      return index_max;
-   }				// returns the maximum allowable index
-   int size() const
-   {
-      return (index_max - index_min + 1);
-   }				// returns the number of elements
-   dvar_vector & shift(int min);
+    void allocate(const ad_integer&,const ad_integer&);
+    void initialize(const dvector& ww);
+    void initialize(void);
+    void save_dvar_vector_position(void) const;
+    void save_dvar_vector_value(void) const;
+    void write_on(const ostream&) const;
+    void write_on(const uostream&) const;
+    void read_from(const istream&);
+    void read_from(const uistream&);
+    int indexmin() const { return index_min; } // returns the minimum allowable index
+    int indexmax() const { return index_max; } // returns the maximum allowable index
+    int size() const { return (index_max - index_min + 1); } // returns the number of elements
+    dvar_vector& shift(int min);
 
 #ifdef OPT_LIB
-#if defined(__NDPX__) || defined(__SUN__)
-   inline prevariable operator() (register int i)
-   {
-      return (va + i);
-   }
-   inline prevariable operator[] (register int i)
-   {
-      return (va + i);
-   }
-#ifdef USE_CONST
-   inline const prevariable operator() (int i) const
-   {
-      return (va + i);
-   }
-   inline const prevariable operator[] (int i) const
-   {
-      return (va + i);
-   }
-#endif
+ #if defined(__NDPX__) || defined(__SUN__)
+	inline prevariable operator() (register int i) { return (va+i); }
+	inline prevariable operator[] (register int i) { return (va+i); }
+      #ifdef USE_CONST
+	inline const prevariable operator()(int i) const { return (va + i); }
+	inline const prevariable operator[] (int i) const { return (va + i); }
+      #endif
+ #else
+	inline prevariable operator() (int i) { return (va+i); }
+	inline prevariable operator[] (int i) { return (va+i); }
+  #ifdef USE_CONST
+	inline const prevariable operator()(int i) const { return (va + i); }
+	inline const prevariable operator[](int i) const { return (va + i); }
+  #endif
+ #endif
 #else
-   inline prevariable operator() (int i)
-   {
-      return (va + i);
-   }
-   inline prevariable operator[] (int i)
-   {
-      return (va + i);
-   }
-#ifdef USE_CONST
-   inline const prevariable operator() (int i) const
-   {
-      return (va + i);
-   }
-   inline const prevariable operator[] (int i) const
-   {
-      return (va + i);
-   }
+	prevariable operator[] (int i);
+	prevariable operator() (int i);
+  #ifdef USE_CONST
+	const prevariable operator[](int i) const;
+	const prevariable operator()(int i) const;
+  #endif
 #endif
-#endif
-#else
-   prevariable operator[] (int i);
-   prevariable operator() (int i);
-#ifdef USE_CONST
-   const prevariable operator[] (int i) const;
-   const prevariable operator() (int i) const;
-#endif
-#endif
 
-   double *initpointer(void)
-   {
-      return ((double *) (va + indexmin()));
-   }
-#ifdef USE_CONST
-   const double *initpointer(void) const
-   {
-      return ((double *) (va + indexmin()));
-   }
+    double* initpointer(void) { return ((double*)(va+indexmin())); }
+  #ifdef USE_CONST
+    const double* initpointer(void) const { return ((double*)(va + indexmin())); }
 #endif
-   dvar_vector operator() (const lvector &);
-   //dvar_vector operator()(int,int);
-   dvar_vector operator () (const ivector & u);
-   dvar_vector & operator+=(const prevariable & d);
-   dvar_vector & operator+=(double d);
-   dvar_vector & operator/=(const prevariable & d);
-   //dvar_vector& operator*=(const dvariable& d);
-   dvar_vector & operator*=(const prevariable & d);
-   dvar_vector & operator*=(double d);
-   dvar_vector & operator/=(double d);
-   dvar_vector & operator-=(const prevariable & d);
-   dvar_vector & operator-=(double d);
-   dvar_vector & operator+=(const dvector & v1);
-   dvar_vector & operator-=(const dvector & v1);
-   dvar_vector & operator+=(const dvar_vector & v1);
-   dvar_vector & operator-=(const dvar_vector & v1);
-   dvar_vector & operator=(const dvar_vector & t);
-   dvar_vector & operator=(const dvector & t);
-   dvar_vector & operator =(double t);
-   dvar_vector & operator=(const prevariable & t);
-   void fill(const char *);
-   void fill_randu(long int &n);
-   void fill_randn(long int &n);
-   void fill_randbi(long int &n, double);
+    dvar_vector operator()(const lvector&);
+    //dvar_vector operator()(int,int);
+    dvar_vector operator ()(const ivector& u);
+    dvar_vector& operator+=(const prevariable& d);
+    dvar_vector& operator+= (double d);
+    dvar_vector& operator/=(const prevariable& d);
+    //dvar_vector& operator*=(const dvariable& d);
+    dvar_vector& operator*=(const prevariable& d);
+    dvar_vector& operator*= ( double d);
+    dvar_vector& operator/= ( double d);
+    dvar_vector& operator-=(const prevariable& d);
+    dvar_vector& operator-= (double d);
+    dvar_vector& operator+=(const dvector& v1);
+    dvar_vector& operator-=(const dvector& v1);
+    dvar_vector& operator+=(const dvar_vector& v1);
+    dvar_vector& operator-=(const dvar_vector& v1);
+    dvar_vector& operator=(const dvar_vector& t);
+    dvar_vector& operator=(const dvector& t);
+    dvar_vector& operator = ( double t);
+    dvar_vector& operator=(const prevariable& t);
+    void fill(const char *);
+    void fill_randu(long int& n);
+    void fill_randn(long int& n);
+    void fill_randbi(long int& n,double);
 
-   void fill_randu_ni(long int &n);
-   void fill_randn_ni(long int &n);
-   void fill_randbi_ni(long int &n, double);
+    void fill_randu_ni(long int& n);
+    void fill_randn_ni(long int& n);
+    void fill_randbi_ni(long int& n,double);
 
-   void fill_seqadd(double, double);
-   void fill_multinomial(const int &seed, const dvector & p);
-   void fill_multinomial(const random_number_generator & rng,
-			 const dvector & p);
-   friend dvar_vector operator+(const dvar_vector &, const dvar_vector &);
-   friend dvar_vector operator+(const dvar_vector &, const dvector &);
-   friend dvar_vector operator+(const dvector &, const dvar_vector &);
-   friend dvar_vector operator-(const dvar_vector &, const dvar_vector &);
+    void fill_seqadd( double, double);
+    void fill_multinomial(const int& seed, const dvector& p);
+    void fill_multinomial(const random_number_generator& rng, const dvector& p);
+    friend dvar_vector operator+(const dvar_vector&, const dvar_vector&);
+    friend dvar_vector operator+(const dvar_vector&, const dvector&);
+    friend dvar_vector operator+(const dvector&, const dvar_vector&);
+    friend dvar_vector operator-(const dvar_vector&, const dvar_vector&);
 
-   friend dvar_vector operator-(const dvector &, const dvar_vector &);
+    friend dvar_vector operator-(const dvector&, const dvar_vector&);
 
-   friend dvar_vector operator-(const dvar_vector &, const dvector &);
+    friend dvar_vector operator-(const dvar_vector&, const dvector&);
 
-   friend dvar_vector sigmoid(const dvar_vector & t1);
+    friend dvar_vector sigmoid(const dvar_vector& t1);
 
-   friend dvariable operator*(const dvar_vector &, const dvar_vector &);
+    friend dvariable operator*(const dvar_vector&, const dvar_vector&);
 
-   friend dvar_vector elem_div(const dvar_vector &, const dvar_vector &);
+    friend dvar_vector elem_div(const dvar_vector&, const dvar_vector&);
 
-   friend dvariable operator*(const dvector &, const dvar_vector &);
+    friend dvariable operator*(const dvector&, const dvar_vector&);
 
-   friend dvariable operator*(const dvar_vector &, const dvector &);
+    friend dvariable operator*(const dvar_vector&, const dvector&);
 
-   friend dvar_vector operator*(const prevariable &, const dvar_vector &);
+    friend dvar_vector operator*(const prevariable&, const dvar_vector&);
 
-   friend dvar_vector operator*(const prevariable &, const dvector &);
+    friend dvar_vector operator*(const prevariable&, const dvector&);
 
-   friend dvar_vector operator*(double, const dvar_vector &);
+    friend dvar_vector operator*(double, const dvar_vector&);
 
-   friend dvar_vector operator*(const dvar_vector &, const dmatrix &);
+    friend dvar_vector operator*(const dvar_vector&, const dmatrix&);
 
-   friend dvar_vector operator*(const dmatrix &, const dvar_vector &);
+    friend dvar_vector operator*(const dmatrix&, const dvar_vector&);
 
-   friend dvar_vector operator*(const dvar_vector &, const dvar_matrix &);
+    friend dvar_vector operator*(const dvar_vector&, const dvar_matrix&);
 
-   friend dvar_vector operator*(const dvar_matrix &, const dvar_vector &);
+    friend dvar_vector operator*(const dvar_matrix&, const dvar_vector&);
 
-   friend dvar_matrix operator*(const dvar_matrix &, const dvar_matrix &);
+    friend dvar_matrix operator*(const dvar_matrix&, const dvar_matrix&);
 
-   friend dvar_matrix operator*(const dmatrix &, const dvar_matrix &);
+    friend dvar_matrix operator*(const dmatrix&, const dvar_matrix&);
 
-   friend dvar_vector elem_prod(const dvar_vector &, const dvar_vector &);
+    friend dvar_vector elem_prod(const dvar_vector&, const dvar_vector&);
 
-   friend dvar_vector first_difference(const dvar_vector &);
-   friend dvar_vector second_difference(const dvar_vector &);
+    friend dvar_vector first_difference(const dvar_vector&);
+    friend dvar_vector second_difference(const dvar_vector&);
 
-   //friend dvar_vector elem_div(const dvar_vector&, const dvar_vector&); // js, see above
+    //friend dvar_vector elem_div(const dvar_vector&, const dvar_vector&); // js, see above
 
-   friend dvar_vector elem_prod(const dvector &, const dvar_vector &);
+    friend dvar_vector elem_prod(const dvector&, const dvar_vector&);
 
-   friend dvar_vector elem_div(const dvector &, const dvar_vector &);
+    friend dvar_vector elem_div(const dvector&, const dvar_vector&);
 
-   friend dvar_vector elem_prod(const dvar_vector &, const dvector &);
+    friend dvar_vector elem_prod(const dvar_vector&, const dvector&);
 
-   friend dvar_vector elem_div(const dvar_vector &, const dvector &);
+    friend dvar_vector elem_div(const dvar_vector&, const dvector&);
 
-   friend dvariable norm(const dvar_vector &);
-   friend dvariable norm2(const dvar_vector &);
-   friend dvariable sumsq(const dvar_vector &);
+    friend dvariable norm(const dvar_vector&);
+    friend dvariable norm2(const dvar_vector&);
+    friend dvariable sumsq(const dvar_vector&);
 
-   friend void copy_status(const ostream & s, const dvar_vector & v);
+    friend void copy_status(const ostream& s, const dvar_vector& v);
 
-   friend dvar_vector exp(const dvar_vector &);
+    friend dvar_vector exp(const dvar_vector&);
 
-   friend dvar_vector log(const dvar_vector &);
+    friend dvar_vector log(const dvar_vector&);
 
-   friend dvar_vector sin(const dvar_vector &);
+    friend dvar_vector sin(const dvar_vector&);
 
-   friend dvar_vector fabs(const dvar_vector &);
+    friend dvar_vector fabs(const dvar_vector&);
 
-   friend dvector value(const dvar_vector & v1);
+    friend dvector value(const dvar_vector& v1);
 
-   friend dvar_vector sfabs(const dvar_vector &);
+    friend dvar_vector sfabs(const dvar_vector&);
 
-   friend void make_indvar_list(const dvar_vector &);
-   friend class array_size;
+    friend void make_indvar_list(const dvar_vector&);
+    friend class array_size;
 
-};				// end of class dvar_vector
-
+ }; // end of class dvar_vector
  /*
-    class funnel_dvar_vector : public dvar_vector
-    {
-    public:
+ class funnel_dvar_vector : public dvar_vector
+ {
+ public:
     funnel_dvar_vector(int l,int u);
     dvar_vector& operator=(const dvar_vector&);
-    };
-  */
+ };
+ */
 
 /**
  * Description not yet available.
  * \param
  */
-class fvar_ptr
-{
-   dvar_vector *p;
-};
+   class fvar_ptr
+   {
+     dvar_vector * p;
+   };
 
 /**
  * Description not yet available.
  * \param
  */
-class dvar_matrix
-{
-   int index_min;
-   int index_max;
-   dvar_vector *m;
-   mat_shapex *shape;
 
+ class dvar_matrix
+ {
+    int index_min;
+    int index_max;
+    dvar_vector * m;
+    mat_shapex * shape;
+
  public:
-   dvar_matrix & operator --(void)
-   {
-      index_min--;
-      index_max--;
-      m++;
-      return *this;
-   }
-   dvar_matrix & operator ++(void)
-   {
-      index_min++;
-      index_max++;
-      m--;
-      return *this;
-   }
+    dvar_matrix& operator -- (void) 
+    { 
+      index_min--;index_max--;m++; return *this;
+    }
+    dvar_matrix& operator ++ (void)  
+    { 
+      index_min++;index_max++;m--; return *this;
+    }
+  
+    int operator!(void) const { return (shape == NULL); }
+  inline dvar_vector& elem(int i) { return (m[i]); }
+  inline prevariable elem(int i, int j) { return (elem(i).elem(j) ) ; }
+  #ifdef USE_CONST
+    inline dvar_vector& elem(int i) const { return (m[i]); }
+    inline prevariable elem(int i, int j) const {return (elem(i).elem(j) ) ; }
+  #endif
 
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   inline dvar_vector & elem(int i)
-   {
-      return (m[i]);
-   }
-   inline prevariable elem(int i, int j)
-   {
-      return (elem(i).elem(j));
-   }
-#ifdef USE_CONST
-   inline dvar_vector & elem(int i) const
-   {
-      return (m[i]);
-   }
-   inline prevariable elem(int i, int j) const
-   {
-      return (elem(i).elem(j));
-   }
-#endif
-
-   friend class banded_symmetric_dvar_matrix;
-   friend class banded_lower_triangular_dvar_matrix;
-   friend class banded_symmetric_dmatrix;
-   friend class banded_lower_triangular_dmatrix;
-   friend class dvar3_array;
-   void shallow_copy(const dvar_matrix &);
-   dvar_matrix();
-   void allocate(int nrl, int nrh, int ncl, int nch);
-   void allocate(int nrl, int nrh);
-   void allocate(ad_integer nrl, ad_integer nrh);
-   void allocate(const dmatrix & m1);
-   void allocate(const dvar_matrix & m1);
-   void allocate(int nrl, int nrh, const ivector & ncl,
-		 const ivector & nch);
-   void allocate(int nrl, int nrh, int ncl, const ivector & nch);
-   void allocate(int nrl, int nrh, const ivector & ncl, int nch);
-   void allocate(void);
-   void deallocate();
-   dvar_matrix(const banded_symmetric_dvar_matrix & v);
-   dvar_matrix(const banded_lower_triangular_dvar_matrix & v);
+    friend class banded_symmetric_dvar_matrix;
+    friend class banded_lower_triangular_dvar_matrix;
+    friend class banded_symmetric_dmatrix;
+    friend class banded_lower_triangular_dmatrix;
+friend class dvar3_array;
+  void shallow_copy(const dvar_matrix&);
+  dvar_matrix();
+  void allocate(int nrl,int nrh,int ncl,int nch);
+  void allocate(int nrl,int nrh);
+  void allocate(ad_integer nrl,ad_integer nrh);
+  void allocate(const dmatrix& m1);
+  void allocate(const dvar_matrix& m1);
+  void allocate(int nrl, int nrh, const ivector& ncl, const ivector& nch);
+  void allocate(int nrl, int nrh, int ncl, const ivector& nch);
+  void allocate(int nrl, int nrh, const ivector& ncl, int nch);
+  void allocate(void);
+  void deallocate();
+  dvar_matrix(const banded_symmetric_dvar_matrix &v);
+  dvar_matrix(const banded_lower_triangular_dvar_matrix &v);
 # if defined(__NUMBERVECTOR__)
-   dvar_matrix(const param_init_vector_vector &);
-   dvar_matrix(const param_init_bounded_vector_vector &);
-   dvar_matrix(const param_init_bounded_number_matrix &);
+    dvar_matrix(const param_init_vector_vector& );
+    dvar_matrix(const param_init_bounded_vector_vector&);
+    dvar_matrix(const param_init_bounded_number_matrix&);
 # endif
-   dvar_matrix sub(int, int);
+  dvar_matrix sub(int,int);
 
-   double fill_seqadd(double, double);
+    double fill_seqadd( double, double);
 
-   int colmin(void) const
-   {
-      return ((*this) (indexmin()).indexmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (indexmin()).indexmax());
-   }
-   int rowmin(void) const
-   {
-      return (index_min);
-   }
-   int rowmax(void) const
-   {
-      return (index_max);
-   }
-   int indexmin(void) const
-   {
-      return (index_min);
-   }
-   int indexmax(void) const
-   {
-      return (index_max);
-   }
-   int rowsize() const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-   void colshift(int min);
-   void rowshift(int min);
+    int colmin(void) const { return ((*this)(indexmin()).indexmin()); }
+    int colmax(void) const { return((*this)(indexmin()).indexmax()); }
+    int rowmin(void) const { return(index_min); }
+    int rowmax(void) const { return(index_max); }
+    int indexmin(void) const { return(index_min); }
+    int indexmax(void) const { return(index_max); }
+    int rowsize() const {return (rowmax() - rowmin() + 1); } // returns the number of rows
+    int colsize() const {return (colmax() - colmin() + 1); } // returns the number of columns
+    void colshift(int min);
+    void rowshift(int min);
 
-   friend char *fform(const char *, const dvar_matrix &);
+    friend char* fform(const char*, const dvar_matrix&);
 
-   friend class dvar_vector;
+    friend class dvar_vector;
 
-   dvar_matrix(const ad_integer & nrl, const ad_integer & nrh,
-	       const index_type & ncl, const index_type & nch);
+    dvar_matrix(const ad_integer& nrl,const ad_integer& nrh,
+      const index_type& ncl,const index_type& nch);
 
-   void allocate(const ad_integer & nrl, const ad_integer & nrh,
-		 const index_type & ncl, const index_type & nch);
+    void allocate(const ad_integer& nrl,const ad_integer& nrh,
+      const index_type& ncl,const index_type& nch);
 
-   dvar_matrix(int, int, int, int);
-   dvar_matrix(int, int);
-   dvar_matrix(int, int, kkludge_object kk);
-   // makes a matrix [nrl..nrh][ncl..nch]
+    dvar_matrix( int,  int,  int,  int );
+    dvar_matrix( int,  int);
+    dvar_matrix( int,  int, kkludge_object kk);
+             // makes a matrix [nrl..nrh][ncl..nch]
 
-   dvar_matrix(int, int, const ivector &, const ivector &);
-   // makes a ragged dvar_matrix [nrl..nrh][ncl..nch]
+    dvar_matrix(int, int, const ivector&, const ivector&);
+             // makes a ragged dvar_matrix [nrl..nrh][ncl..nch]
 
-   dvar_matrix(int, int, int, const ivector &);
-   // makes a ragged dvar_matrix [nrl..nrh][ncl..nch]
+    dvar_matrix(int, int, int, const ivector&);
+             // makes a ragged dvar_matrix [nrl..nrh][ncl..nch]
 
-   dvar_matrix(const dvar_matrix &);
-   // copy initializer
-   void initialize(void);
+    dvar_matrix(const dvar_matrix&);
+             // copy initializer
+    void initialize(void);
 
-   dvar_matrix(const dmatrix &);
+    dvar_matrix(const dmatrix&);
 
-   //dvar_matrix(char *);
+    //dvar_matrix(char *);
 
    ~dvar_matrix();
 
-   void save_dvar_matrix_position(void) const;
-   void save_dvar_matrix_value(void) const;
+    void save_dvar_matrix_position(void) const;
+    void save_dvar_matrix_value(void) const;
 
-   void fill(const char *);
-   //void colfill(const int&n,...);
-   //void rowfill(const int&n,...);
+    void fill(const char *);
+    //void colfill(const int&n,...);
+    //void rowfill(const int&n,...);
 
-   void colfill_randu(const int &j, long int &n);
-   void rowfill_randu(const int &i, long int &n);
-   void colfill_randn(const int &j, long int &n);
-   void rowfill_randn(const int &i, long int &n);
-   void fill_randn(long int &n);
-   void fill_randu(long int &n);
+    void colfill_randu(const int &j, long int &n);
+    void rowfill_randu(const int &i, long int &n);
+    void colfill_randn(const int &j, long int &n);
+    void rowfill_randn(const int& i, long int& n);
+    void fill_randn(long int&n);
+    void fill_randu(long int&n);
 
-   void colfill_seqadd_ni(const int &, double, double);
-   void colfill_randu_ni(const int &j, long int &n);
-   void rowfill_randu_ni(const int &i, long int &n);
-   void colfill_randn_ni(const int &j, long int &n);
-   void rowfill_randn_ni(const int &i, long int &n);
-   void fill_randn_ni(long int &n);
-   void fill_randu_ni(long int &n);
+    void colfill_seqadd_ni(const int&, double, double);
+    void colfill_randu_ni(const int &j, long int &n);
+    void rowfill_randu_ni(const int& i, long int& n);
+    void colfill_randn_ni(const int &j, long int &n);
+    void rowfill_randn_ni(const int& i, long int& n);
+    void fill_randn_ni(long int&n);
+    void fill_randu_ni(long int&n);
 
-   void colfill_seqadd(const int &, double, double);
-   void rowfill_seqadd(const int &, double, double);
-   void colfill(int j, const dvar_vector & v);
-   void rowfill(int j, const dvar_vector & v);
+    void colfill_seqadd(const int&, double, double);
+    void rowfill_seqadd(const int&, double, double);
+    void colfill(int j, const dvar_vector& v);
+    void rowfill(int j, const dvar_vector& v);
 
-   void write_on(const ostream &) const;
-   void write_on(const uostream &) const;
-   void read_from(const istream &);
-   void read_from(const uistream &);
+    void write_on(const ostream&) const;
+    void write_on(const uostream&) const;
+    void read_from(const istream&);
+    void read_from(const uistream&);
 
 #ifdef OPT_LIB
-   inline dvar_vector & operator[] (register int i)
-   {
-      return (m[i]);
-   }
-   inline dvar_vector & operator() (register int i)
-   {
-      return (m[i]);
-   }
+      inline dvar_vector& operator[] (register int i) { return (m[i]); }
+      inline dvar_vector& operator() (register int i) { return (m[i]); }
 #else
-   dvar_vector & operator ()(int i);
-   dvar_vector & operator[](int);
+      dvar_vector& operator () (int i);
+      dvar_vector& operator[] (int) ;
 #endif
 
 #ifdef USE_CONST
-#ifdef OPT_LIB
-   inline const dvar_vector & operator[] (register int i) const
-   {
-      return m[i];
-   }
-   inline const dvar_vector & operator() (register int i) const
-   {
-      return m[i];
-   }
-#else
-   const dvar_vector & operator() (int i) const;
-   const dvar_vector & operator[] (int) const;
+  #ifdef OPT_LIB
+      inline const dvar_vector& operator[](register int i) const { return m[i]; }
+      inline const dvar_vector& operator()(register int i) const { return m[i]; }
+  #else
+      const dvar_vector& operator()(int i) const;
+      const dvar_vector& operator[](int) const;
+  #endif
 #endif
-#endif
 
-#ifdef OPT_LIB
-#ifdef __NDPX__
-   prevariable operator () (register int i, register int j)
-   {
-      return (prevariable((m[i]).va + j));
-   }
-#else
-   inline prevariable operator () (register int i, register int j)
-   {
-      return ((m[i]).va + j);
-   }
-#endif
-#else
-   prevariable operator () (int i, int j);
-#endif
+  #ifdef OPT_LIB
+    #ifdef __NDPX__
+	prevariable operator () (register int i, register int j)
+	  { return ( prevariable((m[i]).va+j) ); }
+    #else
+	inline prevariable operator () (register int i, register int j)
+	  { return ( (m[i]).va+j ); }
+    #endif
+  #else
+      prevariable operator () (int i, int j);
+  #endif
 
-   inline double &elem_value(register int i, register int j)
-   {
-      return *(double *) ((m[i]).va + j);
-   }
+	inline double& elem_value (register int i, register int j) 
+	  { return * (double*) ((m[i]).va+j); }
 
 #ifdef USE_CONST
-   inline const double &elem_value(register int i, register int j) const
-   {
-      return *(double *) ((m[i]).va + j);
-   }
-#ifdef OPT_LIB
-#ifdef __NDPX__
-   prevariable operator() (register int i, register int j) const
-   {
-      return (prevariable((m[i]).va + j));
-   }
-#else
-   inline prevariable operator() (register int i, register int j) const
-   {
-      return ((m[i]).va + j);
-   }
+  inline const double& elem_value(register int i, register int j) const 
+    { return * (double*) ((m[i]).va+j); }
+  #ifdef OPT_LIB
+    #ifdef __NDPX__
+	prevariable operator()(register int i, register int j) const 
+	  { return ( prevariable((m[i]).va+j) ); }
+    #else
+	inline prevariable operator()(register int i, register int j) const 
+	  { return ( (m[i]).va+j ); }
+    #endif
+  #else
+      const prevariable operator()(int i, int j) const;
+  #endif
 #endif
-#else
-   const prevariable operator() (int i, int j) const;
-#endif
-#endif
 
-   dvar_matrix & operator+=(const dvar_matrix & x);
-   dvar_matrix & operator-=(const dvar_matrix & x);
-   dvar_matrix & operator+=(const dmatrix & x);
-   dvar_matrix & operator-=(const dmatrix & x);
+    dvar_matrix& operator+=(const dvar_matrix& x);
+    dvar_matrix& operator-=(const dvar_matrix& x);
+    dvar_matrix& operator+=(const dmatrix& x);
+    dvar_matrix& operator-=(const dmatrix& x);
 
 
-   dvar_matrix & operator=(const dvar_matrix &);
+    dvar_matrix& operator=(const dvar_matrix&);
 
-   dvar_matrix & operator=(const dmatrix &);
-   dvar_matrix & operator =(double t);
-   dvar_matrix & operator=(const prevariable & t);
+    dvar_matrix& operator=(const dmatrix&);
+    dvar_matrix& operator = ( double t);
+    dvar_matrix& operator=(const prevariable& t);
 
-   dvar_matrix & operator*=(const prevariable & t);
-   dvar_matrix & operator *=(double t);
-   dvar_matrix & operator/=(const prevariable & t);
-   dvar_matrix & operator /=(double t);
+    dvar_matrix& operator*=(const prevariable& t);
+    dvar_matrix& operator *= ( double t);
+    dvar_matrix& operator/=(const prevariable& t);
+    dvar_matrix& operator /= ( double t);
 
-   friend dvar_vector operator*(const dvar_vector &, const dvar_matrix &);
+    friend dvar_vector operator*(const dvar_vector&, const dvar_matrix&);
 
-   friend dvar_vector operator*(const dvar_matrix &, const dvar_vector &);
+    friend dvar_vector operator*(const dvar_matrix&, const dvar_vector&);
 
-   friend dvar_vector operator*(const dvector &, const dvar_matrix &);
+    friend dvar_vector operator*(const dvector&, const dvar_matrix&);
 
-   friend dvar_vector operator*(const dvar_matrix &, const dvector &);
+    friend dvar_vector operator*(const dvar_matrix&, const dvector&);
 
-   friend dvar_matrix operator*(const dvar_matrix &, const dvar_matrix &);
+    friend dvar_matrix operator*(const dvar_matrix&, const dvar_matrix&);
 
-   friend dvar_matrix operator*(const dvar_matrix &, const dmatrix &);
+    friend dvar_matrix operator*(const dvar_matrix&, const dmatrix&);
 
-   friend dvar_matrix operator*(const dmatrix &, const dvar_matrix &);
+    friend dvar_matrix operator*(const dmatrix&, const dvar_matrix&);
 
-   friend dvar_matrix operator+(const dvar_matrix &, const dvar_matrix &);
-   friend dvar_matrix operator+(const dvar_matrix &, const dmatrix &);
-   friend dvar_matrix operator+(const dmatrix &, const dvar_matrix &);
+    friend dvar_matrix operator+(const dvar_matrix&, const dvar_matrix&);
+    friend dvar_matrix operator+(const dvar_matrix&, const dmatrix&);
+    friend dvar_matrix operator+(const dmatrix&, const dvar_matrix&);
 
-   friend dvar_matrix operator+(double, const dvar_matrix &);
-   friend dvar_matrix operator+(const dvar_matrix &, double);
-   friend dvar_matrix operator-(double, const dvar_matrix &);
-   friend dvar_matrix operator-(const dvar_matrix &, double);
+    friend dvar_matrix operator+(double, const dvar_matrix&);
+    friend dvar_matrix operator+(const dvar_matrix&, double);
+    friend dvar_matrix operator-(double, const dvar_matrix&);
+    friend dvar_matrix operator-(const dvar_matrix&, double);
 
-   friend dvar_matrix operator+(const dvariable &, const dvar_matrix &);
-   friend dvar_matrix operator+(const dvar_matrix &, const dvariable &);
-   friend dvar_matrix operator-(const dvariable &, const dvar_matrix &);
-   friend dvar_matrix operator-(const dvar_matrix &, const dvariable &);
+    friend dvar_matrix operator+(const dvariable&, const dvar_matrix&);
+    friend dvar_matrix operator+(const dvar_matrix&, const dvariable&);
+    friend dvar_matrix operator-(const dvariable&, const dvar_matrix&);
+    friend dvar_matrix operator-(const dvar_matrix&, const dvariable&);
 
-   friend dvar_matrix operator-(const dvar_matrix &, const dvar_matrix &);
-   friend dvar_matrix operator-(const dvar_matrix &, const dmatrix &);
-   friend dvar_matrix operator-(const dmatrix &, const dvar_matrix &);
+    friend dvar_matrix operator-(const dvar_matrix&, const dvar_matrix&);
+    friend dvar_matrix operator-(const dvar_matrix&, const dmatrix&);
+    friend dvar_matrix operator-(const dmatrix&, const dvar_matrix&);
 
-   friend dvar_matrix inv(const dvar_matrix &);
+    friend dvar_matrix inv(const dvar_matrix&);
 
-   friend dvariable det(const dvar_matrix &);
-   friend dvariable ln_det(const dvar_matrix &, const int &sgn);
+    friend dvariable det(const dvar_matrix&);
+    friend dvariable ln_det(const dvar_matrix&,const int& sgn);
 
-   //friend dvar_matrix testsub(dvar_matrix);
+    //friend dvar_matrix testsub(dvar_matrix);
 
-   friend dvar_matrix trans(const dvar_matrix &);
+    friend dvar_matrix trans(const dvar_matrix&);
 
-   friend dvariable norm(const dvar_matrix &);
-   friend dvariable norm2(const dvar_matrix &);
-   friend dvariable sumsq(const dvar_matrix &);
+    friend dvariable norm(const dvar_matrix&);
+    friend dvariable norm2(const dvar_matrix&);
+    friend dvariable sumsq(const dvar_matrix&);
 
-   friend void copy_status(const ostream & s, const dvar_matrix & m1);
+    friend void copy_status(const ostream& s, const dvar_matrix& m1);
 
-};				// end of class dvar_matrix
+ }; // end of class dvar_matrix
+dvariable ln_det(const dvar_matrix&);
+dvar_matrix operator * (const dvar_matrix& t1, double x);
+dmatrix value(const dvar_matrix& m);
+d3_array value(const dvar3_array& a);
+dvar_vector sort(const dvar_vector&,int NSTACK=60);
+dvector sort(const dvector&,int NSTACK=60);
+ivector sort(const ivector&,int NSTACK=60);
+dvector sort(const dvector&,const ivector& index,int NSTACK=60);
+ivector sort(const ivector&,const ivector& index,int NSTACK=60);
+dmatrix sort(const dmatrix&,int column,int NSTACK=60);
+imatrix sort(const imatrix&,int column,int NSTACK=60);
 
-dvariable ln_det(const dvar_matrix &);
-dvar_matrix operator *(const dvar_matrix & t1, double x);
-dmatrix value(const dvar_matrix & m);
-d3_array value(const dvar3_array & a);
-dvar_vector sort(const dvar_vector &, int NSTACK = 60);
-dvector sort(const dvector &, int NSTACK = 60);
-ivector sort(const ivector &, int NSTACK = 60);
-dvector sort(const dvector &, const ivector & index, int NSTACK = 60);
-ivector sort(const ivector &, const ivector & index, int NSTACK = 60);
-dmatrix sort(const dmatrix &, int column, int NSTACK = 60);
-imatrix sort(const imatrix &, int column, int NSTACK = 60);
 
+#include "factors.h" 
+int count_factor(const dvector& v, const double& eps);
+ivector as_factor(const dvector& v, const double eps=1.0e-6);
+int count_factor(const ivector& v);
 
-#include "factors.h"
-int count_factor(const dvector & v, const double &eps);
-ivector as_factor(const dvector & v, const double eps = 1.0e-6);
-int count_factor(const ivector & v);
-
  //void gradcalc( int , double *);
-void gradcalc(int nvar, const dvector & g);
-void slave_gradcalc(void);
+ void gradcalc(int nvar,const dvector& g);
+ void slave_gradcalc(void);
 
 /**
  * Description not yet available.
  * \param
  */
-class dmatrix
-{
+
+ class dmatrix
+ {
  protected:
    int index_min;
    int index_max;
-   dvector *m;
-   mat_shapex *shape;
-   friend char *fform(const char *, const dmatrix &);
-   friend class dvar_matrix;
+    dvector * m;
+    mat_shapex * shape;
+    friend char* fform(const char*, const dmatrix&);
+    friend class dvar_matrix;
  public:
+ 
+    dmatrix& operator -- (void) 
+    { 
+      index_min--;index_max--;m++; return *this;
+    }
+    dmatrix& operator ++ (void)  
+    { 
+      index_min++;index_max++;m--; return *this;
+    }
+    void shallow_copy(const dmatrix&);
+    int operator!(void) const { return (shape == NULL); }
 
-   dmatrix & operator --(void)
-   {
-      index_min--;
-      index_max--;
-      m++;
-      return *this;
-   }
-   dmatrix & operator ++(void)
-   {
-      index_min++;
-      index_max++;
-      m--;
-      return *this;
-   }
-   void shallow_copy(const dmatrix &);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+    dmatrix sub(int,int);
+    dmatrix(void); 
+    dmatrix(int,int,kkludge_object); 
+    dmatrix(int,int); 
+    void allocate(void);
+    void allocate(const dmatrix& dm);
+    void allocate(const dvar_matrix&);
+    void allocate(int nrl,int nrh,int ncl,int nch);
+    void allocate(int nrl,int nrh);
+    void allocate(ad_integer nrl,ad_integer nrh);
+    void allocate(int nrl,int nrh,int ncl,const ivector& nch);
+    //void allocate(int nrl,int nrh,
+    // const index_type& ncl,const index_type& nch);
+    void allocate(int nrl,int nrh,const ivector& ncl,int nch);
+    void deallocate();
+    void allocate(const ad_integer& nrl,const ad_integer& nrh,
+      const index_type& ncl,const index_type& nch);
+    void allocate(int nrl,int nrh,const ivector& ncl,const ivector& nch);
+    friend class banded_symmetric_dmatrix;
+    friend class banded_lower_triangular_dmatrix;
 
-   dmatrix sub(int, int);
-   dmatrix(void);
-   dmatrix(int, int, kkludge_object);
-   dmatrix(int, int);
-   void allocate(void);
-   void allocate(const dmatrix & dm);
-   void allocate(const dvar_matrix &);
-   void allocate(int nrl, int nrh, int ncl, int nch);
-   void allocate(int nrl, int nrh);
-   void allocate(ad_integer nrl, ad_integer nrh);
-   void allocate(int nrl, int nrh, int ncl, const ivector & nch);
-   //void allocate(int nrl,int nrh,
-   // const index_type& ncl,const index_type& nch);
-   void allocate(int nrl, int nrh, const ivector & ncl, int nch);
-   void deallocate();
-   void allocate(const ad_integer & nrl, const ad_integer & nrh,
-		 const index_type & ncl, const index_type & nch);
-   void allocate(int nrl, int nrh, const ivector & ncl,
-		 const ivector & nch);
-   friend class banded_symmetric_dmatrix;
-   friend class banded_lower_triangular_dmatrix;
+    dmatrix( int,  int,  int,  int );
+             // makes a matrix [nrl..nrh][ncl..nch]
 
-   dmatrix(int, int, int, int);
-   // makes a matrix [nrl..nrh][ncl..nch]
+    dmatrix(const ad_integer& nrl,const ad_integer& nrh,
+      const index_type& ncl,const index_type& nch);
 
-   dmatrix(const ad_integer & nrl, const ad_integer & nrh,
-	   const index_type & ncl, const index_type & nch);
+    dmatrix(int, int, const ivector& coll, const ivector& colh);
+             // makes a ragged dmatrix[nrl..nrh][ncl..nch]
 
-   dmatrix(int, int, const ivector & coll, const ivector & colh);
-   // makes a ragged dmatrix[nrl..nrh][ncl..nch]
+    dmatrix(int, int, int coll, const ivector& colh);
+             // makes a ragged dmatrix[nrl..nrh][ncl..nch]
 
-   dmatrix(int, int, int coll, const ivector & colh);
-   // makes a ragged dmatrix[nrl..nrh][ncl..nch]
+    dmatrix(const dvar_matrix_position&);
 
-   dmatrix(const dvar_matrix_position &);
+    dmatrix(const dmatrix_position&);
 
-   dmatrix(const dmatrix_position &);
+    dmatrix(const dmatrix&);
+    dmatrix(const banded_symmetric_dmatrix&);
+    dmatrix(const banded_lower_triangular_dmatrix&);
+    dmatrix(char *);
+    void fill(const char *);
+    double fill_seqadd( double, double);
+    void initialize(void);
+             // copy initializer
 
-   dmatrix(const dmatrix &);
-   dmatrix(const banded_symmetric_dmatrix &);
-   dmatrix(const banded_lower_triangular_dmatrix &);
-   dmatrix(char *);
-   void fill(const char *);
-   double fill_seqadd(double, double);
-   void initialize(void);
-   // copy initializer
-
    ~dmatrix();
-   void save_dmatrix_derivatives(const dvar_matrix_position & pos) const;
-   void save_dmatrix_derivatives_na(const dvar_matrix_position & pos)
-      const;
-   void save_dmatrix_value(void) const;
-   void save_dmatrix_position(void) const;
-   //void save_dmatrix_derivatives(void);
+    void save_dmatrix_derivatives(const dvar_matrix_position& pos) const;
+    void save_dmatrix_derivatives_na(const dvar_matrix_position& pos) const;
+    void save_dmatrix_value(void) const;
+    void save_dmatrix_position(void) const;
+    //void save_dmatrix_derivatives(void);
 
-   int indexmin(void) const
-   {
-      return index_min;
-   }
-   int indexmax(void) const
-   {
-      return index_max;
-   }
-   int rowmin(void) const
-   {
-      return index_min;
-   }
-   int rowmax(void) const
-   {
-      return index_max;
-   }
-   int colmin(void) const
-   {
-      return ((*this) (indexmin()).indexmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (indexmin()).indexmax());
-   }
-   int rowsize() const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-   void rowshift(int min);
-   void colshift(int min);
+    int indexmin(void) const { return index_min; }
+    int indexmax(void) const { return index_max; }
+    int rowmin(void) const { return index_min; }
+    int rowmax(void) const { return index_max; }
+    int colmin(void) const { return((*this)(indexmin()).indexmin()); }
+    int colmax(void) const { return((*this)(indexmin()).indexmax()); }
+    int rowsize() const { return (rowmax() - rowmin() + 1); } // returns the number of rows
+    int colsize() const { return (colmax() - colmin() + 1); } // returns the number of columns
+    void rowshift(int min);
+    void colshift(int min);
 
-   void write_on(const ostream &) const;
-   void write_on(const uostream &) const;
-   void read_from(const istream &);
-   void read_from(const uistream &);
+    void write_on(const ostream&) const;
+    void write_on(const uostream&) const;
+    void read_from(const istream&);
+    void read_from(const uistream&);
 
-   //void colfill(const int&n,...);
-   //void rowfill(const int&n,...);
+    //void colfill(const int&n,...);
+    //void rowfill(const int&n,...);
 
-   void colfill_randu(const int &j, long int &n);
-   void rowfill_randu(const int &i, long int &n);
-   void colfill_randn(const int &j, long int &n);
-   void fill_randn(long int &n);
-   void fill_randu(long int &n);
-   void rowfill_randn(const int &i, long int &n);
+    void colfill_randu(const int &j, long int &n);
+    void rowfill_randu(const int& i, long int& n);
+    void colfill_randn(const int &j,long int &n);
+    void fill_randn(long int&n);
+    void fill_randu(long int&n);
+    void rowfill_randn(const int& i,long int& n);
 
 
 
-   void colfill_randu(const int &j, const random_number_generator & rng);
-   void rowfill_randu(const int &i, const random_number_generator & rng);
-   void fill_randn(const random_number_generator & rng);
-   void fill_randcau(const random_number_generator & rng);
-   void fill_randu(const random_number_generator & rng);
-   void colfill_randn(const int &j, const random_number_generator & rng);
-   void rowfill_randn(const int &i, const random_number_generator & rng);
+    void colfill_randu(const int &j, const random_number_generator& rng);
+    void rowfill_randu(const int& i, const random_number_generator& rng);
+    void fill_randn(const random_number_generator& rng);
+    void fill_randcau(const random_number_generator& rng);
+    void fill_randu(const random_number_generator& rng);
+    void colfill_randn(const int &j, const random_number_generator& rng);
+    void rowfill_randn(const int& i, const random_number_generator& rng);
 
-   void colfill_randu_ni(const int &j, long int &n);
-   void rowfill_randu_ni(const int &i, long int &n);
-   void colfill_randn_ni(const int &j, long int &n);
-   void fill_randn_ni(long int &n);
-   void fill_randu_ni(long int &n);
-   void rowfill_randn_ni(const int &i, long int &n);
+    void colfill_randu_ni(const int &j, long int &n);
+    void rowfill_randu_ni(const int& i, long int& n);
+    void colfill_randn_ni(const int &j, long int &n);
+    void fill_randn_ni(long int&n);
+    void fill_randu_ni(long int&n);
+    void rowfill_randn_ni(const int& i, long int& n);
 
 
 
-   void colfill_seqadd(const int &, double, double);
-   void rowfill_seqadd(const int &, double, double);
-   void colfill(int j, const dvector & v);
-   void rowfill(int j, const dvector & v);
+    void colfill_seqadd(const int&, double, double);
+    void rowfill_seqadd(const int&, double, double);
+    void colfill(int j, const dvector& v);
+    void rowfill(int j, const dvector& v);
 
 #if defined(OPT_LIB)
-   inline dvector & operator() (register int i)
-   {
-      return m[i];
-   }
-   inline dvector & operator[] (register int i)
-   {
-      return m[i];
-   }
+      inline dvector& operator() (register int i) { return m[i]; }
+      inline dvector& operator[] (register int i) { return m[i]; }
 #else
-   dvector & operator()(int i);
-   dvector & operator[](int);
+      dvector& operator() (int i);
+      dvector& operator[] (int) ;
 #endif
 
 #ifdef USE_CONST
-#if defined(OPT_LIB)
-   inline const dvector & operator() (register int i) const
-   {
-      return m[i];
-   }
-   inline const dvector & operator[] (register int i) const
-   {
-      return m[i];
-   }
+  #if defined(OPT_LIB)
+      inline const dvector& operator()(register int i) const { return m[i]; }
+      inline const dvector& operator[](register int i) const { return m[i]; }
 #else
-   const dvector & operator() (int i) const;
-   const dvector & operator[] (int) const;
+      const dvector& operator()(int i) const;
+      const dvector& operator[](int) const;
+  #endif
 #endif
-#endif
 
-#if defined(OPT_LIB) && !defined(__INTEL_COMPILER)
-   inline double &operator() (register int i, register int j)
-   {
-      return (*(m[i].v + j));
-   }
-   inline const double &operator() (register int i, register int j) const
-   {
-      return (*(m[i].v + j));
-   }
+#if defined(OPT_LIB) && !defined(__INTEL_COMPILER) 
+      inline double& operator() (register int i, register int j) {return(*(m[i].v+j));}
+      inline const double& operator() (register int i, register int j) const 
+      {return(*(m[i].v+j));}
 #else
-   double &operator() (int i, int j);
-   const double &operator() (int i, int j) const;
+      double& operator()(int i, int j);
+      const double& operator()(int i, int j) const;
 #endif
 
-   inline dvector & elem(int i)
-   {
-      return (*(m + i));
-   }
-   inline double &elem(int i, int j)
-   {
-      return (*((*(m + i)).v + j));
-   }
-#ifdef USE_CONST
-   inline const dvector & elem(int i) const
-   {
-      return (*(m + i));
-   }
-   inline const double &elem(int i, int j) const
-   {
-      return (*((*(m + i)).v + j));
-   }
-#endif
-   friend class d3_array;
-   friend dvector operator*(const dvector &, const dmatrix &);
+    inline dvector& elem(int i) { return( *(m+i) ); }
+    inline double& elem(int i,int j) { return( *((*(m+i)).v+j) ); }
+    #ifdef USE_CONST
+      inline const dvector& elem(int i) const { return (*(m + i)); }
+      inline const double& elem(int i, int j) const 
+        { return( *((*(m+i)).v+j) ); }
+    #endif
+    friend class d3_array;
+    friend dvector operator*(const dvector&, const dmatrix& );
 
-   friend dvector operator*(const dmatrix &, const dvector &);
+    friend dvector operator*(const dmatrix&, const dvector&);
 
-   friend dvar_vector operator*(const dvar_vector &, const dmatrix &);
+    friend dvar_vector operator*(const dvar_vector&, const dmatrix&);
 
-   friend dvar_vector operator*(const dmatrix &, const dvar_vector &);
+    friend dvar_vector operator*(const dmatrix&, const dvar_vector&);
 
-   friend dmatrix operator*(const dmatrix &, const dmatrix &);
+    friend dmatrix operator*(const dmatrix&, const dmatrix&);
 
-   friend dvar_matrix operator*(const dvar_matrix &, const dmatrix &);
+    friend dvar_matrix operator*(const dvar_matrix&, const dmatrix&);
 
-   friend dvar_matrix operator*(const dmatrix &, const dvar_matrix &);
+    friend dvar_matrix operator*(const dmatrix&, const dvar_matrix&);
 
-   friend dvar_matrix::dvar_matrix(const dmatrix &);
+    friend dvar_matrix::dvar_matrix(const dmatrix&);
 
-   friend dmatrix operator-(const dmatrix &, const dmatrix &);
-   friend dmatrix operator+(const dmatrix &, const dmatrix &);
+    friend dmatrix operator-(const dmatrix&, const dmatrix&);
+    friend dmatrix operator+(const dmatrix&, const dmatrix&);
 
-   friend dvar_matrix operator+(const dvar_matrix &, const dmatrix &);
+    friend dvar_matrix operator+(const dvar_matrix&, const dmatrix&);
 
-   friend dvar_matrix operator+(const dmatrix &, const dvar_matrix &);
+    friend dvar_matrix operator+(const  dmatrix&, const dvar_matrix&);
 
-   friend dmatrix trans(const dmatrix & m1);
+    friend dmatrix trans(const dmatrix& m1);
 
-   friend dmatrix inv(const dmatrix &);
-   friend dmatrix inv(const dmatrix & m1, const double &_ln_det,
-		      const int &_sgn);
+    friend dmatrix inv(const dmatrix&);
+    friend dmatrix inv(const dmatrix& m1, const double& _ln_det, const int& _sgn);
 
-   friend double det(const dmatrix &);
-   friend double ln_det(const dmatrix & m1, const int &sgn);
+    friend double det(const dmatrix&);
+    friend double ln_det(const dmatrix& m1, const int& sgn);
 
-   friend double norm(const dmatrix &);
-   friend double norm2(const dmatrix &);
-   friend double sumsq(const dmatrix &);
+    friend double norm(const dmatrix&);
+    friend double norm2(const dmatrix&);
+    friend double sumsq(const dmatrix&);
 
-   dmatrix & operator+=(const dmatrix & t);
-   dmatrix & operator-=(const dmatrix & t);
+    dmatrix& operator+=(const dmatrix& t);
+    dmatrix& operator-=(const dmatrix& t);
 
-   dmatrix & operator =(const dmatrix & t);
-   dmatrix & operator =(double t);
+    dmatrix& operator = (const dmatrix& t);
+    dmatrix& operator = ( double t);
 
-   dmatrix operator() (const ivector & t);
+    dmatrix operator()(const ivector& t);
 
-   friend dvar_matrix & dvar_matrix::operator=(const dmatrix &);
+    friend dvar_matrix& dvar_matrix::operator=(const dmatrix&);
 
-   dmatrix(const tdmatrix & t);
+    dmatrix(const tdmatrix& t);
 
-   dmatrix & operator /=(double d);
-   dmatrix & operator *=(double d);
+    dmatrix& operator /= (double d);
+    dmatrix& operator *= (double d);
 
-};				// end of class dmatrix
+ }; // end of class dmatrix
+int norm2(const imatrix&);
+imatrix operator * (const imatrix& , const imatrix& );
+imatrix operator + (const imatrix& , const imatrix& );
+imatrix operator - (const imatrix& , const imatrix& );
 
-imatrix operator*(const imatrix &, const imatrix &);
+dmatrix  trans(const dmatrix& m1);
 
-dmatrix trans(const dmatrix & m1);
+imatrix  trans(const imatrix& m1);
 
-imatrix trans(const imatrix & m1);
+dvariable dfatan1( dvariable , double , double , double * );
 
-dvariable dfatan1(dvariable, double, double, double *);
+double dftinv(double , double , double );
 
-double dftinv(double, double, double);
+dvariable boundp( double , double , double , double * );
 
-dvariable boundp(double, double, double, double *);
+dvariable dfboundp( double , double , double , double *);
+dvariable dfboundp( const prevariable& , double , double);
 
-dvariable dfboundp(double, double, double, double *);
-dvariable dfboundp(const prevariable &, double, double);
+double mean(const dvector&);
+double mean(const dmatrix&);
+double mean(const d3_array&);
 
-double mean(const dvector &);
-double mean(const dmatrix &);
-double mean(const d3_array &);
+double std_dev(const dvector&);
+double var(const dvector&);
 
-double std_dev(const dvector &);
-double var(const dvector &);
+dvariable mean(const dvar_vector&);
+dvariable mean(const dvar_matrix&);
+dvariable mean(const dvar3_array&);
 
-dvariable mean(const dvar_vector &);
-dvariable mean(const dvar_matrix &);
-dvariable mean(const dvar3_array &);
+dvariable std_dev(const dvar_vector&);
+dvariable var(const dvar_vector&);
 
-dvariable std_dev(const dvar_vector &);
-dvariable var(const dvar_vector &);
+dvariable sum(const dvar_vector&);
+double sum(const dvector&);
+int sum(const ivector&);
 
-dvariable sum(const dvar_vector &);
-double sum(const dvector &);
-int sum(const ivector &);
+dvar_vector rowsum(const dvar_matrix&);
+dvar_vector colsum(const dvar_matrix&);
 
-dvar_vector rowsum(const dvar_matrix &);
-dvar_vector colsum(const dvar_matrix &);
+dvector colsum(const dmatrix&);
+dvector rowsum(const dmatrix&);
 
-dvector colsum(const dmatrix &);
-dvector rowsum(const dmatrix &);
+ivector colsum(const imatrix&);
+ivector rowsum(const imatrix&);
 
-ivector colsum(const imatrix &);
-ivector rowsum(const imatrix &);
+int colsum(const imatrix&,int column);
+double colsum(const dmatrix&,int column);
+dvariable colsum(const dvar_matrix&,int column);
 
-int colsum(const imatrix &, int column);
-double colsum(const dmatrix &, int column);
-dvariable colsum(const dvar_matrix &, int column);
+double sfabs( double t1); //"smoothed absolute value function
 
-double sfabs(double t1);	//"smoothed absolute value function
+dvector sfabs(const dvector& t1); //"smoothed absolute value function
 
-dvector sfabs(const dvector & t1);	//"smoothed absolute value function
 
 
-
 //// daves' addition to john's additions
 
 /**
@@ -3909,239 +3540,192 @@
  */
 class imatrix_position
 {
- public:
-   int row_min;
-   int row_max;
-   ivector lb;
-   ivector ub;
-   ptr_vector ptr;
-   imatrix_position(const imatrix &);
-   imatrix_position(int min, int max);
-   imatrix_position(const imatrix_position &);
-   ivector_position operator () (int i);
+public:
+  int row_min;
+  int row_max;
+  ivector lb;
+  ivector ub;
+  ptr_vector ptr;
+  imatrix_position(const imatrix&);
+  imatrix_position(int min,int max);
+  imatrix_position(const imatrix_position&);
+  ivector_position operator () (int i);
 };
 
 imatrix_position restore_imatrix_position(void);
-imatrix restore_imatrix_value(const imatrix_position &);
+imatrix restore_imatrix_value(const imatrix_position&);
 
 /**
  * Description not yet available.
  * \param
  */
-class imatrix
-{
- protected:
-   int index_min;
-   int index_max;
-   ivector *m;
-   mat_shapex *shape;
-   friend char *fform(const char *, const dmatrix &);
 
+ class imatrix
+ {
+  protected:
+    int index_min;
+    int index_max;
+    ivector * m;
+    mat_shapex * shape;
+    friend char* fform(const char*, const dmatrix&);
+
  public:
 
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+    int operator!(void) const { return (shape == NULL); }
 
-   imatrix(int, int);
-   // makes a matrix [0..nr][0..nc]
+    imatrix( int ,  int );
+              // makes a matrix [0..nr][0..nc]
 
-   imatrix(int nrl, int nrh, const ivector & iv);
-   void allocate(int nrl, int nrh, const ivector & iv);
+    imatrix(int nrl, int nrh, const ivector& iv);
+    void allocate(int nrl, int nrh, const ivector& iv);
 
-   imatrix(int, int, int, int);
-   // makes a matrix [nrl..nrh][ncl..nch]
-   imatrix(int, int, int, const ivector &);
-   imatrix sub(int, int);
-   imatrix(int, int, const ivector &, const ivector &);
-   imatrix(const ad_integer & nrl, const ad_integer & nrh,
-	   const index_type & ncl, const index_type & nch);
+    imatrix( int,  int,  int,  int );
+             // makes a matrix [nrl..nrh][ncl..nch]
+    imatrix(int, int, int, const ivector&);
+    imatrix sub( int,  int);
+    imatrix(int, int, const ivector&, const ivector&);
+    imatrix(const ad_integer& nrl,const ad_integer& nrh,
+      const index_type& ncl,const index_type& nch);
 
-   imatrix & operator=(const imatrix & t);
-   imatrix & operator =(const int);
-   imatrix(const imatrix &);
-   // copy initializer
-   imatrix(const imatrix_position &);
-   imatrix(void);
+    imatrix& operator=(const imatrix& t);
+    imatrix& operator = (const int);
+    imatrix(const imatrix&);
+             // copy initializer
+    imatrix(const imatrix_position&);
+    imatrix(void);
 
    ~imatrix();
-   void shallow_copy(const imatrix &);
+    void shallow_copy(const imatrix&);
 
-   void save_imatrix_value(void);
-   void save_imatrix_position(void);
-   imatrix restore_imatrix_value(const imatrix_position & mpos);
-   imatrix_position restore_imatrix_position(void);
+    void save_imatrix_value(void);
+    void save_imatrix_position(void);
+    imatrix restore_imatrix_value(const imatrix_position& mpos);
+    imatrix_position restore_imatrix_position(void);
 
-   void allocate(void);
-   void allocate(const imatrix & dm);
-   void allocate(int nrl, int nrh, int ncl, int nch);
-   void allocate(int nrl, int nrh);
-   void allocate(int nrl, int nrh, int ncl, const ivector & nch);
-   void allocate(int nrl, int nrh, const ivector & ncl,
-		 const ivector & nch);
-   void allocate(const ad_integer & nrl, const ad_integer & nrh,
-		 const index_type & ncl, const index_type & nch);
-   void deallocate();
+    void allocate(void);
+    void allocate(const imatrix& dm);
+    void allocate(int nrl,int nrh,int ncl,int nch);
+    void allocate(int nrl,int nrh);
+    void allocate(int nrl,int nrh,int ncl,const ivector& nch);
+    void allocate(int nrl,int nrh,const ivector& ncl,const ivector& nch);
+    void allocate(const ad_integer& nrl,const ad_integer& nrh,
+      const index_type& ncl,const index_type& nch);
+    void deallocate();
 
 #ifdef OPT_LIB
-   inline ivector & operator() (int i)
-   {
-      return m[i];
-   }
-   inline int &operator() (int i, int j)
-   {
-      return (*((*(m + i)).v + j));
-   }
-   inline ivector & operator[] (int i)
-   {
-      return m[i];
-   }
+ inline ivector& operator() (int i) {return m[i];}
+ inline int& operator() (int i,int j) {return(*((*(m+i)).v+j));}
+ inline ivector& operator[] (int i) {return m[i];}
 #else
-   ivector & operator [] (int);
-   ivector & operator () (int);
-   int &operator () (int, int);
+  ivector& operator [] (int);
+  ivector& operator () (int);
+  int& operator () (int,int);
 #endif
 
 #ifdef USE_CONST
-#ifdef OPT_LIB
-   inline const ivector & operator() (int i) const
-   {
-      return m[i];
-   }
-   inline const int &operator() (int i, int j) const
-   {
-      return (*((*(m + i)).v + j));
-   }
-   inline const ivector & operator[] (int i) const
-   {
-      return m[i];
-   }
-#else
-   const ivector & operator[] (int) const;
-   const ivector & operator() (int) const;
-   const int &operator() (int, int) const;
+ #ifdef OPT_LIB
+  inline const ivector& operator()(int i) const { return m[i]; }
+  inline const int& operator()(int i, int j) const
+    {return(*((*(m+i)).v+j));}
+  inline const ivector& operator[](int i) const { return m[i]; }
+ #else
+    const ivector& operator[](int) const;
+    const ivector& operator()(int) const;
+    const int& operator()(int, int) const;
 #endif
 #endif
-   int indexmin(void) const
-   {
-      return index_min;
-   }
-   int indexmax(void) const
-   {
-      return index_max;
-   }
-   int rowmin(void) const
-   {
-      return index_min;
-   }
-   int rowmax(void) const
-   {
-      return index_max;
-   }
-   int colmin(void) const
-   {
-      return ((*this) (indexmin()).indexmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (indexmin()).indexmax());
-   }
-   int rowsize() const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-   void rowshift(int min);
+    int indexmin(void) const { return index_min; }
+    int indexmax(void) const { return index_max; }
+    int rowmin(void) const { return index_min; }
+    int rowmax(void) const { return index_max; }
+    int colmin(void) const { return((*this)(indexmin()).indexmin()); }
+    int colmax(void) const { return((*this)(indexmin()).indexmax()); }
+    int rowsize() const { return (rowmax() - rowmin() + 1); } // returns the number of rows
+    int colsize() const { return (colmax() - colmin() + 1); } // returns the number of columns
+    void rowshift(int min);
 
-   void write_on(const ostream &) const;
-   void write_on(const uostream &) const;
-   void read_from(const istream &);
-   void read_from(const uistream &);
-   void initialize(void);
-   friend class i3_array;
-   void fill_seqadd(int, int);
-};				//end of class imatrix
+    void write_on(const ostream&) const;
+    void write_on(const uostream&) const;
+    void read_from(const istream&);
+    void read_from(const uistream&);
+    void initialize(void);
+    friend class i3_array;
+    void fill_seqadd(int,int);
+}; //end of class imatrix
+dvariable regression(const dvector& obs,const dvar_vector& pred);
+double regression(const dvector& obs,const dvector& pred);
 
-dvariable regression(const dvector & obs, const dvar_vector & pred);
-double regression(const dvector & obs, const dvector & pred);
+dvariable robust_regression_fixed(const dvector& obs,const dvar_vector& pred,
+  double a=0.7);
+dvariable robust_regression(const dvector& obs,const dvar_vector& pred,
+  double a=0.7);
 
-dvariable robust_regression_fixed(const dvector & obs,
-				  const dvar_vector & pred, double a =
-				  0.7);
-dvariable robust_regression(const dvector & obs, const dvar_vector & pred,
-			    double a = 0.7);
+dvariable robust_regression(const dvector& obs,const dvar_vector& pred,const dvariable& cutoff);
 
-dvariable robust_regression(const dvector & obs, const dvar_vector & pred,
-			    const dvariable & cutoff);
+ dmatrix column_vector(const dvector&);
+ dmatrix row_vector(const dvector&);
 
-dmatrix column_vector(const dvector &);
-dmatrix row_vector(const dvector &);
+ dvar_matrix column_vector(const dvar_vector&);
+ dvar_matrix row_vector(const dvar_vector&);
 
-dvar_matrix column_vector(const dvar_vector &);
-dvar_matrix row_vector(const dvar_vector &);
+ dmatrix identity_matrix(int min,int max); 
 
-dmatrix identity_matrix(int min, int max);
+istream& operator >> (const istream& s,const ptr_vector& v);
+ostream& operator << (const ostream& s,const ptr_vector& v);
 
-istream & operator>>(const istream & s, const ptr_vector & v);
-ostream & operator<<(const ostream & s, const ptr_vector & v);
-
 /**
  * Description not yet available.
  * \param
  */
 class fmm_control
 {
- public:
-   int noprintx;
-   long maxfn;
-   long iprint;
-   double crit;
-   double fringe;
-   long imax;
-   double dfn;
-   long ifn;
-   long iexit;
-   long ialph;
-   long ihflag;
-   long ihang;
-   long scroll_flag;
-   int maxfn_flag;
-   int quit_flag;
-   double min_improve;
-   int ireturn;
-   int dcheck_flag;
-   int use_control_c;
+public:
+  int noprintx;
+  long   maxfn;
+  long   iprint;
+  double crit;
+  double fringe;
+  long   imax;
+  double dfn;
+  long   ifn;
+  long   iexit;
+  long   ialph;
+  long   ihflag;
+  long   ihang;
+  long   scroll_flag;
+  int maxfn_flag;
+  int quit_flag;
+  double min_improve;
+  int    ireturn;
+  int  dcheck_flag;
+  int use_control_c;
 
-   void set_defaults();
-   fmm_control();
-   fmm_control(const fmm_control &);
-   fmm_control(const lvector & ipar);
-   void writeon(const ostream & s) const;
+  void set_defaults();
+  fmm_control();
+  fmm_control(const fmm_control& );
+  fmm_control(const lvector& ipar);
+  void writeon(const ostream& s) const;
 };
 
 /**
  * Description not yet available.
  * \param
  */
-class sdmatrix:public dmatrix
+class sdmatrix: public dmatrix
 {
- public:
-   void allocate(int);
-   void allocate();
-   sdmatrix(int);
-   sdmatrix();
+  public:
+    void allocate(int);
+    void allocate();
+    sdmatrix(int);
+    sdmatrix();
    ~sdmatrix();
-   void deallocate();
+    void deallocate();
 };
 
 class dfsdmat;
 
-uistream & operator>>(const uistream &, const dfsdmat &);
-uostream & operator<<(const uostream &, const dfsdmat &);
+uistream& operator >> (const uistream&,const dfsdmat&);
+uostream& operator << (const uostream&,const dfsdmat&);
 
 /**
  * Description not yet available.
@@ -4149,99 +3733,82 @@
  */
 class dfsdmat
 {
-   int tmp_file;
-   int disk_save_flag;
-   double *ptr;
-   double **m;
-   double *minp;
-   double *maxp;
-   int shared_memory;
-   int n;
- public:
-   int disk_save(void)
-   {
-      return disk_save_flag;
-   }
-   void save(void);
-   void restore(void);
-   double *getminp(void)
-   {
-      return minp;
-   }
-   int operator!(void) const
-   {
-      return (ptr == NULL);
-   }
-   int size(void)
-   {
-      return n;
-   }
-   dfsdmat(int n);
-   dfsdmat();
-   dfsdmat(int n, const gradient_structure & gs);
-   void allocate(int n);
-   void allocate(int n, const gradient_structure & gs);
-   void allocate(void);
-   ~dfsdmat();
-   void deallocate(void);
-   friend uistream & operator>>(const uistream &, const dfsdmat &);
-   friend uostream & operator<<(const uostream &, const dfsdmat &);
+  int tmp_file;
+  int disk_save_flag;
+  double * ptr;
+  double ** m;
+  double* minp;
+  double* maxp;
+  int shared_memory;
+  int n;
+public:
+  int disk_save(void) {return disk_save_flag;}
+  void save(void);
+  void restore(void);
+  double * getminp(void){ return minp;}
+  int operator ! (void) const {return (ptr == NULL);}
+  int size(void) {return n;} 
+  dfsdmat(int n);
+  dfsdmat();
+  dfsdmat(int n,const gradient_structure& gs);
+  void allocate(int n);
+  void allocate(int n,const gradient_structure& gs);
+  void allocate(void);
+  ~dfsdmat();
+  void deallocate(void);
+  friend uistream& operator >> (const uistream&,const dfsdmat&);
+  friend uostream& operator << (const uostream&,const dfsdmat&);
 
-#if defined(OPT_LIB) && !defined(__INTEL_COMPILER)
-   double &elem(int i, int j)
-   {
-      return *(m[i] + j);
-   }
-   double &operator () (int i, int j)
-   {
-      return *(m[i] + j);
-   }
-#else
-   double &elem(int i, int j);
-   double &operator () (int i, int j);
-#endif
+  #if defined(OPT_LIB) && !defined(__INTEL_COMPILER) 
+    double& elem(int i,int j){ return *(m[i]+j);}
+    double& operator () (int i,int j){ return *(m[i]+j);}
+  #else
+    double& elem(int i,int j);
+    double& operator () (int i,int j);
+  #endif
 };
 
 /**
  * Description not yet available.
  * \param
  */
-class fmm:public fmm_control
+class fmm : public fmm_control
 {
- private:
-   dfsdmat h;
-   dvector w;
-   dvector funval;
- public:
-   double dmin, fbest, df;
+private:
+  dfsdmat h;
+  dvector w;
+  dvector funval;
+public:
+  double dmin,fbest,df;
 
-   long int llog, n1, ic, iconv, i1, xxlink;
-   double z, zz, gys, gs, sig, gso, alpha, tot, fy, dgs;
-   long int itn, icc, np, nn, is, iu, iv, ib;
-   int i, j;
-   double gmax;
-   double fsave;
-   dvector xx;
-   dvector gbest;
-   dvector xsave;
-   dvector gsave;
+  long int llog,n1,ic,iconv,i1,xxlink;
+  double z,zz,gys,gs,sig,gso,alpha,tot,fy,dgs;
+  long int itn,icc,np,nn,is,iu,iv,ib;
+  int i, j;
+  double gmax;
+  double fsave;
+  dvector xx;
+  dvector gbest;
+  dvector xsave;
+  dvector gsave;
 
-   int n;
-   int disk_save;
+  int n;
+  int disk_save;
 
- public:
-   fmm(int nvar, int disk_save = 0);
-   fmm(int nvar, const lvector & ipar, int disk_save = 0);
-   double minimize(const independent_variables & x,
-		   double (*pf) (const dvar_vector &));
+public:
+  void allocate(int nvar,int disk_save=0);
+  fmm(int nvar,int disk_save=0);
+  fmm(void);
+  fmm(int nvar,const lvector& ipar,int disk_save=0);
+  double minimize(const independent_variables & x,double (*pf)(const dvar_vector&));
 
-   double minimize(const independent_variables & x, const dvector & c,
-		   double (*pf) (const dvar_vector &, const dvector &));
+  double minimize(const independent_variables & x,const dvector& c,
+        double (*pf)(const dvar_vector&,const dvector&) );
 
-   //void fmin(const double& f, const independent_variables &x, const dvector& g);
-   void fmin(const double &f, const dvector & x, const dvector & g);
+  //void fmin(const double& f, const independent_variables & x,const dvector& g);
+  void fmin(const double& f, const dvector& x,const dvector& g);
 
-   dmatrix & hessian();
+  dmatrix& hessian();
 };
 
 class function_minimizer;
@@ -4250,162 +3817,156 @@
  * Description not yet available.
  * \param
  */
-class fmmt1:public fmm_control
+
+class fmmt1 : public fmm_control
 {
- private:
-   dvector w;
-   dvector funval;
-   int xm;
-   dmatrix xstep;
-   dvector xrho;
-   dvector rrr;
-   dmatrix xy;
-   dvector xold;
-   dvector gold;
- public:
-   double dmin, fbest, df;
+private:
+  dvector w;
+  dvector funval;
+  int xm;
+  dmatrix xstep;
+  dvector xrho;
+  dvector rrr;
+  dmatrix xy; 
+  dvector xold; 
+  dvector gold; 
+public:
+  double dmin,fbest,df;
 
-   long int llog, n1, ic, iconv, i1, link;
-   double z, zz, gys, gs, sig, gso, alpha, tot, fy, dgs;
-   long int itn, icc, np, nn, is, iu, iv, ib;
-   int i, j;
-   double gmax;
-   double fsave;
-   dvector xx;
-   dvector gbest;
-   dvector xsave;
-   dvector gsave;
+  long int llog,n1,ic,iconv,i1,link;
+  double z,zz,gys,gs,sig,gso,alpha,tot,fy,dgs;
+  long int itn,icc,np,nn,is,iu,iv,ib;
+  int i, j;
+  double gmax;
+  double fsave;
+  dvector xx;
+  dvector gbest;
+  dvector xsave;
+  dvector gsave;
 
-   int n;
+  int n;
 
- public:
-   fmmt1(int nvar, int _xm = 7);
-   fmmt1(int nvar, const lvector & ipar);
-   double minimize(const independent_variables & x,
-		   double (*pf) (const dvar_vector &));
+public:
+  fmmt1(void);
+  fmmt1(int nvar,int _xm=7);
+  void allocate(int nvar,int _xm=7);
+  fmmt1(int nvar,const lvector& ipar);
+  double minimize(const independent_variables & x,double (*pf)(const dvar_vector&));
 
-   double minimize(const independent_variables & x, const dvector & c,
-		   double (*pf) (const dvar_vector &, const dvector &));
+  double minimize(const independent_variables & x,const dvector& c,
+        double (*pf)(const dvar_vector&,const dvector&) );
 
-   void fmin2(const double &f, const independent_variables & x,
-	      const dvector & g, function_minimizer *);
+  void fmin2(const double& f, const independent_variables & x,const dvector& g, function_minimizer *);
 
-   void fmin(const double &f, const dvector & x, const dvector & g);
+  void fmin(const double& f, const dvector & x,const dvector& g);
 
 //  dmatrix& hessian();
 };
 
+void derch(const double& f, const independent_variables & x,const dvector& g,
+     int n, const int & ireturn);
 
-void derch(const double &f, const independent_variables & x,
-	   const dvector & g, int n, const int &ireturn);
+void fmin( double f, const independent_variables & x,const dvector& g,
+            const int& n,const dvector& w,const dvector& h, const fmm_control & fmc);
 
-void fmin(double f, const independent_variables & x, const dvector & g,
-	  const int &n, const dvector & w, const dvector & h,
-	  const fmm_control & fmc);
+void fmmdisp(const dvector& x,const dvector& g, const int& nvar,
+             int scroll_flag,int noprintx=0);
 
-void fmmdisp(const dvector & x, const dvector & g, const int &nvar,
-	     int scroll_flag, int noprintx = 0);
+void fmmdisp(const double * x,const double * g, const int& nvar,
+             int scroll_flag,int noprintx=0);
 
-void fmmdisp(const double *x, const double *g, const int &nvar,
-	     int scroll_flag, int noprintx = 0);
+ostream& operator<<(const ostream& s, const fmm_control& fmc);
 
-ostream & operator<<(const ostream & s, const fmm_control & fmc);
-
 // !!!! #ifndef __GNU__
 
 /**
  * Description not yet available.
  * \param
  */
-class uostream:public ofstream
+class uostream : public ofstream
 {
- public:
-#if defined(__TURBOC__) && (__BORLANDC__  <= 0x0520)
-   uostream(const char *, int = ios::out | ios::binary,
-	    int = filebuf::openprot);
-   void open(const char *, int = ios::out | ios::binary,
-	     int = filebuf::openprot);
+public:
+#if defined(__TURBOC__) && (__BORLANDC__  <= 0x0520) 
+  uostream(const char*, int = ios::out | ios::binary,
+                       int = filebuf::openprot);
+  void open(const char*, int = ios::out | ios::binary,
+                    int = filebuf::openprot);
 #endif
-#if (__BORLANDC__  >= 0x0540)
-   uostream(const char *, int = ios::out | ios::binary,
-	    int protection = 666);
-   void open(const char *, int = ios::out | ios::binary,
-	     int protection = 666);
+#if (__BORLANDC__  >= 0x0540) 
+  uostream(const char*, int = ios::out | ios::binary,
+                       int protection= 666);
+  void open(const char*, int = ios::out | ios::binary,
+                    int protection=666);
 #endif
-#if defined (__MSVC32__) || defined (__WAT32__)
+#if defined (__MSVC32__) || defined (__WAT32__) 
 #  if (__MSVC32__ <7)
-   uostream(const char *, int = ios::out | ios::binary,
-	    int = filebuf::openprot);
-   void open(const char *, int = ios::out | ios::binary,
-	     int = filebuf::openprot);
+  uostream(const char*, int = ios::out | ios::binary,
+                       int = filebuf::openprot);
+  void open(const char*, int = ios::out | ios::binary,
+                    int = filebuf::openprot);
 #  else
-   uostream(const char *, int = ios::out | ios::binary, int prot = 0664);
-   void open(const char *, int = ios::out | ios::binary, int prot = 0664);
+  uostream(const char*, int = ios::out | ios::binary,
+                       int prot=0664);
+  void open(const char*, int = ios::out | ios::binary,
+                    int prot=0664);
 #  endif
 #endif
 
 #ifdef __ZTC__
-   uostream(const char *, int = ios::out, int = filebuf::openprot);
-   void open(const char *, int = ios::out, int = filebuf::openprot);
+  uostream(const char*, int = ios::out, int = filebuf::openprot);
+  void open(const char*, int = ios::out, int = filebuf::openprot);
 #endif
 
 #ifdef __NDPX__
-   uostream(const char *, int = ios::out, int = filebuf::openprot);
-   void open(const char *, int = ios::out, int = filebuf::openprot);
+  uostream(const char*, int = ios::out, int = filebuf::openprot);
+  void open(const char*, int = ios::out, int = filebuf::openprot);
 #endif
 
 #ifdef __SUN__
-   //uostream(const char*, int = ios::out, int = openprot);
-   //void open(const char*, int = ios::out, int = openprot);
+  //uostream(const char*, int = ios::out, int = openprot);
+  //void open(const char*, int = ios::out, int = openprot);
 #endif
 
-#if defined(__GNUDOS__)
+#if defined(__GNUDOS__) 
 #  if !defined(__ADSGI__)
-#    if (__GNUC__  < 3) && !defined(__SUNPRO_CC)
-   uostream(const char *name, int mode = ios::out | ios::bin, int prot =
-	    0664);
-   void open(const char *name, int mode = ios::out | ios::bin, int prot =
-	     0664);
-#    else
-   uostream(const char *name, int mode = ios::out | ios::binary, int prot =
-	    0664);
-   void open(const char *name, int mode =
-	     ios::out | ios::binary, int prot = 0664);
+#    if (__GNUC__  < 3) && !defined(__SUNPRO_CC) 
+  uostream(const char* name, int mode = ios::out | ios::bin,int prot=0664);
+  void open(const char* name, int mode = ios::out | ios::bin,int prot=0664);
+#    else  
+  uostream(const char* name, int mode = ios::out | ios::binary,int prot=0664);
+  void open(const char* name, int mode = ios::out | ios::binary,int prot=0664);
 #    endif
 #  else
-   uostream(const char *name, int mode = ios::out, int prot = 0664);
-   void open(const char *name, int mode = ios::out, int prot = 0664);
+  uostream(const char* name, int mode = ios::out,int prot=0664);
+  void open(const char* name, int mode = ios::out,int prot=0664);
 #  endif
 #endif
 
-   // insert character
+  // insert character
 #ifndef __SUN__
-   uostream & operator<<(signed char);
+  uostream&  operator<< (  signed char);
 #endif
-   uostream & operator<<(unsigned char);
+  uostream&  operator<< (unsigned char);
 
-   // insert numeric value
-   uostream & operator<<(short);
-   uostream & operator<<(unsigned short);
-   uostream & operator<<(int);
-   uostream & operator<<(unsigned int);
-   uostream & operator<<(long);
-   uostream & operator<<(unsigned long);
-   uostream & operator<<(float);
-   uostream & operator<<(double);
-   uostream & operator<<(const char *)
-   {
-      return *this;
-   };
+  // insert numeric value
+  uostream&  operator<< (short);
+  uostream&  operator<< (unsigned short);
+  uostream&  operator<< (int);
+  uostream&  operator<< (unsigned int);
+  uostream&  operator<< (long);
+  uostream&  operator<< (unsigned long);
+  uostream&  operator<< (float);
+  uostream&  operator<< (double);
+  uostream&  operator<< (const char *){return *this;};
 #ifdef __TURBOC__
-   uostream & operator<<(long double);
+  uostream&  operator<< (long double);
 #endif
 
 
-   // insert pointer
-   uostream & operator<<(void *);
+  // insert pointer
+  uostream&  operator<< (void*);
 
-   virtual void sss(void);
+virtual void sss(void);
 };
 
 
@@ -4451,107 +4012,105 @@
  * Description not yet available.
  * \param
  */
-class uistream:public ifstream
+class uistream :  public ifstream
 {
- public:
-#if defined (__TURBOC__) &&   (__BORLANDC__  <= 0x0520)
-   uistream(const char *, int = ios::in | ios::binary,
-	    int = filebuf::openprot);
-   void open(const char *, int = ios::in | ios::binary,
-	     int = filebuf::openprot);
+public:
+#if defined (__TURBOC__) &&   (__BORLANDC__  <= 0x0520) 
+  uistream(const char*, int = ios::in | ios::binary,
+                       int = filebuf::openprot);
+  void   open(const char*, int = ios::in | ios::binary,
+                    int = filebuf::openprot);
 #endif
-#if (__BORLANDC__  >= 0x0540)
-   uistream(const char *, int = ios::in | ios::binary,
-	    int protection = 666);
-   void open(const char *, int = ios::in | ios::binary,
-	     int protection = 666);
+#if (__BORLANDC__  >= 0x0540) 
+  uistream(const char*, int = ios::in | ios::binary,
+                       int protection= 666);
+  void   open(const char*, int = ios::in | ios::binary,
+                       int protection= 666);
 #endif
 #if defined (__MSVC32__) || defined (__WAT32__)
 #if (__MSVC32__ <7)
-   uistream(const char *, int = ios::in | ios::binary,
-	    int = filebuf::openprot);
-   void open(const char *, int = ios::in | ios::binary,
-	     int = filebuf::openprot);
+  uistream(const char*, int = ios::in | ios::binary,
+                       int = filebuf::openprot);
+  void   open(const char*, int = ios::in | ios::binary,
+                    int = filebuf::openprot);
 #else
-   uistream(const char *, int = ios::in | ios::binary, int prot = 0664);
-   void open(const char *, int = ios::in | ios::binary, int prot = 0664);
+  uistream(const char*, int = ios::in | ios::binary,
+                       int prot=0664);
+  void   open(const char*, int = ios::in | ios::binary,
+                    int prot=0664);
 #endif
 #endif
 #ifdef __ZTC__
-   uistream(const char *, int = ios::in, int = filebuf::openprot);
-   void open(const char *, int = ios::in, int = filebuf::openprot);
+  uistream(const char*, int = ios::in, int = filebuf::openprot);
+  void open(const char*, int = ios::in, int = filebuf::openprot);
 #endif
 
 #ifdef __NDPX__
-   uistream(const char *, int = ios::in, int = filebuf::openprot);
-   void open(const char *, int = ios::in, int = filebuf::openprot);
+  uistream(const char*, int = ios::in, int = filebuf::openprot);
+  void open(const char*, int = ios::in, int = filebuf::openprot);
 #endif
 
 #ifdef __SUN__
-   // uistream(const char* name, int mode = ios::in, int prot=0664);
-   // void open(const char* name, int mode = ios::in, int prot=0664);
+ // uistream(const char* name, int mode = ios::in, int prot=0664);
+ // void open(const char* name, int mode = ios::in, int prot=0664);
 #endif
 
 
-#if defined(__GNUDOS__)
+#if defined(__GNUDOS__) 
 #  if !defined(__ADSGI__)
-#    if (__GNUC__  < 3) && !defined(__SUNPRO_CC)
-   uistream(const char *name, int mode = ios::in | ios::bin, int prot =
-	    0664);
-   void open(const char *name, int mode = ios::in | ios::bin, int prot =
-	     0664);
-#    else
-   uistream(const char *name, int mode = ios::in | ios::binary, int prot =
-	    0664);
-   void open(const char *name, int mode = ios::in | ios::binary, int prot =
-	     0664);
+#    if (__GNUC__  < 3) && !defined(__SUNPRO_CC) 
+       uistream(const char* name, int mode = ios::in | ios::bin, int prot=0664);
+       void open(const char* name, int mode = ios::in | ios::bin, int prot=0664);
+#    else  
+       uistream(const char* name, int mode = ios::in | ios::binary, int prot=0664);
+       void open(const char* name, int mode = ios::in | ios::binary, int prot=0664);
 #    endif
 #  else
-   uistream(const char *name, int mode = ios::in, int prot = 0664);
-   void open(const char *name, int mode = ios::in, int prot = 0664);
+  uistream(const char* name, int mode = ios::in, int prot=0664);
+  void open(const char* name, int mode = ios::in, int prot=0664);
 #  endif
 #endif
 
-   // extract characters into an array
+  // extract characters into an array
 #ifndef __SUN__
-   uistream & get(signed char *, int, char = '\n');
+  uistream&  get(  signed char*, int, char = '\n');
 #endif
-   uistream & get(unsigned char *, int, char = '\n');
+  uistream&  get(unsigned char*, int, char = '\n');
 
-   // extract a single character
-   uistream & get(unsigned char &);
+  // extract a single character
+  uistream&  get(unsigned char&);
 #ifndef __SUN__
-   uistream & get(signed char &);
+  uistream&  get(  signed char&);
 #endif
-   int get();
+  int        get();
 
 
-   // extract and discard chars but stop at delim
-   uistream & ignore(int = 1, int = EOF);
+  // extract and discard chars but stop at delim
+  uistream&  ignore(int = 1, int = EOF);
 
 #ifndef __SUN__
-   uistream & operator>>(const signed char *);
+  uistream&  operator>> (const signed char*);
 #endif
-   uistream & operator>>(const unsigned char *);
-   uistream & operator>>(const unsigned char &);
+  uistream&  operator>> (const unsigned char*);
+  uistream&  operator>> (const unsigned char&);
 #ifndef __SUN__
-   uistream & operator>>(const signed char &);
+  uistream&  operator>> (const signed char&);
 #endif
-   uistream & operator>>(const short &);
-   uistream & operator>>(const int &);
-   uistream & operator>>(const long &);
-   uistream & operator>>(const unsigned short &);
-   uistream & operator>>(const unsigned int &);
-   uistream & operator>>(const unsigned long &);
-   uistream & operator>>(const float &);
-   uistream & operator>>(const double &);
-   uistream & operator>>(const char &);
-#if defined(__TURBOC__) || defined (__MSVC32__)
-   uistream & operator>>(const long double &);
+  uistream&  operator>> (const short&);
+  uistream&  operator>> (const int&);
+  uistream&  operator>> (const long&);
+  uistream&  operator>> (const unsigned short&);
+  uistream&  operator>> (const unsigned int&);
+  uistream&  operator>> (const unsigned long&);
+  uistream&  operator>> (const float&);
+  uistream&  operator>> (const double&);
+  uistream&  operator>> (const char&);
+#if defined(__TURBOC__) || defined (__MSVC32__)  
+  uistream&  operator>> (const long double&);
 #endif
-   virtual void sss(void);
+virtual void sss(void);
 };
-
+  
   // inline void   uistream::open(const char* name, int m, int prot)
   // {
   // #if defined(__TURBOC__) && (__BORLANDC__  <= 0x0520) 
@@ -4572,8 +4131,7 @@
 class fmmc;
 
 
-void derch(const double &f, const dvector & x, const dvector & gg, int n,
-	   const int &ireturn);
+void derch(const double& f,const dvector& x,const dvector& gg,int n, const int & ireturn);
 
 /**
  * Description not yet available.
@@ -4581,802 +4139,658 @@
  */
 class fmmc
 {
- public:
-   int maxfn;
-   double crit;
-   double min_improve;
-   int iprint;
-   int scroll_flag;
-   int j;
-   int J;
-   long int ifn;
-   long int iter;
-   int imax;
-   int ihang;
-   int quit_flag;
-   dvector *funval;
-   dvector *left_bracket_gradient;
-   dvector *right_bracket_gradient;
-   dvector *g;
-   dvector *h;
-   dvector *xi;
-   dvector *d;
-   dvector *extx;
-   dvector *g2;
-   dvector *grad;
-   dvector *extg;
-   dvector *theta;
-   dvector *xbest;
-   dvector *gbest;
-   int lin_flag;
-   int ext_flag;
-   int int_flag;
-   int ifnex;
-   int ireturn;
-   int frp_flag;
-   double gg;
-   double gam;
-   double fp;
-   double dgg;
-   double rho_min;
-   double converge_flag;
-   double gamma;
-   double Psi_0;
-   double extf;
-   double crit1;
-   double rho_1;
-   double Psi_1;
-   double dir_deriv;
-   double rho_i;
-   double left_bracket;
-   double left_bracket_value;
-   double right_bracket;
-   double right_bracket_value;
-   double rho_0;
-   double fbest;
-   fmmc(const int &n);
-   ~fmmc();
-   void fmin(const double &f, const dvector & p, const dvector & gg);
-   double dfn;
-   int maxfn_flag;
-   int iexit;
-   int ihflag;
+public:
+  int maxfn;
+  double crit;
+  double min_improve;
+  int iprint;
+  int scroll_flag;
+  int j;
+  int J;
+  long int ifn;
+  long int iter;
+  int imax;
+  int ihang;
+  int quit_flag;
+  dvector * funval;
+  dvector * left_bracket_gradient;
+  dvector * right_bracket_gradient;
+  dvector * g;
+  dvector * h;
+  dvector * xi;
+  dvector * d;
+  dvector * extx;
+  dvector * g2;
+  dvector * grad;
+  dvector * extg;
+  dvector * theta;
+  dvector * xbest;
+  dvector * gbest;
+  int lin_flag;
+  int ext_flag;
+  int int_flag;
+  int ifnex;
+  int ireturn;
+  int frp_flag;
+  double gg;
+  double gam;
+  double fp;
+  double dgg;
+  double rho_min;
+  double converge_flag;
+  double gamma;
+  double Psi_0;
+  double extf;
+  double crit1;
+  double rho_1;
+  double Psi_1;
+  double dir_deriv;
+  double rho_i;
+  double left_bracket;
+  double left_bracket_value;
+  double right_bracket;
+  double right_bracket_value;
+  double rho_0;
+  double fbest;
+  fmmc(const int& n);
+  ~fmmc();
+   void fmin(const double& f,const dvector& p,const dvector& gg);
+  double dfn;
+  int maxfn_flag;
+  int iexit;
+  int ihflag;
 };
 
-class dd3_array;
+    class dd3_array;
 
 /**
  * Description not yet available.
  * \param
  */
-class three_array_shape
-{
-   //unsigned int nslices;
-   unsigned int ncopies;
-   //unsigned int nrows;
-   //unsigned int ncols;
-   int slice_min;
-   int slice_max;
-   // int row_min;
-   // int row_max;
-   //int col_min;
-   //int col_max;
-   three_array_shape(int sl, int sh);
-   //mat_shape(){};
+  class three_array_shape
+  {
+    //unsigned int nslices;
+    unsigned int ncopies;
+    //unsigned int nrows;
+    //unsigned int ncols;
+     int slice_min;
+     int slice_max;
+    // int row_min;
+    // int row_max;
+     //int col_min;
+     //int col_max;
+    three_array_shape(int sl,int sh);
+    //mat_shape(){};
 
-   friend class i3_array;
-   friend class d3_array;
-   friend class dd3_array;
-   friend class qd3_array;
-   friend class dvar3_array;
+    friend class i3_array;
+    friend class d3_array;
+    friend class dd3_array;
+    friend class qd3_array;
+    friend class dvar3_array;
 
-};				// End of class three_array_shape
+  }; // End of class three_array_shape
 
 /**
  * Description not yet available.
  * \param
  */
-class dmatrix_ptr
-{
-   dmatrix *p;
-};
+   class dmatrix_ptr
+   {
+     dmatrix * p;
+   };
 
 /**
  * Description not yet available.
  * \param
  */
-class dvar_matrix_ptr
-{
-   dvar_matrix *p;
-};
+   class dvar_matrix_ptr
+   {
+     dvar_matrix * p;
+   };
 
-
 /**
  * Description not yet available.
  * \param
  */
-class d3_array
-{
-   dmatrix *t;
-   three_array_shape *shape;
-   friend class d4_array;
- public:
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   // conclass cgors
-   d3_array(void);
-   void save_d3_array_value(void) const;
-   void shallow_copy(const d3_array &);
-   d3_array sub(int, int);
-   d3_array(int sl, int sh, int nrl, int nrh, int ncl, int nch);
-   d3_array(int sl, int sh, int nrl, int nrh);
-   d3_array(int sl, int sh, const index_type & nrl,
-	    const index_type & nrh);
-   d3_array(int sl, int sh);
-   d3_array(const d3_array_position &);
 
-   void save_d3_array_position(void) const;
+  class d3_array
+  {
+    dmatrix * t;
+    three_array_shape * shape;
+    friend class d4_array;
+  public:
+    int operator!(void) const { return (shape == NULL); }
+    // conclass cgors
+    d3_array(void);
+    void save_d3_array_value(void) const;
+    void shallow_copy(const d3_array&);
+    d3_array sub(int,int);
+    d3_array(int sl,int sh,int nrl,int nrh,int ncl,int nch);
+    d3_array(int sl,int sh,int nrl,int nrh);
+    d3_array(int sl,int sh,const index_type& nrl,const index_type& nrh);
+    d3_array(int sl,int sh);
+    d3_array(const d3_array_position&);
 
-   d3_array(int sl, int sh, int nrl, int nrh, const ivector & ncl,
-	    int nch);
+    void save_d3_array_position(void) const;
 
-   d3_array(const ad_integer & sl, const ad_integer & sh,
-	    const index_type & nrl, const index_type & nrh,
-	    const index_type & ncl, const index_type & nch);
+    d3_array(int sl, int sh, int nrl, int nrh, const ivector& ncl, int nch);
 
-   void allocate(const ad_integer & sl, const ad_integer & sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch);
+    d3_array(const ad_integer& sl, const ad_integer& sh,
+             const index_type& nrl, const index_type& nrh,
+             const index_type& ncl, const index_type& nch);
 
-   d3_array(int sl, int sh, const ivector & nrl, const ivector & nrh,
-	    const imatrix & ncl, const imatrix & nch);
-   d3_array(int sl, int sh, const ivector & nrl, const ivector & nrh,
-	    int ncl, const imatrix & nch);
-   d3_array(int sl, int sh, int nrl, const ivector & nrh,
-	    int ncl, const imatrix & nch);
-   d3_array(int sl, int sh, const ivector & nrl, const ivector & nrh,
-	    const ivector & ncl, const ivector & nch);
-   d3_array(int sl, int sh, int nrl, int nrh, const ivector & ncl,
-	    const ivector & nch);
-   d3_array(int sl, int sh, int nrl, const ivector & nrh,
-	    int ncl, const ivector & nch);
-   d3_array(int sl, int sh, int nrl, const ivector & nrh,
-	    int ncl, int nch);
-   d3_array(const d3_array & m2);
-   ~d3_array();
+    void allocate(const ad_integer& sl, const ad_integer& sh,
+                  const index_type& nrl, const index_type& nrh,
+                  const index_type& ncl, const index_type& nch);
 
-   void allocate(const dvar3_array &);
-   void allocate(const d3_array & d3v);
-   void allocate(int sl, int sh, int nrl, int nrh, int ncl, int nch);
-   void allocate(int sl, int sh, int nrl, int nrh);
-   void allocate(int sl, int sh, const index_type & nrl,
-		 const index_type & nrh);
-   void allocate(int sl, int sh);
+    d3_array(int sl, int sh, const ivector& nrl, const ivector& nrh,
+             const imatrix& ncl, const imatrix& nch);
+    d3_array(int sl, int sh, const ivector& nrl, const ivector& nrh,
+             int ncl, const imatrix& nch);
+    d3_array(int sl, int sh, int nrl, const ivector& nrh,
+             int ncl, const imatrix& nch);
+    d3_array(int sl, int sh, const ivector& nrl, const ivector& nrh,
+             const ivector& ncl, const ivector& nch);
+    d3_array(int sl, int sh, int nrl, int nrh, const ivector& ncl,
+             const ivector& nch);
+    d3_array(int sl, int sh, int nrl, const ivector& nrh,
+             int ncl, const ivector& nch);
+    d3_array(int sl, int sh, int nrl, const ivector& nrh,
+             int ncl, int nch);
+    d3_array(const d3_array& m2);
+    ~d3_array();
 
-   void allocate(int sl, int sh, int nrl, int nrh, const ivector & ncl,
-		 int nch);
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 const imatrix & ncl, const imatrix & nch);
-   void allocate(int sl, int sh, int nrl, const ivector & nrh, int ncl,
-		 const imatrix & nch);
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 int ncl, const imatrix & nch);
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 int ncl, int nch);
-   void allocate(int sl, int sh, const ivector & nrl, int nrh, int ncl,
-		 int nch);
-   void allocate(int sl, int sh, int nrl, const ivector & nrh, int ncl,
-		 int nch);
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 const ivector & ncl, const ivector & nch);
-   void allocate(int sl, int sh, int nrl, const ivector & nrh, int ncl,
-		 const ivector & nch);
-   void allocate(int sl, int sh, int nrl, int nrh, const ivector & ncl,
-		 const ivector & nch);
-   void allocate(int sl, int sh, int nrl, int nrh, int ncl,
-		 const ivector & nch);
-   void allocate(void);
-   void deallocate(void);
-   void initialize(int sl, int sh, int nrl, const ivector & nrh,
-		   int ncl, const ivector & nch);
+    void allocate(const dvar3_array&);
+    void allocate(const d3_array& d3v);
+    void allocate(int sl,int sh,int nrl,int nrh,int ncl,int nch);
+    void allocate(int sl,int sh,int nrl,int nrh);
+    void allocate(int sl,int sh,const index_type& nrl,const index_type& nrh);
+    void allocate(int sl,int sh);
 
-   //access functions
-   int indexmin(void) const
-   {
-      return shape->slice_min;
-   }
-   int indexmax(void) const
-   {
-      return shape->slice_max;
-   }
-   int slicemin(void) const
-   {
-      return shape->slice_min;
-   }
-   int slicemax(void) const
-   {
-      return shape->slice_max;
-   }
-   int colmin(void) const
-   {
-      return ((*this) (slicemin()).colmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (slicemin()).colmax());
-   }
-   int rowmin(void) const
-   {
-      return ((*this) (slicemin()).rowmin());
-   }
-   int rowmax(void) const
-   {
-      return ((*this) (slicemin()).rowmax());
-   }
+    void allocate(int sl, int sh, int nrl, int nrh, const ivector& ncl, int nch);
+   void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+                 const imatrix& ncl, const imatrix& nch);
+   void allocate(int sl, int sh, int nrl, const ivector& nrh,
+                 int ncl, const imatrix& nch);
+   void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+                 int ncl, const imatrix& nch);
+   void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+      int ncl,int nch);
+   void allocate(int sl, int sh, const ivector& nrl, int nrh,
+      int ncl,int nch);
+   void allocate(int sl, int sh, int nrl, const ivector& nrh,
+      int ncl,int nch);
+   void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+                 const ivector& ncl, const ivector& nch);
+   void allocate(int sl, int sh, int nrl, const ivector& nrh,
+                 int ncl, const ivector& nch);
+   void allocate(int sl, int sh, int nrl, int nrh,
+                 const ivector& ncl, const ivector& nch);
+    void allocate(int sl,int sh,int nrl,int nrh,
+      int ncl, const ivector& nch);
+    void allocate(void);
+    void deallocate(void);
+    void initialize(int sl, int sh, int nrl, const ivector& nrh,
+                    int ncl, const ivector& nch);
 
-   int slicesize(void) const
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize(void) const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize(void) const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-   void initialize(void);
+    //access functions
+    int indexmin(void) const { return shape->slice_min; }
+    int indexmax(void) const { return shape->slice_max; }
+    int slicemin(void) const { return shape->slice_min; }
+    int slicemax(void) const { return shape->slice_max; }
+    int colmin(void) const { return ((*this)(slicemin()).colmin()); }
+    int colmax(void) const { return ((*this)(slicemin()).colmax()); }
+    int rowmin(void) const { return ((*this)(slicemin()).rowmin()); }
+    int rowmax(void) const { return ((*this)(slicemin()).rowmax()); }
 
-   dmatrix & elem(int k)
-   {
-      return (t[k]);
-   }
+    int slicesize(void) const { return (slicemax() - slicemin() + 1); } // returns the number of rows
+    int rowsize(void) const { return (rowmax() - rowmin() + 1); } // returns the number of rows
+    int colsize(void) const { return (colmax() - colmin() + 1); } // returns the number of columns
+    void initialize(void);
+
+   dmatrix& elem(int k) { return(t[k]); }
 #ifdef USE_CONST
-   const dmatrix & elem(int k) const
-   {
-      return t[k];
-   }
+   const dmatrix& elem(int k) const { return t[k]; }
 #endif
 #ifdef OPT_LIB
-#ifdef USE_CONST
-   inline const double &operator() (int k, int i, int j) const
-   {
-      return (((t[k].m[i]).v)[j]);
-   }
+  #ifdef USE_CONST
+    inline const double& operator()(int k, int i, int j) const
+    {
+      return ( ((t[k].m[i]).v)[j] );
+    }
 
-   inline const dvector & operator() (int k, int i) const
-   {
-      return (t[k].m[i]);
-   }
+    inline const dvector& operator()(int k, int i) const
+    {
+      return ( t[k].m[i]);
+    }
 
-   inline const dmatrix & operator() (int i) const
-   {
-      return (t[i]);
-   }
+    inline const dmatrix& operator()(int i) const
+    {
+      return( t[i]);
+    }
 
-   inline const dmatrix & operator[] (int i) const
-   {
-      return (t[i]);
-   }
-#endif
+    inline const dmatrix& operator[](int i) const
+    {
+      return( t[i]);
+    }
+  #endif
 
-   inline double &operator () (int k, int i, int j)
-   {
-      return (((t[k].m[i]).v)[j]);
-   }
+    inline double& operator () (int k, int i, int j)
+    {
+      return ( ((t[k].m[i]).v)[j] );
+    }
 
-   inline dvector & operator () (int k, int i)
-   {
-      return (t[k].m[i]);
-   }
+    inline dvector& operator () (int k, int i)
+    {
+      return ( t[k].m[i]);
+    }
 
-   inline dmatrix & operator() (int i)
-   {
-      return (t[i]);
-   }
+    inline dmatrix& operator() (int i)
+    {
+      return( t[i]);
+    }
 
-   inline dmatrix & operator[] (int i)
-   {
-      return (t[i]);
-   }
+    inline dmatrix& operator[] (int i)
+    {
+      return( t[i]);
+    }
 #else
-   double &operator () (int k, int i, int j);
-   dvector & operator ()(int k, int i);
-   dmatrix & operator[](int i);
-   dmatrix & operator()(int i);
-#ifdef USE_CONST
-   const double &operator() (int k, int i, int j) const;
-   const dvector & operator() (int k, int i) const;
-   const dmatrix & operator[] (int i) const;
-   const dmatrix & operator() (int i) const;
+    double& operator () (int k, int i, int j);
+    dvector& operator () (int k, int i);
+    dmatrix& operator[] (int i);
+    dmatrix& operator() (int i);
+  #ifdef USE_CONST
+    const double& operator()(int k, int i, int j) const;
+    const dvector& operator()(int k, int i) const;
+    const dmatrix& operator[](int i) const; 
+    const dmatrix& operator()(int i) const;
+  #endif
 #endif
-#endif
 
-   d3_array & operator=(const d3_array & m1);
-   d3_array & operator=(double x);
-   friend d3_array value(const dvar3_array & ar);
+    d3_array& operator=(const d3_array& m1);
+    d3_array& operator= (double x);
+    friend d3_array value(const dvar3_array& ar);
 
-   void fill_randn(const random_number_generator & rng);
-   void fill_randcau(const random_number_generator & rng);
-   void fill_randu(const random_number_generator & rng);
+    void fill_randn(const random_number_generator& rng);
+    void fill_randcau(const random_number_generator& rng);
+    void fill_randu(const random_number_generator& rng);
 
-   void fill_randu(long int &n);
-   void fill_randn(long int &n);
+    void fill_randu(long int& n);
+    void fill_randn(long int& n);
 
-   void fill_randu_ni(long int &n);
-   void fill_randn_ni(long int &n);
-   double fill_seqadd(double, double);
-   void operator /=(double d);
+    void fill_randu_ni(long int& n);
+    void fill_randn_ni(long int& n);
+    double fill_seqadd(double,double);
+    void operator /= (double d);
 
-};				//end of class d3_array
+  }; //end of class d3_array
 
 /**
  * Description not yet available.
  * \param
  */
-class i3_array
-{
-   imatrix *t;
-   three_array_shape *shape;
- public:
+  class i3_array
+  {
+    imatrix * t;
+    three_array_shape * shape;
+  public:
 #  if defined(MFCL2_CONSTRUCTORS)
-   i3_array(int sl, int sh, int nrl, int nrh, const ivector & nc);
-   void allocate(int sl, int sh, int nrl, int nrh, const ivector & nc);
+    i3_array(int sl,int sh,int nrl,int nrh,const ivector& nc);
+    void allocate(int sl,int sh,int nrl,int nrh,const ivector& nc);
 #  endif
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   // conclass cgors
-   void shallow_copy(const i3_array &);
-   i3_array(void);
-   i3_array(int sl, int sh, const index_type & nrl, const index_type & nrh,
-	    const index_type & ncl, const index_type & nch);
+    int operator!(void) const { return (shape == NULL); }
+    // conclass cgors
+    void shallow_copy(const i3_array&);
+    i3_array(void);
+    i3_array(int sl, int sh, const index_type& nrl, const index_type& nrh,
+             const index_type& ncl, const index_type& nch);
 
-   i3_array(int _sl, int _sh, const imatrix & m1);
+    i3_array(int _sl, int _sh, const imatrix& m1);
 
-   i3_array(int sl, int sh);
-   i3_array(int sl, int sh, int nrl, int nrh, int ncl, int nch);
-   i3_array(int sl, int sh, int nrl, int nrh, const ivector & ncl,
-	    int nch);
+    i3_array(int sl,int sh);
+    i3_array(int sl,int sh,int nrl,int nrh,int ncl,int nch);
+    i3_array(int sl, int sh, int nrl, int nrh, const ivector& ncl, int nch);
 
-   i3_array(int sl, int sh, const ivector & nrl, const ivector & nrh,
-	    const imatrix & ncl, const imatrix & nch);
-   i3_array(int sl, int sh, const ivector & nrl, const ivector & nrh,
-	    int ncl, const imatrix & nch);
-   i3_array(int sl, int sh, const ivector & nrl, const ivector & nrh,
-	    const ivector & ncl, const ivector & nch);
-   i3_array(int sl, int sh, int nrl, int nrh, const ivector & ncl,
-	    const ivector & nch);
-   i3_array(int sl, int sh, int nrl, const ivector & nrh,
-	    int ncl, const ivector & nch);
-   i3_array(int sl, int sh, int nrl, const ivector & nrh,
-	    int ncl, int nch);
-   i3_array(int sl, int sh, int nrl, const ivector & nrh,
-	    int ncl, const imatrix & nch);
-   i3_array(const i3_array & m2);
-   ~i3_array();
+    i3_array(int sl, int sh, const ivector& nrl, const ivector& nrh,
+             const imatrix& ncl, const imatrix& nch);
+    i3_array(int sl, int sh, const ivector& nrl, const ivector& nrh,
+             int ncl, const imatrix& nch);
+    i3_array(int sl, int sh, const ivector& nrl, const ivector& nrh,
+             const ivector& ncl, const ivector& nch);
+    i3_array(int sl, int sh, int nrl, int nrh, const ivector& ncl,
+             const ivector& nch);
+    i3_array(int sl, int sh, int nrl, const ivector& nrh,
+             int ncl, const ivector& nch);
+    i3_array(int sl, int sh, int nrl, const ivector& nrh,
+      int ncl,int nch);
+    i3_array(int sl, int sh, int nrl, const ivector& nrh,
+             int ncl, const imatrix& nch);
+    i3_array(const i3_array& m2);
+    ~i3_array();
 
-   void allocate(int sl, int sh, int nrl, const ivector & nrh, int ncl,
-		 int nch);
-   void allocate(const dvar3_array &);
-   void allocate(const i3_array & i3v);
-   void allocate(int sl, int sh, int nrl, int nrh, int ncl, int nch);
-   void allocate(int sl, int sh);
+    void allocate(int sl,int sh,int nrl,const ivector& nrh,int ncl,int nch);
+    void allocate(const dvar3_array&);
+    void allocate(const i3_array& i3v);
+    void allocate(int sl,int sh,int nrl,int nrh,int ncl,int nch);
+    void allocate(int sl,int sh);
 
-   void allocate(int sl, int sh, int nrl, int nrh, const ivector & ncl,
-		 int nch);
+    void allocate(int sl, int sh, int nrl, int nrh, const ivector& ncl, int nch);
 
-   void allocate(int sl, int sh, const index_type & nrl,
-		 const index_type & nrh, const index_type & ncl,
-		 const index_type & nch);
+   void allocate(int sl, int sh, const index_type& nrl, const index_type& nrh,
+                 const index_type& ncl, const index_type& nch);
 
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 const imatrix & ncl, const imatrix & nch);
-   void allocate(int sl, int sh, int nrl, const ivector & nrh,
-		 int ncl, const imatrix & nch);
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 int ncl, const imatrix & nch);
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 int ncl, int nch);
-   void allocate(int sl, int sh, const ivector & nrl, int nrh,
-		 int ncl, int nch);
+   void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+                 const imatrix& ncl, const imatrix& nch);
+   void allocate(int sl, int sh, int nrl, const ivector& nrh,
+                 int ncl, const imatrix& nch);
+   void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+                 int ncl, const imatrix& nch);
+   void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+      int ncl,int nch);
+   void allocate(int sl, int sh, const ivector& nrl, int nrh,
+      int ncl,int nch);
    //void allocate(int sl, int sh, int nrl, const ivector& nrh,
-   //  int ncl,int nch);
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 const ivector & ncl, const ivector & nch);
-   void allocate(int sl, int sh, int nrl, const ivector & nrh,
-		 int ncl, const ivector & nch);
-   void allocate(int sl, int sh, int nrl, int nrh,
-		 const ivector & ncl, const ivector & nch);
-   void allocate(int sl, int sh, int nrl, int nrh,
-		 int ncl, const ivector & nch);
-   void allocate(void);
-   void deallocate(void);
-   void initialize(int sl, int sh, int nrl, const ivector & nrh,
-		   int ncl, const ivector & nch);
+    //  int ncl,int nch);
+   void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+                 const ivector& ncl, const ivector& nch);
+    void allocate(int sl, int sh, int nrl, const ivector& nrh,
+                  int ncl, const ivector& nch);
+    void allocate(int sl,int sh,int nrl,int nrh,
+                  const ivector& ncl, const ivector& nch);
+    void allocate(int sl,int sh,int nrl,int nrh,
+                  int ncl, const ivector& nch);
+    void allocate(void);
+    void deallocate(void);
+    void initialize(int sl, int sh, int nrl, const ivector& nrh,
+                    int ncl, const ivector& nch);
 
-   //access functions
-   int indexmin(void) const
-   {
-      return shape->slice_min;
-   }
-   int indexmax(void) const
-   {
-      return shape->slice_max;
-   }
-   int slicemin(void) const
-   {
-      return shape->slice_min;
-   }
-   int slicemax(void) const
-   {
-      return shape->slice_max;
-   }
-   int colmin(void) const
-   {
-      return ((*this) (slicemin()).colmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (slicemin()).colmax());
-   }
-   int rowmin(void) const
-   {
-      return ((*this) (slicemin()).rowmin());
-   }
-   int rowmax(void) const
-   {
-      return ((*this) (slicemin()).rowmax());
-   }
+    //access functions
+    int indexmin(void) const { return shape->slice_min; }
+    int indexmax(void) const { return shape->slice_max; }
+    int slicemin(void) const { return shape->slice_min; }
+    int slicemax(void) const { return shape->slice_max; }
+    int colmin(void) const { return ((*this)(slicemin()).colmin()); }
+    int colmax(void) const { return ((*this)(slicemin()).colmax()); }
+    int rowmin(void) const { return ((*this)(slicemin()).rowmin()); }
+    int rowmax(void) const { return ((*this)(slicemin()).rowmax()); }
 
-   int slicesize() const
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize() const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-   void initialize(void);
+    int slicesize() const { return (slicemax() - slicemin() + 1); } // returns the number of rows
+    int rowsize() const { return (rowmax() - rowmin() + 1); } // returns the number of rows
+    int colsize() const { return (colmax() - colmin() + 1); } // returns the number of columns
+    void initialize(void);
 
-   imatrix & elem(int k)
-   {
-      return (t[k]);
-   }
+   imatrix& elem(int k) { return(t[k]); }
 #ifdef USE_CONST
-   const imatrix & elem(int k) const
-   {
-      return t[k];
-   }
+   const imatrix& elem(int k) const { return t[k]; }
 #endif
 #ifdef OPT_LIB
-#ifdef USE_CONST
-   inline const int &operator() (int k, int i, int j) const
-   {
-      return (((t[k].m[i]).v)[j]);
-   }
+  #ifdef USE_CONST
+    inline const int& operator()(int k, int i, int j) const
+    {
+      return ( ((t[k].m[i]).v)[j] );
+    }
 
-   inline const ivector & operator() (int k, int i) const
-   {
-      return (t[k].m[i]);
-   }
+    inline const ivector& operator()(int k, int i) const
+    {
+      return ( t[k].m[i]);
+    }
 
-   inline const imatrix & operator() (int i) const
-   {
-      return (t[i]);
-   }
+    inline const imatrix& operator()(int i) const
+    {
+      return( t[i]);
+    }
 
-   inline const imatrix & operator[] (int i) const
-   {
-      return (t[i]);
-   }
-#endif
+    inline const imatrix& operator[](int i) const
+    {
+      return( t[i]);
+    }
+  #endif
 
-   inline int &operator() (int k, int i, int j)
-   {
-      return (((t[k].m[i]).v)[j]);
-   }
+    inline int& operator()(int k, int i, int j)
+    {
+      return ( ((t[k].m[i]).v)[j] );
+    }
 
-   inline ivector & operator () (int k, int i)
-   {
-      return (t[k].m[i]);
-   }
+    inline ivector& operator () (int k, int i)
+    {
+      return ( t[k].m[i]);
+    }
 
-   inline imatrix & operator() (int i)
-   {
-      return (t[i]);
-   }
+    inline imatrix& operator() (int i)
+    {
+      return( t[i]);
+    }
 
-   inline imatrix & operator[] (int i)
-   {
-      return (t[i]);
-   }
+    inline imatrix& operator[] (int i)
+    {
+      return( t[i]);
+    }
 #else
-   int &operator () (int k, int i, int j);
-   ivector & operator ()(int k, int i);
-   imatrix & operator[](int i);
-   imatrix & operator()(int i);
-#ifdef USE_CONST
-   const int &operator() (int k, int i, int j) const;
-   const ivector & operator() (int k, int i) const;
-   const imatrix & operator[] (int i) const;
-   const imatrix & operator() (int i) const;
+    int& operator () (int k, int i, int j);
+    ivector& operator () (int k, int i);
+    imatrix& operator[] (int i);
+    imatrix& operator() (int i);
+  #ifdef USE_CONST
+    const int& operator()(int k, int i, int j) const;
+    const ivector& operator()(int k, int i) const;
+    const imatrix& operator[](int i) const; 
+    const imatrix& operator()(int i) const;
+  #endif
 #endif
-#endif
 
-   i3_array & operator=(const i3_array & m1);
-   i3_array & operator=(int x);
+    i3_array& operator=(const i3_array& m1);
+    i3_array& operator= (int x);
 
-   void fill_randu(long int &n);
-   void fill_randn(long int &n);
-   void fill_randu_ni(long int &n);
-   void fill_randn_ni(long int &n);
+    void fill_randu(long int& n);
+    void fill_randn(long int& n);
+    void fill_randu_ni(long int& n);
+    void fill_randn_ni(long int& n);
 
-};				//end of class i3_array
-
+  }; //end of class i3_array
 #   if defined(__NUMBERVECTOR__)
-class param_init_matrix_vector;
-class param_init_bounded_matrix_vector;
+      class param_init_matrix_vector;
+      class param_init_bounded_matrix_vector;
 #   endif
 
 /**
  * Description not yet available.
  * \param
  */
-class dvar3_array
-{
 
-   dvar_matrix *t;
-   three_array_shape *shape;
+  class dvar3_array
+  {
 
- public:
+    dvar_matrix * t;
+    three_array_shape * shape;
 
-   void shallow_copy(const dvar3_array &);
-   dvar3_array sub(int, int);
-   dvar3_array(int, int);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   // conclass cgors
+  public:
 
-   void initialize(void);
-   void allocate(int sl, int sh, int nrl, int nrh, int ncl, int nch);
-   void allocate(int sl, int sh, int nrl, int nrh);
-   void allocate(int sl, int sh, const index_type & nrl,
-		 const index_type & nrh);
-   void allocate(int sl, int sh);
+    void shallow_copy(const dvar3_array&);
+    dvar3_array sub(int,int);
+    dvar3_array(int,int);
+    int operator!(void) const { return (shape == NULL); }
+    // conclass cgors
 
+    void initialize(void);
+      void allocate(int sl,int sh,int nrl,int nrh,int ncl,int nch);
+      void allocate(int sl,int sh,int nrl,int nrh);
+      void allocate(int sl,int sh,const index_type& nrl,const index_type& nrh);
+      void allocate(int sl,int sh);
 
-   void allocate(int sl, int sh, int nrl, int nrh, const ivector & ncl,
-		 int nch);
-   void allocate(const d3_array & m1);
-   void allocate(void);
-   void allocate(const dvar3_array & m1);
-   void allocate(int sl, int sh, int nrl, int nrh,
-		 const ivector & ncl, const ivector & nch);
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 const ivector & ncl, const ivector & nch);
-   void allocate(int sl, int sh, const ivector & nrl, const ivector & nrh,
-		 int ncl, int nch);
-   void allocate(int sl, int sh, const ivector & nrl, int nrh,
-		 int ncl, int nch);
-   void allocate(int sl, int sh, int nrl, const ivector & nrh,
-		 int ncl, int nch);
-   void allocate(int sl, int sh, int nrl, const ivector & nrh,
-		 int ncl, const ivector & nch);
-   void allocate(int sl, int sh, int nrl, int nrh,
-		 int ncl, const ivector & nch);
-   void allocate(ad_integer sl, ad_integer sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch);
-   void allocate(ad_integer sl, ad_integer sh,
-		 const index_type & nrl, const index_type & nrh);
-   void allocate(ad_integer sl, ad_integer sh);
 
-   void deallocate();
-   dvar3_array(int sl, int sh, int nrl, int nrh, int ncl, int nch);
-   dvar3_array(int sl, int sh, int nrl, int nrh, const ivector & ncl,
-	       int nch);
+      void allocate(int sl, int sh, int nrl, int nrh, const ivector& ncl, int nch);
+      void allocate(const d3_array& m1);
+      void allocate(void);
+      void allocate(const dvar3_array& m1);
+      void allocate(int sl,int sh,int nrl,int nrh,
+	            const ivector& ncl, const ivector& nch);
+      void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+                    const ivector& ncl, const ivector& nch);
+      void allocate(int sl, int sh, const ivector& nrl, const ivector& nrh,
+	int ncl,int nch);
+      void allocate(int sl, int sh, const ivector& nrl, int nrh,
+	int ncl,int nch);
+      void allocate(int sl, int sh, int nrl, const ivector& nrh,
+	int ncl,int nch);
+      void allocate(int sl, int sh, int nrl, const ivector& nrh,
+	            int ncl, const ivector& nch);
+      void allocate(int sl,int sh,int nrl,int nrh,
+                    int ncl, const ivector& nch);
+      void allocate(ad_integer sl, ad_integer sh,
+                    const index_type& nrl, const index_type& nrh,
+                    const index_type& ncl, const index_type& nch);
+      void allocate(ad_integer sl, ad_integer sh,
+                   const index_type& nrl, const index_type& nrh);
+      void allocate(ad_integer sl,ad_integer sh);
 
-   dvar3_array(int sl, int sh, const ivector & nrl, const ivector & nrh,
-	       ivector & ncl, const ivector & nch);
+      void deallocate();
+    dvar3_array(int sl,int sh,int nrl,int nrh,int ncl,int nch);
+    dvar3_array(int sl, int sh, int nrl, int nrh, const ivector& ncl, int nch);
 
-   dvar3_array(int sl, int sh, int nrl, const ivector & nrh,
-	       int ncl, const ivector & nch);
+    dvar3_array(int sl, int sh, const ivector& nrl, const ivector& nrh,
+                ivector& ncl, const ivector& nch);
 
-   dvar3_array(int sl, int sh, int nrl, const ivector & nrh,
-	       int ncl, int nch);
+    dvar3_array(int sl, int sh, int nrl, const ivector& nrh,
+                int ncl, const ivector& nch);
 
-   dvar3_array(ad_integer sl, ad_integer sh,
-	       const index_type & nrl, const index_type & nrh,
-	       const index_type & ncl, const index_type & nch);
+    dvar3_array(int sl, int sh, int nrl, const ivector& nrh,
+      int ncl,int nch);
 
+    dvar3_array(ad_integer sl, ad_integer sh,
+                const index_type& nrl, const index_type& nrh,
+                const index_type& ncl, const index_type& nch);
 
-   dvar3_array(const d3_array & m2);
+
+    dvar3_array(const d3_array& m2);
 #   if defined(__NUMBERVECTOR__)
-   dvar3_array(const param_init_matrix_vector & m2);
-   dvar3_array(const param_init_bounded_matrix_vector & m2);
+      dvar3_array(const param_init_matrix_vector& m2);
+      dvar3_array(const param_init_bounded_matrix_vector& m2);
 #   endif
 
-   dvar3_array(const dvar3_array & m2);
+    dvar3_array(const dvar3_array& m2);
 
-   dvar3_array(void);
+    dvar3_array(void);
 
-   ~dvar3_array();
+    ~dvar3_array();
 
-   d3_array value(const dvar3_array &);
+    d3_array value(const dvar3_array&);
 
-   //access functions
-   int indexmin(void) const
-   {
-      return shape->slice_min;
-   }
-   int indexmax(void) const
-   {
-      return shape->slice_max;
-   }
-   int slicemin(void) const
-   {
-      return shape->slice_min;
-   }
-   int slicemax(void) const
-   {
-      return (shape->slice_max);
-   }
-   int colmin(void) const
-   {
-      return ((*this) (slicemin()).colmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (slicemin()).colmax());
-   }
-   int rowmin(void) const
-   {
-      return ((*this) (slicemin()).rowmin());
-   }
-   int rowmax(void) const
-   {
-      return ((*this) (slicemin()).rowmax());
-   }
+    //access functions
+    int indexmin(void) const { return shape->slice_min; }
+    int indexmax(void) const { return shape->slice_max; }
+    int slicemin(void) const { return shape->slice_min; }
+    int slicemax(void) const { return (shape->slice_max); }
+    int colmin(void) const { return ((*this)(slicemin()).colmin()); }
+    int colmax(void) const { return ((*this)(slicemin()).colmax()); }
+    int rowmin(void) const { return ((*this)(slicemin()).rowmin()); }
+    int rowmax(void) const { return ((*this)(slicemin()).rowmax()); }
 
-   int slicesize() const
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize() const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
+    int slicesize() const { return (slicemax() - slicemin() + 1); } // returns the number of rows
+    int rowsize() const { return (rowmax() - rowmin() + 1); } // returns the number of rows
+    int colsize() const { return (colmax() - colmin() + 1); } // returns the number of columns
 
-   dvar_matrix & elem(int k)
-   {
-      return (t[k]);
-   }
-   prevariable elem(int i, int j, int k)
-   {
-      return (t[k].elem(i, j));
-   }
-#ifdef USE_CONST
-   const dvar_matrix & elem(int k) const
-   {
-      return t[k];
-   }
-   const prevariable elem(int i, int j, int k) const
-   {
-      return t[k].elem(i, j);
-   }
-#endif
+    dvar_matrix& elem(int k) { return( t[k] ); }
+    prevariable elem(int i,int j,int k) { return( t[k].elem(i,j) ); }
+    #ifdef USE_CONST
+       const dvar_matrix& elem(int k) const { return t[k]; }
+       const prevariable elem(int i,int j,int k) const { return t[k].elem(i,j); }
+    #endif
 
 #ifdef OPT_LIB
-#ifdef USE_CONST
-   inline const prevariable operator() (int k, int i, int j) const
-   {
-      return (((t[k].m[i]).va) + j);
-   }
+  #ifdef USE_CONST
+    inline const prevariable operator()(int k, int i, int j) const
+    {
+      return ( ((t[k].m[i]).va)+j );
+    }
 
-   inline const dvar_vector & operator() (int k, int i) const
-   {
-      return (t[k].m[i]);
-   }
+    inline const dvar_vector& operator()(int k, int i) const
+    {
+      return ( t[k].m[i]);
+    }
 
-   inline const dvar_matrix & operator() (int i) const
-   {
-      return (t[i]);
-   }
+    inline const dvar_matrix& operator()(int i) const
+    {
+      return( t[i]);
+    }
 
-   inline const dvar_matrix & operator[] (int i) const
-   {
-      return (t[i]);
-   }
-#endif
+    inline const dvar_matrix& operator[](int i) const
+    {
+      return( t[i]);
+    }
+  #endif
 
-   inline prevariable operator () (int k, int i, int j)
-   {
-      return (((t[k].m[i]).va) + j);
-   }
+    inline prevariable operator () (int k, int i, int j)
+    {
+      return ( ((t[k].m[i]).va)+j );
+    }
 
-   inline dvar_vector & operator () (int k, int i)
-   {
-      return (t[k].m[i]);
-   }
+    inline dvar_vector& operator () (int k, int i)
+    {
+      return ( t[k].m[i]);
+    }
 
-   inline dvar_matrix & operator() (int i)
-   {
-      return (t[i]);
-   }
+    inline dvar_matrix& operator() (int i)
+    {
+      return( t[i]);
+    }
 
-   inline dvar_matrix & operator[] (int i)
-   {
-      return (t[i]);
-   }
+    inline dvar_matrix& operator[] (int i)
+    {
+      return( t[i]);
+    }
 #else
-   prevariable operator () (int k, int i, int j);
-   dvar_vector & operator ()(int k, int i);
-   dvar_matrix & operator[](int i);
-   dvar_matrix & operator()(int i);
-#ifdef USE_CONST
-   const prevariable operator() (int k, int i, int j) const;
-   const dvar_vector & operator() (int k, int i) const;
-   const dvar_matrix & operator[] (int i) const;
-   const dvar_matrix & operator() (int i) const;
+    prevariable operator () (int k, int i, int j);
+    dvar_vector& operator () (int k, int i);
+    dvar_matrix& operator[] (int i);
+    dvar_matrix& operator() (int i);
+  #ifdef USE_CONST
+    const prevariable operator()(int k, int i, int j) const;
+    const dvar_vector& operator()(int k, int i) const;
+    const dvar_matrix& operator[](int i) const; 
+    const dvar_matrix& operator()(int i) const;
+  #endif
 #endif
-#endif
 
-   dvar3_array & operator=(const d3_array & m1);
-   dvar3_array & operator=(double x);
-   dvar3_array & operator=(const dvar3_array & m1);
+    dvar3_array& operator=(const d3_array& m1);
+    dvar3_array& operator= (double x);
+    dvar3_array& operator=(const dvar3_array& m1);
 
-   void fill_randu(long int &n);
-   void fill_randn(long int &n);
+    void fill_randu(long int& n);
+    void fill_randn(long int& n);
 
-   void fill_randu_ni(long int &n);
-   void fill_randn_ni(long int &n);
-   double fill_seqadd(double, double);
-   void operator/=(const prevariable &);
-   void operator /=(double);
+    void fill_randu_ni(long int& n);
+    void fill_randn_ni(long int& n);
+    double fill_seqadd(double,double);
+    void operator/=(const prevariable&);
+    void operator /=(double);
 
-};				//end of class dvar3_array
+  }; //end of class dvar3_array
+dvariable inv_cumd_exponential(const prevariable& y);
+dvariable cumd_exponential(const prevariable& x);
 
-dvariable inv_cumd_exponential(const prevariable & y);
-dvariable cumd_exponential(const prevariable & x);
-
 double inv_cumd_exponential(double y);
 double cumd_exponential(double x);
 
-double cumd_logistic(const double &x);
-double inv_cumd_logistic(const double &x);
+double cumd_logistic(const double& x);
+double inv_cumd_logistic(const double& x);
 
-dvariable cumd_logistic(const prevariable & x);
-dvariable inv_cumd_logistic(const prevariable & x);
-double inv_cumd_norm(const double &x);
-double cumd_norm(const double &x);
-double cumd_norm(const double &x, double);
-dvariable inv_cumd_norm(const prevariable & x);
-dvar_vector inv_cumd_norm(const dvar_vector & x);
-prevariable & cumd_norm(const prevariable & x);
-prevariable & bounded_cumd_norm(const prevariable & x, double);
-double bounded_cumd_norm(double x, double);
+dvariable cumd_logistic(const prevariable& x);
+dvariable inv_cumd_logistic(const prevariable& x);
+double inv_cumd_norm(const double& x);
+double cumd_norm(const double& x);
+double cumd_norm(const double& x,double);
+dvariable inv_cumd_norm(const prevariable& x);
+dvar_vector inv_cumd_norm(const dvar_vector& x);
+prevariable& cumd_norm(const prevariable& x);
+prevariable& bounded_cumd_norm(const prevariable& x,double);
+double bounded_cumd_norm(double x,double);
 //dvariable& old_cumd_norm(const prevariable& x);
-double normal_tail_right(const double &x);
+double normal_tail_right(const double& x);
 
-dvariable inv_cumd_norm_logistic(const prevariable & x, double);
-prevariable & cumd_norm_logistic(const prevariable & x, double);
-double inv_cumd_norm_logistic(double x, double);
-double cumd_norm_logistic(double x, double);
+dvariable inv_cumd_norm_logistic(const prevariable& x,double);
+prevariable& cumd_norm_logistic(const prevariable& x,double);
+double inv_cumd_norm_logistic(double x,double);
+double cumd_norm_logistic(double x,double);
 
 /**
  * Description not yet available.
@@ -5384,271 +4798,242 @@
  */
 class prevariable_position
 {
-   double_and_int *v;
- public:
-   prevariable_position(const prevariable & x)
-   {
-      v = x.get_v();
-   }
-   prevariable_position(double_and_int * p)
-   {
-      v = p;
-   }
-   double &xval()
-   {
-      return ((v->x));
-   }
+  double_and_int * v;
+public:
+  prevariable_position(const prevariable& _x)
+  {
+    prevariable& x=(prevariable&)(_x); v=x.get_v();
+  }
+  prevariable_position(double_and_int * p){v=p;}
+  double& xval() { return( (v->x) ); }
 };
 
-double restore_prevariable_derivative(const prevariable_position & pre);
+double restore_prevariable_derivative(const prevariable_position& pre);
 double restore_prevariable_derivative(void);
 prevariable_position restore_prevariable_position(void);
-void save_double_derivative(double x, const prevariable_position & pos);
+void save_double_derivative(double x, const prevariable_position& pos);
 double restore_prevariable_value(void);
 void save_double_value(double x);
-int sum(const imatrix &);
-double sum(const dmatrix &);
-double sum(const d3_array &);
-double sum(const d4_array &);
-double sum(const d5_array &);
-double sum(const d6_array &);
-double sum(const d7_array &);
-dvariable sum(const dvar_matrix &);
-dvariable sum(const dvar3_array &);
-dvariable sum(const dvar4_array &);
-dvariable sum(const dvar5_array &);
-dvariable sum(const dvar6_array &);
-dvariable sum(const dvar7_array &);
+   int sum(const imatrix&);
+   double sum(const dmatrix&);
+   double sum(const d3_array&);
+   double sum(const d4_array&);
+   double sum(const d5_array&);
+   double sum(const d6_array&);
+   double sum(const d7_array&);
+   dvariable sum(const dvar_matrix&);
+   dvariable sum(const dvar3_array&);
+   dvariable sum(const dvar4_array&);
+   dvariable sum(const dvar5_array&);
+   dvariable sum(const dvar6_array&);
+   dvariable sum(const dvar7_array&);
 
-dmatrix fabs(const dmatrix & m);
-//double& value(const  double& u);
+   dmatrix fabs(const dmatrix& m);
+   //double& value(const double& u);
    //const double& value(const double& u);
-double norm(const d3_array &);
-double norm2(const d3_array &);
-double sumsq(const d3_array &);
-d3_array exp(const d3_array & m);
-d3_array mfexp(const d3_array & m);
-d3_array mfexp(const d3_array & m, double d);
-d3_array log(const d3_array & m);
-d3_array fabs(const d3_array & m);
-d3_array sin(const d3_array & m);
-d3_array cos(const d3_array & m);
-d3_array tan(const d3_array & m);
-d3_array sqrt(const d3_array & m);
-d3_array sqr(const d3_array & m);
-d3_array elem_prod(const d3_array & m1, const d3_array & m2);
-d3_array elem_div(const d3_array & m1, const d3_array & m2);
-d3_array operator+(const d3_array & m1, const d3_array & m2);
-d3_array operator+(const d3_array & m1, double m2);
-d3_array operator/(const d3_array & m1, double m2);
-d3_array operator/(double m2, const d3_array & m1);
-d3_array operator+(double m1, const d3_array & m2);
-d3_array operator-(const d3_array & m1, const d3_array & m2);
-d3_array operator-(const d3_array & m1, double m2);
-d3_array operator-(double m1, const d3_array & m2);
-d3_array operator*(const d3_array & m1, const d3_array & m2);
-dmatrix operator *(const d3_array & m1, const dvector & m2);
-d3_array operator*(const d3_array & m1, double m2);
-d3_array operator*(double m1, const d3_array & m2);
+   double norm(const d3_array&);
+   double norm2(const d3_array&);
+   double sumsq(const d3_array&);
+   d3_array exp(const d3_array& m);
+   d3_array mfexp(const d3_array& m);
+   d3_array mfexp(const d3_array& m, double d);
+   d3_array log(const d3_array& m);
+   d3_array fabs(const d3_array& m);
+   d3_array sin(const d3_array& m);
+   d3_array cos(const d3_array& m);
+   d3_array tan(const d3_array& m);
+   d3_array sqrt(const d3_array& m);
+   d3_array sqr(const d3_array& m);
+   d3_array elem_prod(const d3_array& m1,const d3_array& m2);
+   d3_array elem_div(const d3_array& m1,const d3_array& m2);
+   d3_array operator + (const d3_array& m1,const d3_array& m2);
+   d3_array operator + (const d3_array& m1, double m2);
+   d3_array operator / (const d3_array& m1, double m2);
+   d3_array operator / ( double m2,const d3_array& m1);
+   d3_array operator + ( double m1,const d3_array& m2);
+   d3_array operator - (const d3_array& m1,const d3_array& m2);
+   d3_array operator - (const d3_array& m1, double m2);
+   d3_array operator - ( double m1,const d3_array& m2);
+   d3_array operator * (const d3_array& m1,const d3_array& m2);
+   dmatrix operator * (const d3_array& m1,const dvector& m2);
+   d3_array operator * (const d3_array& m1, double m2);
+   d3_array operator * ( double m1,const d3_array& m2);
 
-dvariable norm(const dvar3_array & m);
-dvariable norm2(const dvar3_array & m);
-dvariable sumsq(const dvar3_array & m);
-dvar3_array exp(const dvar3_array & m);
-dvar3_array mfexp(const dvar3_array & m);
-dvar3_array mfexp(const dvar3_array & m, double d);
-dvar3_array log(const dvar3_array & m);
-dvar3_array fabs(const dvar3_array & m);
-dvar3_array sin(const dvar3_array & m);
-dvar3_array cos(const dvar3_array & m);
-dvar3_array tan(const dvar3_array & m);
-dvar3_array sqrt(const dvar3_array & m);
-dvar3_array sqr(const dvar3_array & m);
-dvar3_array elem_prod(const dvar3_array & m1, const dvar3_array & m2);
-dvar3_array elem_div(const dvar3_array & m1, const dvar3_array & m2);
-dvar3_array operator+(const dvar3_array & m1, const dvar3_array & m2);
-dvar3_array operator-(const dvar3_array & m1, const dvar3_array & m2);
-dvar3_array elem_prod(const d3_array & m1, const dvar3_array & m2);
-dvar3_array elem_div(const d3_array & m1, const dvar3_array & m2);
-dvar3_array operator+(const d3_array & m1, const dvar3_array & m2);
-dvar3_array operator-(const d3_array & m1, const dvar3_array & m2);
-dvar3_array elem_prod(const dvar3_array & m1, const d3_array & m2);
-dvar3_array elem_div(const dvar3_array & m1, const d3_array & m2);
-dvar3_array operator+(const dvar3_array & m1, const d3_array & m2);
-dvar3_array operator+(const dvar3_array & m1, const dvariable & m2);
-dvar3_array operator+(const dvariable & d1, const dvar3_array & m1);
+   dvariable norm(const dvar3_array& m);
+   dvariable norm2(const dvar3_array& m);
+   dvariable sumsq(const dvar3_array& m);
+   dvar3_array exp(const dvar3_array& m);
+   dvar3_array mfexp(const dvar3_array& m);
+   dvar3_array mfexp(const dvar3_array& m, double d);
+   dvar3_array log(const dvar3_array& m);
+   dvar3_array fabs(const dvar3_array& m);
+   dvar3_array sin(const dvar3_array& m);
+   dvar3_array cos(const dvar3_array& m);
+   dvar3_array tan(const dvar3_array& m);
+   dvar3_array sqrt(const dvar3_array& m);
+   dvar3_array sqr(const dvar3_array& m);
+   dvar3_array elem_prod(const dvar3_array& m1,const dvar3_array& m2);
+   dvar3_array elem_div(const dvar3_array& m1,const dvar3_array& m2);
+   dvar3_array operator + (const dvar3_array& m1,const dvar3_array& m2);
+   dvar3_array operator - (const dvar3_array& m1,const dvar3_array& m2);
+   dvar3_array elem_prod(const d3_array& m1,const dvar3_array& m2);
+   dvar3_array elem_div(const d3_array& m1,const dvar3_array& m2);
+   dvar3_array operator + (const d3_array& m1,const dvar3_array& m2);
+   dvar3_array operator - (const d3_array& m1,const dvar3_array& m2);
+   dvar3_array elem_prod(const dvar3_array& m1,const d3_array& m2);
+   dvar3_array elem_div(const dvar3_array& m1,const d3_array& m2);
+   dvar3_array operator + (const dvar3_array& m1,const d3_array& m2);
+   dvar3_array operator + (const dvar3_array& m1,const dvariable& m2);
+   dvar3_array operator + (const dvariable& d1, const dvar3_array& m1);
+  
+   dvar3_array operator / (const prevariable& m2,const dvar3_array& m1);
+   dvar3_array operator / (const prevariable& m2,const d3_array& m1);
+   dvar3_array operator / ( double m2,const dvar3_array& m1);
 
-dvar3_array operator/(const prevariable & m2, const dvar3_array & m1);
-dvar3_array operator/(const prevariable & m2, const d3_array & m1);
-dvar3_array operator/(double m2, const dvar3_array & m1);
+   dvar3_array operator / (const dvar3_array& m1,const prevariable& m2);
+   dvar3_array operator / (const d3_array& m1,const prevariable& m2);
+   dvar3_array operator / (const dvar3_array& m1, double m2);
 
-dvar3_array operator/(const dvar3_array & m1, const prevariable & m2);
-dvar3_array operator/(const d3_array & m1, const prevariable & m2);
-dvar3_array operator/(const dvar3_array & m1, double m2);
+   dvar3_array operator + (const dvariable& m1,const d3_array& m2);
+   dvar3_array operator + ( double m1,const dvar3_array& m2);
+   dvar3_array operator - (const dvar3_array& m1,const d3_array& m2);
+   dvar3_array operator - (const dvar3_array& m1,const dvariable& m2);
+   dvar3_array operator - (const dvariable& m1,const d3_array& m2);
+   dvar3_array operator - (const dvariable& m1,const dvar3_array& m2);
+   dvar3_array operator - ( double m1,const dvar3_array& m2);
+   dvar3_array operator * (const dvar3_array& m1,const d3_array& m2);
+   dvar3_array operator * (const dvar3_array& m1,const dvariable& m2);
+   dvar3_array operator * (const dvariable& m1,const d3_array& m2);
+   dvar3_array operator * (const dvariable& m1,const dvar3_array& m2);
+   dvar3_array operator * (double m1,const dvar3_array& m2);
 
-dvar3_array operator+(const dvariable & m1, const d3_array & m2);
-dvar3_array operator+(double m1, const dvar3_array & m2);
-dvar3_array operator-(const dvar3_array & m1, const d3_array & m2);
-dvar3_array operator-(const dvar3_array & m1, const dvariable & m2);
-dvar3_array operator-(const dvariable & m1, const d3_array & m2);
-dvar3_array operator-(const dvariable & m1, const dvar3_array & m2);
-dvar3_array operator-(double m1, const dvar3_array & m2);
-dvar3_array operator*(const dvar3_array & m1, const d3_array & m2);
-dvar3_array operator*(const dvar3_array & m1, const dvariable & m2);
-dvar3_array operator*(const dvariable & m1, const d3_array & m2);
-dvar3_array operator*(const dvariable & m1, const dvar3_array & m2);
-dvar3_array operator*(double m1, const dvar3_array & m2);
+   double square( double x);
+   dvector square(const dvector& x);
+   dmatrix square(const dmatrix& x);
+   d3_array square(const d3_array& x);
 
-double square(double x);
-dvector square(const dvector & x);
-dmatrix square(const dmatrix & x);
-d3_array square(const d3_array & x);
+   dvariable& square(const prevariable& x);
+   dvar_vector square(const dvar_vector& x);
+   dvar_matrix square(const dvar_matrix& x);
+   dvar3_array square(const dvar3_array& x);
 
-dvariable & square(const prevariable & x);
-dvar_vector square(const dvar_vector & x);
-dvar_matrix square(const dvar_matrix & x);
-dvar3_array square(const dvar3_array & x);
+   double cube( double x);
+   double fourth( double x);
+   dvector cube(const dvector& x);
+   dmatrix cube(const dmatrix& x);
+   d3_array cube(const d3_array& x);
 
-double cube(double x);
-double fourth(double x);
-dvector cube(const dvector & x);
-dmatrix cube(const dmatrix & x);
-d3_array cube(const d3_array & x);
+   d3_array pow(const d3_array& x,int e);
+   dvar3_array pow(const dvar3_array& x,int e);
 
-d3_array pow(const d3_array & x, int e);
-dvar3_array pow(const dvar3_array & x, int e);
+   prevariable& cube(const prevariable& x);
+   dvar_vector cube(const dvar_vector& x);
+   dvar_matrix cube(const dvar_matrix& x);
+   dvar3_array cube(const dvar3_array& x);
 
-prevariable & cube(const prevariable & x);
-dvar_vector cube(const dvar_vector & x);
-dvar_matrix cube(const dvar_matrix & x);
-dvar3_array cube(const dvar3_array & x);
+void set_value(const dvar_matrix& x,const dvar_vector& v,const int& _ii,
+  double s);
+void set_value(const dvar_matrix& x,const dvar_vector& v, const int& ii, 
+  double fmin,double fmax,const dvariable& fpen,double s);
+void set_value_inv(const dvar_matrix& x,const dvector& v, const int& ii,
+  double s);
+void set_value_inv(const dvar_matrix& x,const dvector& v, const int& ii,
+  double fmin,double fmax,double s);
+void set_value(const dvar_vector& x,const dvar_vector& v, const int& _ii,double s);
+void set_value(const dvar_vector& _x,const dvar_vector& v,const int& _ii,
+  double fmin,double fmax,const dvariable& fpen,double s);
+void set_value_inv(const dvar_vector& x,const dvector& _v,const int& _ii,double s);
+void set_value_inv(const dvar_vector& x,const dvector& _v,const int& _ii,
+  double fmin,double fmax,double s);
+void set_value_inv(const dvar_matrix& x,const dvector& v, const int& ii);
+ void set_value_inv(const prevariable& x,const dvector& v,const int& ii,
+    double s);
+ void set_value_inv(const prevariable& x,const dvector& v, const int& ii);
+ void set_value_inv(const dvar_matrix& x,const dvector& v, const int& ii);
+ void set_value_inv(const dvar_matrix& u,const dvector& x,const int& ii,
+  double fmin,double fmax);
+ void set_value_inv(const dvar3_array& u,const dvector& x,const int& ii,
+  double fmin,double fmax);
+ void set_value_inv(const dvar3_array& u,const dvector& x,const int& ii);
 
-void set_value(const dvar_matrix & x, const dvar_vector & v,
-	       const int &_ii, double s);
-void set_value(const dvar_matrix & x, const dvar_vector & v, const int &ii,
-	       double fmin, double fmax, const dvariable & fpen, double s);
-void set_value_inv(const dvar_matrix & x, const dvector & v, const int &ii,
-		   double s);
-void set_value_inv(const dvar_matrix & x, const dvector & v, const int &ii,
-		   double fmin, double fmax, double s);
-void set_value(const dvar_vector & x, const dvar_vector & v,
-	       const int &_ii, double s);
-void set_value(const dvar_vector & _x, const dvar_vector & v,
-	       const int &_ii, double fmin, double fmax,
-	       const dvariable & fpen, double s);
-void set_value_inv(const dvar_vector & x, const dvector & _v,
-		   const int &_ii, double s);
-void set_value_inv(const dvar_vector & x, const dvector & _v,
-		   const int &_ii, double fmin, double fmax, double s);
-void set_value_inv(const dvar_matrix & x, const dvector & v,
-		   const int &ii);
-void set_value_inv(const prevariable & x, const dvector & v, const int &ii,
-		   double s);
-void set_value_inv(const prevariable & x, const dvector & v,
-		   const int &ii);
-void set_value_inv(const dvar_matrix & x, const dvector & v,
-		   const int &ii);
-void set_value_inv(const dvar_matrix & u, const dvector & x, const int &ii,
-		   double fmin, double fmax);
-void set_value_inv(const dvar3_array & u, const dvector & x, const int &ii,
-		   double fmin, double fmax);
-void set_value_inv(const dvar3_array & u, const dvector & x,
-		   const int &ii);
+  void set_value_inv( double x,const dvector& v, const int& ii);
 
-void set_value_inv(double x, const dvector & v, const int &ii);
+  void set_value_inv_exp(const prevariable& x,const dvector& _v,const int& _ii,
+    double fmin, double fmax,double s);
 
-void set_value_inv_exp(const prevariable & x, const dvector & _v,
-		       const int &_ii, double fmin, double fmax, double s);
+  void set_value_inv(const prevariable& x,const dvector& _v,const int& _ii,
+    double fmin, double fmax,double s);
 
-void set_value_inv(const prevariable & x, const dvector & _v,
-		   const int &_ii, double fmin, double fmax, double s);
+  void set_value_inv(const prevariable& u,const dvector& x,const int& ii,
+    double fmin,double fmax);
+  void set_value_inv( double u,const dvector& x,const int& ii, double fmin,
+    double fmax);
+  void set_value_inv(const dvector& x,const dvector& v, const int& ii);
+  void set_value_inv(const dvar_vector& x,const dvector& v, const int& ii);
+  void set_value_inv(const dvar_vector& x,const dvector& v, const int& ii,
+    double fmin,double fmax);
+  void set_value_inv(const dvector& x,const dvector& v, const int& ii,
+    double fmin,double fmax);
+  void set_value_inv(const dmatrix& x,const dvector& v, const int& ii);
+  void set_value_inv(const dmatrix& x,const dvector& v, const int& ii,
+    double fmin,double fmax);
+  void set_value_inv(const d3_array& x,const dvector& v, const int& ii);
+  void set_value_inv(const d3_array& x,const dvector& v, const int& ii,
+    double fmin,double fmax);
+  void set_value(const prevariable& x,const dvar_vector& v, const int& ii);
+  void set_value(const prevariable& x,const dvar_vector& v, const int& ii,double s);
+  void set_value(const dvar_vector& x,const dvar_vector& v, const int& ii);
 
-void set_value_inv(const prevariable & u, const dvector & x, const int &ii,
-		   double fmin, double fmax);
-void set_value_inv(double u, const dvector & x, const int &ii, double fmin,
-		   double fmax);
-void set_value_inv(const dvector & x, const dvector & v, const int &ii);
-void set_value_inv(const dvar_vector & x, const dvector & v,
-		   const int &ii);
-void set_value_inv(const dvar_vector & x, const dvector & v, const int &ii,
-		   double fmin, double fmax);
-void set_value_inv(const dvector & x, const dvector & v, const int &ii,
-		   double fmin, double fmax);
-void set_value_inv(const dmatrix & x, const dvector & v, const int &ii);
-void set_value_inv(const dmatrix & x, const dvector & v, const int &ii,
-		   double fmin, double fmax);
-void set_value_inv(const d3_array & x, const dvector & v, const int &ii);
-void set_value_inv(const d3_array & x, const dvector & v, const int &ii,
-		   double fmin, double fmax);
-void set_value(const prevariable & x, const dvar_vector & v,
-	       const int &ii);
-void set_value(const prevariable & x, const dvar_vector & v, const int &ii,
-	       double s);
-void set_value(const dvar_vector & x, const dvar_vector & v,
-	       const int &ii);
+void set_value_exp(const prevariable& _x,const dvar_vector& v,const int& _ii, 
+  double fmin, double fmax,const dvariable& fpen,double s);
+void set_value(const prevariable& _x,const dvar_vector& v,const int& _ii, 
+  double fmin, double fmax,const dvariable& fpen,double s);
 
-void set_value_exp(const prevariable & _x, const dvar_vector & v,
-		   const int &_ii, double fmin, double fmax,
-		   const dvariable & fpen, double s);
-void set_value(const prevariable & _x, const dvar_vector & v,
-	       const int &_ii, double fmin, double fmax,
-	       const dvariable & fpen, double s);
+  void set_value(const prevariable& x,const dvar_vector& v, const int& ii,
+    double fmin,double fmax,const dvariable& fpen);
+  void set_value(const dvar_vector& x,const dvar_vector& v, const int& ii,
+    double fmin,double fmax,const dvariable& fpen);
+  void set_value(const dvar_matrix& x,const dvar_vector& v, const int& ii);
+  void set_value(const dvar_matrix& x,const dvar_vector& v, const int& ii,
+    double fmin,double fmax,const dvariable& fpen);
+  void set_value(dvar3_array& x,const dvar_vector& v, const int& ii);
+  void set_value(dvar3_array& x,const dvar_vector& v, const int& ii, 
+    double fmin,double fmax,const dvariable& fpen);
 
-void set_value(const prevariable & x, const dvar_vector & v, const int &ii,
-	       double fmin, double fmax, const dvariable & fpen);
-void set_value(const dvar_vector & x, const dvar_vector & v, const int &ii,
-	       double fmin, double fmax, const dvariable & fpen);
-void set_value(const dvar_matrix & x, const dvar_vector & v,
-	       const int &ii);
-void set_value(const dvar_matrix & x, const dvar_vector & v, const int &ii,
-	       double fmin, double fmax, const dvariable & fpen);
-void set_value(dvar3_array & x, const dvar_vector & v, const int &ii);
-void set_value(dvar3_array & x, const dvar_vector & v, const int &ii,
-	       double fmin, double fmax, const dvariable & fpen);
+  void set_value_inv_partial(const dvector& x,const dvector& v, const int& ii,int n);
+  void set_value_inv_partial(const dvector& x,const dvector& v, const int& ii, int n,
+    double fmin,double fmax);
+  void set_value_inv_partial(const dmatrix& x,const dvector& v, const int& ii,int n);
+  void set_value_inv_partial(const dvar_matrix& x,const dvector& v, const int& ii,int n);
+  void set_value_inv_partial(const d3_array& x,const dvector& v, const int& ii,int n);
 
-void set_value_inv_partial(const dvector & x, const dvector & v,
-			   const int &ii, int n);
-void set_value_inv_partial(const dvector & x, const dvector & v,
-			   const int &ii, int n, double fmin, double fmax);
-void set_value_inv_partial(const dmatrix & x, const dvector & v,
-			   const int &ii, int n);
-void set_value_inv_partial(const dvar_matrix & x, const dvector & v,
-			   const int &ii, int n);
-void set_value_inv_partial(const d3_array & x, const dvector & v,
-			   const int &ii, int n);
+  void set_value_inv_partial(const dvar_vector& x,const dvector& v, const int& ii,int n);
+  void set_value_inv_partial(const dvar_vector& x,const dvector& v, const int& ii, int n,
+    double fmin,double fmax);
 
-void set_value_inv_partial(const dvar_vector & x, const dvector & v,
-			   const int &ii, int n);
-void set_value_inv_partial(const dvar_vector & x, const dvector & v,
-			   const int &ii, int n, double fmin, double fmax);
+  void set_value_partial(const dvar_vector& x,const dvar_vector& v, const int& ii,int n);
+  void set_value_partial(const dvar_vector& x,const dvar_vector& v, const int& ii, int n,
+    double fmin,double fmax,const dvariable& fpen);
+  void set_value_partial(const dvar_matrix& x,const dvar_vector& v, const int& ii,int n);
+  void set_value_partial(dvar3_array& x,const dvar_vector& v, const int& ii,int n);
 
-void set_value_partial(const dvar_vector & x, const dvar_vector & v,
-		       const int &ii, int n);
-void set_value_partial(const dvar_vector & x, const dvar_vector & v,
-		       const int &ii, int n, double fmin, double fmax,
-		       const dvariable & fpen);
-void set_value_partial(const dvar_matrix & x, const dvar_vector & v,
-		       const int &ii, int n);
-void set_value_partial(dvar3_array & x, const dvar_vector & v,
-		       const int &ii, int n);
+  int size_count(const dvar_vector& x);
+  int size_count(const dvar_matrix& x);
+  int size_count(const dvar3_array& x);
+  int size_count(const dvar4_array& x);
+  int size_count(const dvector& x);
+  int size_count(const dmatrix& x);
+  int size_count(const d3_array& x);
+  int size_count(const d4_array& x);
 
-int size_count(const dvar_vector & x);
-int size_count(const dvar_matrix & x);
-int size_count(const dvar3_array & x);
-int size_count(const dvar4_array & x);
-int size_count(const dvector & x);
-int size_count(const dmatrix & x);
-int size_count(const d3_array & x);
-int size_count(const d4_array & x);
+  int size_count_partial(const dvar_vector& x,int);
+  int size_count_partial(const dvar_matrix& x,int);
+  int size_count_partial(const dvar3_array& x,int);
+  int size_count_partial(const dvector& x,int);
+  int size_count_partial(const dmatrix& x,int);
+  int size_count_partial(const d3_array& x,int);
 
-int size_count_partial(const dvar_vector & x, int);
-int size_count_partial(const dvar_matrix & x, int);
-int size_count_partial(const dvar3_array & x, int);
-int size_count_partial(const dvector & x, int);
-int size_count_partial(const dmatrix & x, int);
-int size_count_partial(const d3_array & x, int);
-
-int min(int, int);
+int min(int,int);
 // ********************************************************
 // Prototypes for compiled derivative calculations
 void dfinvpret(void);
@@ -5658,109 +5043,105 @@
 
 
 // ********************************************************
-int save_identifier_string(const char *);
-void insert_identifier_string(const char *s);
-void verify_identifier_string(const char *);
+int save_identifier_string(const char*);
+void insert_identifier_string(const char * s);
+void verify_identifier_string(const char*);
 
 
-ivector restore_ivector_value(const ivector_position &);
+ivector restore_ivector_value(const ivector_position&);
 ivector_position restore_ivector_position(void);
 dvar_matrix_position restore_dvar_matrix_position(void);
-dvector restore_dvar_matrix_derivative_row(const dvar_matrix_position &
-					   pos, const int &ii);
-dvector restore_dvar_matrix_derivative_column(const dvar_matrix_position &
-					      pos, const int &ii);
-dmatrix restore_dvar_matrix_derivatives(const dvar_matrix_position & pos);
+dvector restore_dvar_matrix_derivative_row(const dvar_matrix_position& pos,const int& ii);
+dvector restore_dvar_matrix_derivative_column(const dvar_matrix_position& pos,const int& ii);
+dmatrix restore_dvar_matrix_derivatives(const dvar_matrix_position& pos);
 dmatrix restore_dvar_matrix_derivatives(void);
 double restore_prevariable_derivative(void);
 double restore_double_value(void);
 int restore_int_value(void);
-void save_double_value(double x);
+void save_double_value( double x);
 void save_int_value(int x);
-void save_pointer_value(void *ptr);
-void *restore_pointer_value(void);
-dvar_matrix nograd_assign_trans(const dmatrix & m);
-dvar_matrix nograd_assign(const dmatrix &);
+void save_pointer_value(void * ptr);
+void* restore_pointer_value(void);
+dvar_matrix nograd_assign_trans(const dmatrix& m);
+dvar_matrix nograd_assign(const dmatrix&);
 dvariable nograd_assign(double tmp);
 dvar_vector nograd_assign(dvector tmp);
-dmatrix restore_dvar_matrix_value(const dvar_matrix_position & mpos);
+dmatrix restore_dvar_matrix_value(const dvar_matrix_position& mpos);
 dmatrix_position restore_dmatrix_position(void);
 dvector_position restore_dvector_position(void);
-dvector restore_dvector_value(const dvector_position &);
-dmatrix restore_dmatrix_value(const dmatrix_position &);
-dvector restore_dvar_matrix_derivatives(const dvar_matrix_position & pos,
-					const int &ii);
-dvector restore_dvar_vector_derivatives(const dvar_vector_position & tmp);
-dmatrix restore_dvar_matrix_derivatives(const dvar_matrix_position & pos);
-void save_dmatrix_derivatives(const dvar_matrix_position & pos, double x,
-			      const int &i, int &j);
-dmatrix restore_dvar_matrix_der_nozero(const dvar_matrix_position & pos);
-dvector restore_dvar_vector_der_nozero(const dvar_vector_position & tmp);
+dvector restore_dvector_value(const dvector_position&);
+dmatrix restore_dmatrix_value(const dmatrix_position&);
+dvector restore_dvar_matrix_derivatives(const dvar_matrix_position& pos,const int& ii);
+dvector restore_dvar_vector_derivatives(const dvar_vector_position& tmp);
+dmatrix restore_dvar_matrix_derivatives(const dvar_matrix_position& pos);
+void save_dmatrix_derivatives(const dvar_matrix_position& pos, double x,const int& i,
+  int& j);
+dmatrix restore_dvar_matrix_der_nozero(const dvar_matrix_position& pos);
+dvector restore_dvar_vector_der_nozero(const dvar_vector_position& tmp);
 d3_array_position restore_d3_array_position(void);
-d3_array restore_d3_array_value(const d3_array_position &);
-void nograd_assign_row(const dvar_matrix & m, const dvector & v,
-		       const int &ii);
-void nograd_assign_column(const dvar_matrix & m, const dvector & v,
-			  const int &ii);
+d3_array restore_d3_array_value(const d3_array_position&);
+void nograd_assign_row(const dvar_matrix& m,const dvector& v,const int& ii);
+void nograd_assign_column(const dvar_matrix& m,const dvector& v,const int& ii);
 
 long int reset_gs_stack(void);
 void reset_gs_stack(long int);
 
-dvar_vector solve(const dvar_matrix & aa, const dvar_vector & z);
-dvar_vector solve(const dvar_matrix & aa, const dvar_vector & z,
-		  prevariable & ln_unsigned_det, const prevariable & sign);
+dvar_vector solve(const dvar_matrix& aa,const dvar_vector& z);
+dvar_vector solve(const dvar_matrix& aa,const dvar_vector& z,
+  prevariable& ln_unsigned_det,const prevariable& sign);
+dvar_vector old_solve(const dvar_matrix& aa,const dvar_vector& z,
+  prevariable& ln_unsigned_det,const prevariable& sign);
 
-//dvar_vector solve(const dvar_matrix& aa, const dvar_vector& z,
- // prevariable& ln_unsigned_det, const prevariable& sign);
+dvar_vector solve(const dvar_matrix& aa,const dvar_vector& z,
+  prevariable& ln_unsigned_det,const prevariable& sign);
 
-dvector csolve(const dmatrix & aa, const dvector & z);
-dvector solve(const dmatrix & aa, const dvector & z);
-dvector solve(const dmatrix & aa, const dvector & z,
-	      const double &ln_unsigned_det, double &sign);
+dvector csolve(const dmatrix& aa,const dvector& z);
+dvector solve(const dmatrix& aa,const dvector& z);
+dvector solve(const dmatrix& aa,const dvector& z,
+  const double& ln_unsigned_det,double& sign);
+dvector old_solve(const dmatrix& aa,const dvector& z,
+  const double& ln_unsigned_det,double& sign);
 
-dmatrix choleski_decomp(const dmatrix & M);
-dmatrix choleski_decomp_error(const dmatrix & M, int &ierror);
-dmatrix choleski_decomp_neghess_error(const dmatrix & M, int &ierror);
-dmatrix choleski_decomp_positive(const dmatrix & MM, const int &ierr);
-dmatrix choleski_decomp_positive(const dmatrix & MM, double bound);
-dvar_matrix choleski_decomp(const dvar_matrix & M);
+dmatrix choleski_decomp(const dmatrix& M);
+dmatrix choleski_decomp_error(const dmatrix& M,int& ierror);
+dmatrix choleski_decomp_neghess_error(const dmatrix& M,int& ierror);
+dmatrix choleski_decomp_positive(const dmatrix& MM,const int& ierr);
+dmatrix choleski_decomp_positive(const dmatrix& MM,double bound);
+dvar_matrix choleski_decomp(const dvar_matrix& M);
 
-dvar_matrix solve(const dvar_matrix & aa, const dvar_matrix & zz);
+dvar_matrix solve(const dvar_matrix& aa, const dvar_matrix& zz);
 dmatrix expm(const dmatrix & A);
 dvar_matrix expm(const dvar_matrix & A);
 
-dvariable factln(const dvariable & n);
+dvariable factln(const dvariable& n);
 double factln(double n);
-dvar_vector factln(const dvar_vector & n);
-dvector factln(const dvector & n);
+dvar_vector factln(const dvar_vector& n);
+dvector factln(const dvector& n);
 
-dvar_vector posfun(const dvar_vector & x, double eps,
-		   const prevariable & pen);
-dvariable posfun(const dvariable & x, const double eps,
-		 const prevariable & pen);
-dvariable posfun2(const dvariable & x, const double eps,
-		  const prevariable & pen);
-double posfun(const double &x, const double eps, const double &_pen);
-double posfun2(const double &x, const double eps, const double &_pen);
-double dfposfun(const double &x, const double eps);
-dvariable dfposfun(const prevariable & x, const double eps);
-double dfposfun1(const double &x, const double eps);
-dvar_vector log_comb(const dvar_vector & n, const dvector & k);
-dvariable log_comb(double n, const dvariable & k);
-dvar_vector log_comb(const dvar_vector & n, const dvar_vector & k);
-dvar_vector log_comb(const dvector & n, const dvar_vector & k);
-dvar_vector log_comb(double n, const dvar_vector & k);
-dvar_vector log_comb(const dvariable & n, const dvector & k);
-dvar_vector log_comb(const dvariable & n, const dvar_vector & k);
-dvariable log_comb(const dvariable & n, double k);
-dvariable log_comb(const dvariable & n, const dvariable & k);
-dvector log_comb(const dvector & n, const dvector & k);
-dvector log_comb(double n, const dvector & k);
-double log_comb(double n, double k);
-dmatrix orthpoly(int n, int deg);
-dmatrix orthpoly(int n, int deg, int skip);
-dvar_vector gammln(const dvar_vector & n);
-dvector gammln(const dvector & n);
+dvar_vector posfun(const dvar_vector&x,double eps,const prevariable& pen);
+dvariable posfun(const dvariable&x,const double eps,const prevariable& pen);
+dvariable posfun2(const dvariable&x,const double eps,const prevariable& pen);
+double posfun(const double&x,const double eps,const double& _pen);
+double posfun2(const double&x,const double eps,const double& _pen);
+double dfposfun(const double&x,const double eps);
+dvariable dfposfun(const prevariable&x,const double eps);
+double dfposfun1(const double&x,const double eps);
+dvar_vector log_comb(const dvar_vector& n,const dvector& k);
+dvariable log_comb(double n,const dvariable& k);
+dvar_vector log_comb(const dvar_vector& n,const dvar_vector& k);
+dvar_vector log_comb(const dvector& n,const dvar_vector& k);
+dvar_vector log_comb(double n,const dvar_vector& k);
+dvar_vector log_comb(const dvariable& n,const dvector& k);
+dvar_vector log_comb(const dvariable& n,const dvar_vector& k);
+dvariable log_comb(const dvariable& n,double k);
+dvariable log_comb(const dvariable& n,const dvariable& k);
+dvector log_comb(const dvector& n,const dvector& k);
+dvector log_comb(double n,const dvector& k);
+double log_comb(double n,double k);
+dmatrix orthpoly(int n,int deg);
+dmatrix orthpoly(int n,int deg,int skip);
+dvar_vector gammln(const dvar_vector& n);
+dvector gammln(const dvector& n);
 
 /**
  * Description not yet available.
@@ -5768,23 +5149,17 @@
  */
 class dvar_vector_position
 {
- public:
-   int min;
-   int max;
-   double_and_int *va;
-   int indexmin() const
-   {
-      return min;
-   }
-   int indexmax() const
-   {
-      return max;
-   }
-   dvar_vector_position(const dvar_vector & v);
-   dvar_vector_position(const dvar_vector_position & dvp);
-   dvar_vector_position(void);
-   double &operator() (const int &i);
-   friend class dvar_matrix_position;
+public:
+  int min;
+  int max;
+  double_and_int * va;
+  int indexmin() const {return min;}
+  int indexmax() const {return max;}
+  dvar_vector_position(const dvar_vector& v);
+  dvar_vector_position(const dvar_vector_position& dvp);
+  dvar_vector_position(void);
+  double& operator () (const int& i);
+  friend class dvar_matrix_position;
 };
 
 /**
@@ -5793,40 +5168,27 @@
  */
 class dvar_matrix_position
 {
- public:
-   int row_min;
-   int row_max;
-   ivector lb;
-   ivector ub;
-   ptr_vector ptr;
-   dvar_matrix_position(const dvar_matrix &, int);
-   dvar_matrix_position(int min, int max);
-   dvar_matrix_position(const dvar_matrix_position &);
-   dvar_vector_position operator () (int i);
-   int &rowmin(void)
-   {
-      return row_min;
-   }
-   int &rowmax(void)
-   {
-      return row_max;
-   }
-   ivector & colmin(void)
-   {
-      return lb;
-   }
-   ivector & colmax(void)
-   {
-      return ub;
-   }
-   friend ostream & operator<<(const ostream &,
-			       const dvar_matrix_position &);
-   friend class dmatrix_position;
-   friend class dmatrix;
+public:
+  int row_min;
+  int row_max;
+  ivector lb;
+  ivector ub;
+  ptr_vector ptr;
+  dvar_matrix_position(const dvar_matrix&,int);
+  dvar_matrix_position(int min,int max);
+  dvar_matrix_position(const dvar_matrix_position&);
+  dvar_vector_position operator () (int i);
+  int& rowmin(void){return row_min;}
+  int& rowmax(void){return row_max;}
+  ivector& colmin(void){return lb;}
+  ivector& colmax(void){return ub;}
+  friend ostream& operator << (const ostream&,const dvar_matrix_position&);
+  friend class dmatrix_position;
+  friend class dmatrix;
 };
 
-dvar_matrix use_shape(const dvar_matrix & m);
-dmatrix use_shape(const dmatrix & m);
+dvar_matrix use_shape(const dvar_matrix& m);
+dmatrix use_shape(const dmatrix& m);
 
 /**
  * Description not yet available.
@@ -5834,17 +5196,17 @@
  */
 class dmatrix_position
 {
- public:
-   int row_min;
-   int row_max;
-   ivector lb;
-   ivector ub;
-   ptr_vector ptr;
-   dmatrix_position(const dmatrix &);
-   dmatrix_position(int min, int max);
-   dmatrix_position(const dmatrix_position &);
-   dvector_position operator () (int i);
-   friend class dmatrix;
+public:
+  int row_min;
+  int row_max;
+  ivector lb;
+  ivector ub;
+  ptr_vector ptr;
+  dmatrix_position(const dmatrix&);
+  dmatrix_position(int min,int max);
+  dmatrix_position(const dmatrix_position&);
+  dvector_position operator () (int i);
+  friend class dmatrix;
 };
 
 /**
@@ -5853,19 +5215,13 @@
  */
 class d3_array_position
 {
-   int min;
-   int max;
- public:
-   d3_array_position(int mmin, int mmax);
-
-   int indexmin() const
-   {
-      return min;
-   }
-   int indexmax() const
-   {
-      return max;
-   }
+  int min;
+  int max;
+public:
+  d3_array_position(int mmin,int mmax);
+  
+  int indexmin() const {return min;}
+  int indexmax() const {return max;}
 };
 
 /**
@@ -5874,22 +5230,16 @@
  */
 class dvector_position
 {
-   int min;
-   int max;
-   double *v;
- public:
-   dvector_position(const dvector & v);
-   dvector_position(const dvector_position & dvp);
-   dvector_position(void);
-   int indexmin() const
-   {
-      return min;
-   }
-   int indexmax() const
-   {
-      return max;
-   }
-   friend class dmatrix_position;
+  int min;
+  int max;
+  double * v;
+public:
+  dvector_position(const dvector& v);
+  dvector_position(const dvector_position& dvp);
+  dvector_position(void);
+  int indexmin() const {return min;}
+  int indexmax() const {return max;}
+  friend class dmatrix_position;
 };
 
 /**
@@ -5898,25 +5248,19 @@
  */
 class ivector_position
 {
-   int min;
-   int max;
-   int *v;
- public:
-   ivector_position(void);
-   ivector_position(const ivector & v);
-   ivector_position(const ivector_position & dvp);
-   int indexmin() const
-   {
-      return min;
-   }
-   int indexmax() const
-   {
-      return max;
-   }
+  int min;
+  int max;
+  int * v;
+public:
+  ivector_position(void);
+  ivector_position(const ivector& v);
+  ivector_position(const ivector_position& dvp);
+  int indexmin() const {return min;}
+  int indexmax() const {return max;}
 };
 
-ostream & operator<<(const ostream & s, const ptr_vector & ptr);
-ostream & operator<<(const ostream &, const dvar_matrix_position &);
+ostream& operator << (const ostream& s,const ptr_vector& ptr);
+ostream& operator << (const ostream&,const dvar_matrix_position&);
 
 /**
  * Description not yet available.
@@ -5924,44 +5268,43 @@
  */
 class DF_FILE
 {
- public:
-   char *buff;
+public:
+  char *        buff;
 #ifdef __BORLANDC__
-   unsigned long buff_end;
-   unsigned long buff_size;
+  unsigned long buff_end;
+  unsigned long buff_size;
 #else
-   unsigned long long buff_end;
-   unsigned long long buff_size;
+  unsigned long long   buff_end;
+  unsigned long long  buff_size;
 #endif
-   union
-   {
+  union {
 #ifdef __BORLANDC__
-      unsigned long offset;
+     unsigned long  offset;
 #else
-      unsigned long long offset;
+     unsigned long long  offset;
 #endif
-      char fourb[sizeof(unsigned int)];
-   };
+     char fourb[sizeof(unsigned int)];
+  };
 #ifdef __BORLANDC__
-   unsigned long toffset;
+  unsigned long  toffset;
 #else
-   unsigned long long toffset;
+  unsigned long long  toffset;
 #endif
-   char cmpdif_file_name[81];
-   int file_ptr;
-   DF_FILE(my_u_off_t);
-   ~DF_FILE();
-   void write_cmpdif_stack_buffer(void);
-   void read_cmpdif_stack_buffer(my_off_t & lpos);
-   void fwrite(const void *s, const size_t num_bytes);
-   void fread(void *s, const size_t num_bytes);
-   void fwrite(double);
-   void fwrite(const int &);
-   void fread(const int &);
-   void fread(const double &);
+  char cmpdif_file_name[101];
+  int           file_ptr;
+  DF_FILE(my_u_off_t);
+  ~DF_FILE();
+  void write_cmpdif_stack_buffer(void);
+  void read_cmpdif_stack_buffer(my_off_t& lpos);
+  void fwrite(const void* s,const size_t num_bytes);
+  void fread(void* s,const size_t num_bytes);
+  void fwrite( double);
+  void fwrite(const int&);
+  void fread(const int&);
+  void fread(const double&);
 
-   void fwrite(void *ptr);
-   void fread(void *&ptr);
+  void fwrite(void * ptr);
+  void fread(void* &ptr);
 };
 
 char which_library();
@@ -5970,64 +5313,64 @@
  * Description not yet available.
  * \param
  */
-class fmmq:public fmm_control
+class fmmq : public fmm_control
 {
- private:
-   dvector h;
-   dvector w;
-   dvector funval;
+private:
+  dvector h;
+  dvector w;
+  dvector funval;
 
-   double dmin, fbest, df;
-   long int llog, n1, ic, iconv, i1, link;
-   double z, zz, gys, gs, sig, gso, alpha, tot, fy, dgs;
-   long int itn, icc, np, nn, is, iu, iv, ib, ifn;
-   int i, j;
-   double gmax;
-   double fsave;
-   dvector gbest;
-   dvector xbest;
-   dvector xsave;
-   dvector gsave;
-   dvector scale;
-   dvector xa;
-   dvector xb;
-   dvector d;
-   dvector ga;
-   dvector gb;
-   int mode;
-   int igwindow;
-   int ir;
-   int isfv;
-   int istart;
-   int istop;
-   double c;
-   double cc;
-   double dff;
-   double fa;
-   double fb;
-   double dga;
-   double dgb;
-   double stmin;
-   double stepbd;
-   double tfmin;
-   double gmin;
-   double step;
-   double gl1;
-   double gl2;
-   unsigned int k;
-   int ititle;
-   int print;
-   int ipra;
-   int ip;
-   int n;
- public:
-   fmmq(int nvar);
-   fmmq(int nvar, const lvector & ipar);
-   double minimize(const dvector & x, double (*pf) (const dvar_vector &));
-   double minimize(const independent_variables & x, const dvector & c,
-		   double (*pf) (const dvar_vector &, const dvector &));
-   void fmin(const double &f, const dvector & x, const dvector & g);
-   void va13c(const dvector & x, double f, const dvector & g);
+  double dmin,fbest,df;
+  long int llog,n1,ic,iconv,i1,link;
+  double z,zz,gys,gs,sig,gso,alpha,tot,fy,dgs;
+  long int itn,icc,np,nn,is,iu,iv,ib,ifn;
+  int i, j;
+  double gmax;
+  double fsave;
+  dvector gbest;
+  dvector xbest;
+  dvector xsave;
+  dvector gsave;
+  dvector scale;
+  dvector xa;
+  dvector xb;
+  dvector d;
+  dvector ga;
+  dvector gb;
+  int mode;
+  int igwindow;
+int  ir;
+int isfv;
+int istart;
+int istop;
+double c;
+double cc;
+double dff;
+double fa;
+double fb;
+double dga;
+double dgb;
+double stmin;
+double stepbd;
+double tfmin;
+double gmin;
+double step;
+double gl1;
+double gl2;
+unsigned int k;
+int ititle;
+int print;
+int ipra;
+int ip;
+int n;
+public:
+  fmmq(int nvar);
+  fmmq(int nvar,const lvector& ipar);
+  double minimize(const dvector& x,double (*pf)(const dvar_vector&));
+  double minimize(const independent_variables & x,const dvector& c,
+	double (*pf)(const dvar_vector&,const dvector&) );
+  void fmin(const double& f,const dvector& x,const dvector& g);
+  void va13c (const dvector& x, double f,const dvector& g);
 };
 
 /**
@@ -6036,19 +5379,19 @@
  */
 class vcubic_spline_function
 {
-   dvector x;			// indep variables values
-   dvar_vector y;		// dep variable values
-   dvar_vector y2;		// second derivatives
- public:
-   vcubic_spline_function(const dvector & _x, const dvar_vector & _y,
-			  double yp1 = 0.0, double ypn = 0.0);
-   vcubic_spline_function(const dvector & _x, const dvar_vector & _y,
-			  dvariable yp1, dvariable ypn);
-   vcubic_spline_function(const dvector & _x, const dvar_vector & _y,
-			  dvariable yp1);
-   dvariable operator () (double u);
-   dvar_vector operator () (const dvector & u);
-   dvar_vector operator () (const dvar_vector & u);
+  dvector x;  // indep variables values
+  dvar_vector y;  // dep variable values
+  dvar_vector y2; // second derivatives
+public:
+  vcubic_spline_function(const dvector & _x,const dvar_vector& _y,
+    double yp1=0.0,double ypn=0.0);
+  vcubic_spline_function(const dvector & _x,const dvar_vector& _y,
+    dvariable yp1,dvariable ypn);
+  vcubic_spline_function(const dvector & _x,const dvar_vector& _y,
+    dvariable yp1);
+  dvariable operator () (double u);
+  dvar_vector operator () (const dvector& u);
+  dvar_vector operator () (const dvar_vector& u);
 };
 
 /**
@@ -6057,20 +5400,20 @@
  */
 class cubic_spline_function
 {
-   dvector x;			// indep variables values
-   dvector y;			// dep variable values
-   dvector y2;			// second derivatives
- public:
-   cubic_spline_function(const dvector & _x, const dvector & _y,
-			 double yp1 = 0.0, double ypn = 0.0);
-   double operator () (double u);
-   dvector operator() (const dvector & u);
+  dvector x;  // indep variables values
+  dvector y;  // dep variable values
+  dvector y2; // second derivatives
+public:
+  cubic_spline_function(const dvector & _x,const dvector& _y,
+    double yp1=0.0,double ypn=0.0);
+  double operator () (double u);
+  dvector operator () (const dvector& u);
 };
 
 #ifdef __ZTC__
 #ifndef DOS386
-void *cdecl _farptr_norm(void *);
-void *cdecl _farptr_fromlong(unsigned long int);
+  void * cdecl _farptr_norm(void *);
+  void * cdecl _farptr_fromlong(unsigned long int);
 #endif
 #endif
 /*
@@ -6098,11 +5441,15 @@
 #endif
 */
 
+dvector Lubksb(const dmatrix& a,const ivector&  indx,const dvector&  b);
+
+dmatrix ludcmp(const dmatrix& _a,const ivector& _indx,
+  const double& _det,const double& sgn, const double& _d);
+
 // this is the speical version with an index for reordering the matrix
-void ludcmp_index(const dmatrix & a, const ivector & indx,
-		  const double &d);
+void ludcmp_index(const dmatrix& a,const ivector& indx,const double& d);
 
-void ludcmp(const dmatrix & a, const ivector & indx, const double &d);
+void ludcmp(const dmatrix& a,const ivector& indx,const double& d);
 // this should allways appear at the end of the file
 #if (__BCPLUSPLUS__ >= 2)
 #endif
@@ -6111,53 +5458,53 @@
  * Description not yet available.
  * \param
  */
-class function_tweaker
-{
-   double mult;
-   double eps;
-   dvector coffs;
- public:
-   function_tweaker(double eps, double mult);
-   double operator () (double);
-};
-
+  class function_tweaker
+  {
+    double mult;
+    double eps;
+    dvector coffs;
+  public:
+    function_tweaker(double eps,double mult);
+    double operator () (double);
+  };
+    
 /**
  * Description not yet available.
  * \param
  */
-class dfunction_tweaker
-{
-   double mult;
-   double eps;
-   dvector coffs;
- public:
-   dfunction_tweaker(double eps, double mult);
-   dvariable operator () (const prevariable &);
-};
-
+  class dfunction_tweaker
+  {
+    double mult;
+    double eps;
+    dvector coffs;
+  public:
+    dfunction_tweaker(double eps,double mult);
+    dvariable operator () (const prevariable&);
+  };
+    
 /**
  * Description not yet available.
  * \param
  */
-class four_array_shape
-{
-   unsigned int ncopies;
-   int hslice_min;
-   int hslice_max;
-   //int slice_min;
-   //int slice_max;
-   //int row_min;
-   //int row_max;
-   //int col_min;
-   //int col_max;
-   four_array_shape(int hsl, int hsu);	//, int sl,int sh,int rl,
-   // int ru,int cl,int cu);
-   //mat_shape(){};
+  class four_array_shape
+  {
+    unsigned int ncopies;
+    int hslice_min;
+    int hslice_max;
+    //int slice_min;
+    //int slice_max;
+    //int row_min;
+    //int row_max;
+    //int col_min;
+    //int col_max;
+    four_array_shape(int hsl,int hsu); //, int sl,int sh,int rl,
+      // int ru,int cl,int cu);
+    //mat_shape(){};
 
-   friend class d4_array;
-   friend class dvar4_array;
+    friend class d4_array;
+    friend class dvar4_array;
 
-};				// End of class four_array_shape
+  }; // End of class four_array_shape
 
 /**
  * Description not yet available.
@@ -6165,290 +5512,167 @@
  */
 class d4_array
 {
-   four_array_shape *shape;
-   d3_array *t;
- public:
-   void shallow_copy(const d4_array &);
-   d4_array(int, int);
-   d4_array sub(int, int);
-   void allocate(int hsl, int hsu, int sl, int sh, int nrl,
-		 int nrh, int ncl, int nch);
-   void allocate(int hsl, int hsu, int sl, const ivector & sh, int nrl,
-		 const imatrix & nrh, int ncl, const imatrix & nch);
-   void allocate(int hsl, int hsu, int sl, const ivector & sh, int nrl,
-		 const imatrix & nrh, int ncl, const i3_array & nch);
-   void allocate(int hsl, int hsu, int sl, int sh, int nrl,
-		 int nrh, const ivector & ncl, const ivector & nch);
-   void allocate(int hsl, int hsu, int sl, int sh, const ivector & nrl,
-		 const ivector & nrh, const ivector & ncl,
-		 const ivector & nch);
-   void allocate(int hsl, int hsu, int sl, const ivector & sh, int nrl,
-		 const imatrix & nrh, int ncl, int nch);
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const d4_array &);
-   void allocate(const dvar4_array &);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   d4_array(int hsl, int hsu, int sl, int sh, ivector nrl, ivector nrh,
-	    ivector ncl, ivector nch);
+  four_array_shape * shape;
+  d3_array * t;
+public:
+    void shallow_copy(const d4_array&);
+    d4_array(int,int);
+    d4_array sub(int,int);
+  void allocate(int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch);
+  void allocate(int hsl, int hsu, int sl, const ivector& sh, int nrl,
+                const imatrix& nrh, int ncl, const imatrix& nch);
+  void allocate(int hsl, int hsu, int sl, const ivector& sh, int nrl,
+                const imatrix& nrh, int ncl, const i3_array& nch);
+  void allocate(int hsl,int hsu,int sl,int sh,int nrl,
+                int nrh, const ivector& ncl, const ivector& nch);
+  void allocate(int hsl, int hsu, int sl, int sh, const ivector& nrl,
+                const ivector& nrh, const ivector& ncl, const ivector& nch);
+  void allocate(int hsl, int hsu, int sl, const ivector& sh,
+                int nrl, const imatrix& nrh, int ncl, int nch);
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const d4_array&);
+  void allocate(const dvar4_array&);
+  int operator!(void) const { return (shape == NULL); }
+  d4_array(int hsl,int hsu, int sl,int sh,ivector nrl,ivector nrh,
+    ivector ncl,ivector nch);
 
-   d4_array(int hsl, int hsu, int sl, const ivector & sh, int nrl,
-	    const imatrix & nrh, int ncl, const i3_array & nch);
+  d4_array(int hsl, int hsu, int sl, const ivector& sh, int nrl,
+           const imatrix& nrh, int ncl, const i3_array& nch);
 
-   d4_array(int hsl, int hsu, const index_type & sl,
-	    const index_type & sh, const index_type & nrl,
-	    const index_type & nrh, const index_type & ncl,
-	    const index_type & nch);
+  d4_array(int hsl,int hsu,const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch);
 
-   void allocate(int hsl, int hsu, const index_type & sl,
-		 const index_type & sh, const index_type & nrl,
-		 const index_type & nrh, const index_type & ncl,
-		 const index_type & nch);
-   void allocate(ad_integer hsl, ad_integer hsu, const index_type & sl,
-		 const index_type & sh, const index_type & nrl,
-		 const index_type & nrh, const index_type & ncl,
-		 const index_type & nch);
+  void allocate(int hsl,int hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch);
+  void allocate(ad_integer hsl,ad_integer hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch);
 
-   void allocate(ad_integer hsl, ad_integer hsu, const index_type & sl,
-		 const index_type & sh, const index_type & nrl,
-		 const index_type & nrh);
-   void allocate(ad_integer hsl, ad_integer hsu, const index_type & sl,
-		 const index_type & sh);
-   void allocate(ad_integer hsl, ad_integer hsu);
+  void allocate(ad_integer hsl,ad_integer hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh);
+  void allocate(ad_integer hsl,ad_integer hsu, const index_type& sl,
+    const index_type& sh);
+  void allocate(ad_integer hsl,ad_integer hsu);
 
-   d4_array & operator=(const d4_array &);
-   d4_array(const d4_array & m2);
-   d4_array(int, int, int, int, int, int, int, int);
-   //d4_array(int,int,int,ivector,int,imatrix,int,int);
-   d4_array(int hsl, int hsu, int sl, const ivector & sh,
-	    int nrl, const imatrix & nrh, int ncl, int nch);
-   d4_array();
-   ~d4_array();
-   d3_array & elem(int i)
+  d4_array& operator=(const d4_array&);
+  d4_array(const d4_array& m2);
+  d4_array(int,int,int,int,int,int,int,int);
+  //d4_array(int,int,int,ivector,int,imatrix,int,int);
+  d4_array(int hsl, int hsu, int sl, const ivector& sh,
+           int nrl, const imatrix& nrh, int ncl, int nch);
+  d4_array();
+  ~d4_array();
+   d3_array& elem(int i) { return t[i];}
+   dmatrix& elem (int i ,int j) {return ((*this)(i))(j);}
+   dvector& elem(int i,int j,int k) {return (((*this)(i,j))(k));}
+   double& elem(int i,int j,int k,int l)
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   dmatrix & elem(int i, int j)
+   const d3_array& elem(int i) const { return t[i]; }
+   const dmatrix& elem(int i ,int j) const { return ((*this)(i))(j); }
+   const dvector& elem(int i,int j,int k) const { return (((*this)(i,j))(k)); }
+   const double& elem(int i, int j, int k, int l) const
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i,j,k))(l));
    }
-   dvector & elem(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   double &elem(int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   const d3_array & elem(int i) const
-   {
-      return t[i];
-   }
-   const dmatrix & elem(int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   const dvector & elem(int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
-   const double &elem(int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-#ifdef OPT_LIB
-   d3_array & operator () (int i)
-   {
-      return t[i];
-   }
-   d3_array & operator [](int i)
-   {
-      return t[i];
-   }
-   dmatrix & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   dvector & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   double &operator () (int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-#ifdef USE_CONST
-   inline const d3_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const d3_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const dmatrix & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const dvector & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
-   inline const double &operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const d3_array & operator() (int i) const;
-   const d3_array & operator[] (int i) const;
-   const dmatrix & operator() (int i, int j) const;
-   const dvector & operator() (int i, int j, int k) const;
-   const double &operator() (int i, int j, int k, int l) const;
-#endif
-   d3_array & operator ()(int);
-   d3_array & operator [](int);
-   dmatrix & operator ()(int, int);
-   dvector & operator ()(int, int, int);
-   double &operator () (int, int, int, int);
-#endif
-   //access functions
-   friend class four_array_shape;
+  #ifdef OPT_LIB
+    d3_array& operator ( ) (int i) { return t[i];}
+    d3_array& operator [] (int i) { return t[i];}
+    dmatrix& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    dvector& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    double& operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i,j,k))(l));
+    }
+    #ifdef USE_CONST
+     inline const d3_array& operator()(int i) const { return t[i]; }
+     inline const d3_array& operator[](int i) const { return t[i]; }
+     inline const dmatrix& operator()(int i, int j) const { return ((*this)(i))(j); }
+     inline const dvector& operator()(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+     inline const double& operator()(int i, int j, int k, int l) const
+     {
+       return ( ((*this)(i,j,k))(l));
+     }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const d3_array& operator()(int i) const;
+      const d3_array& operator[](int i) const;
+      const dmatrix& operator()(int i, int j) const;
+      const dvector& operator()(int i, int j, int k) const;
+      const double& operator()(int i, int j, int k, int l) const;
+    #endif
+    d3_array& operator ( ) (int);
+    d3_array& operator [] (int);
+    dmatrix& operator ( ) (int,int);
+    dvector& operator ( ) (int,int,int);
+    double& operator ( ) (int,int,int,int);
+  #endif
+  //access functions
+  friend class four_array_shape;
 
-   int indexmin(void)
-   {
-      return (shape->hslice_min);
-   }
-   int indexmax(void)
-   {
-      return (shape->hslice_max);
-   }
-   int hslicemin(void)
-   {
-      return (shape->hslice_min);
-   }
-   int hslicemax(void)
-   {
-      return (shape->hslice_max);
-   }
-   int slicemin(void)
-   {
-      return ((*this) (hslicemin()).slicemin());
-   }
-   int slicemax(void)
-   {
-      return ((*this) (hslicemin()).slicemax());
-   }
-   int rowmin(void)
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmin());
-   }
-   int rowmax(void)
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmax());
-   }
-   int colmin(void)
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmin());
-   }
-   int colmax(void)
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmax());
-   }
+  int indexmin(void) { return(shape->hslice_min);}
+  int indexmax(void) { return(shape->hslice_max);}
+  int hslicemin(void) { return(shape->hslice_min);}
+  int hslicemax(void) { return(shape->hslice_max);}
+  int slicemin(void) { return((*this)(hslicemin()).slicemin());}
+  int slicemax(void) { return((*this)(hslicemin()).slicemax());}
+  int rowmin(void) { return((*this)(hslicemin(),slicemin()).rowmin());}
+  int rowmax(void) { return((*this)(hslicemin(),slicemin()).rowmax());}
+  int colmin(void) 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmin());
+  }
+  int colmax(void) 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmax());
+  }
 
-   int hslicesize()
-   {
-      return (hslicemax() - hslicemin() + 1);
-   }				// returns the number of rows
-   int slicesize()
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize()
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize()
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-#ifdef USE_CONST
-   int indexmin(void) const
-   {
-      return (shape->hslice_min);
-   }
-   int indexmax(void) const
-   {
-      return (shape->hslice_max);
-   }
-   int hslicemin(void) const
-   {
-      return (shape->hslice_min);
-   }
-   int hslicemax(void) const
-   {
-      return (shape->hslice_max);
-   }
-   int slicemin(void) const
-   {
-      return ((*this) (hslicemin()).slicemin());
-   }
-   int slicemax(void) const
-   {
-      return ((*this) (hslicemin()).slicemax());
-   }
-   int rowmin(void) const
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmin());
-   }
-   int rowmax(void) const
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmax());
-   }
-   int colmin(void) const
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmax());
-   }
+  int hslicesize() {return (hslicemax()-hslicemin()+1);} // returns the number of rows
+  int slicesize() {return (slicemax()-slicemin()+1);} // returns the number of rows
+  int rowsize() {return (rowmax()-rowmin()+1);} // returns the number of rows
+  int colsize() {return (colmax()-colmin()+1);} // returns the number of columns
+ #ifdef USE_CONST
+  int indexmin(void) const { return (shape->hslice_min); }
+  int indexmax(void) const { return (shape->hslice_max); }
+  int hslicemin(void) const { return (shape->hslice_min); }
+  int hslicemax(void) const { return (shape->hslice_max); }
+  int slicemin(void) const { return ((*this)(hslicemin()).slicemin()); }
+  int slicemax(void) const { return ((*this)(hslicemin()).slicemax()); }
+  int rowmin(void) const { return ((*this)(hslicemin(),slicemin()).rowmin()); }
+  int rowmax(void) const { return ((*this)(hslicemin(),slicemin()).rowmax()); }
+  int colmin(void) const 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmin());
+  }
+  int colmax(void) const
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmax());
+  }
 
-   //int hslicemin(void) const { return(shape->hslice_min);}
-   //int hslicemax(void) const { return(shape->hslice_max);}
-   //int slicemin(void) const { return(shape->slice_min);}
-   //int slicemax(void) const { return(shape->slice_max);}
-   //int colmin(void) const { return(shape->col_min);}
-   //int colmax(void) const { return(shape->col_max);}
-   //int rowmin(void) const { return(shape->row_min);}
-   //int rowmax(void) const { return(shape->row_max);}
-   int hslicesize() const
-   {
-      return (hslicemax() - hslicemin() + 1);
-   }				// returns the number of rows
-   int slicesize() const
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize() const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-#endif
-   void initialize(void);
-   void operator /=(double d);
+  //int hslicemin(void) const { return(shape->hslice_min);}
+  //int hslicemax(void) const { return(shape->hslice_max);}
+  //int slicemin(void) const { return(shape->slice_min);}
+  //int slicemax(void) const { return(shape->slice_max);}
+  //int colmin(void) const { return(shape->col_min);}
+  //int colmax(void) const { return(shape->col_max);}
+  //int rowmin(void) const { return(shape->row_min);}
+  //int rowmax(void) const { return(shape->row_max);}
+  int hslicesize() const { return (hslicemax() - hslicemin() + 1); } // returns the number of rows
+  int slicesize() const { return (slicemax() - slicemin() + 1); } // returns the number of rows
+  int rowsize() const { return (rowmax() - rowmin() + 1); } // returns the number of rows
+  int colsize() const { return (colmax() - colmin() + 1); } // returns the number of columns
+ #endif
+  void initialize(void);
+  void operator /= (double d);
 };
-
-d4_array operator/(const d4_array & m, double d);
-d4_array operator/(double d, const d4_array & m);
+  d4_array operator / (const d4_array& m, double d);
+  d4_array operator / ( double d,const d4_array& m);
 #ifndef D4ARR_HPP
 #define D4ARR_HPP
 #endif
@@ -6457,618 +5681,383 @@
  * Description not yet available.
  * \param
  */
+
 class dvar4_array
 {
-   four_array_shape *shape;
-   dvar3_array *t;
- public:
-   void shallow_copy(const dvar4_array &);
-   dvar4_array(int, int);
-   dvar4_array sub(int, int);
-   void allocate(int hsl, int hsu, int sl, int sh, int nrl,
-		 int nrh, int ncl, int nch);
-   void allocate(int hsl, int hsu, int sl, int sh, int nrl,
-		 int nrh, const ivector & ncl, const ivector & nch);
-   void allocate(int hsl, int hsu, int sl, int sh, const ivector & nrl,
-		 const ivector & nrh, const ivector & ncl,
-		 const ivector & nch);
-   void allocate(ad_integer, ad_integer, const index_type &,
-		 const index_type &, const index_type &,
-		 const index_type &, const index_type &,
-		 const index_type &);
-   void allocate(ad_integer, ad_integer, const index_type &,
-		 const index_type &, const index_type &,
-		 const index_type &);
-   void allocate(ad_integer, ad_integer, const index_type &,
-		 const index_type &);
-   void allocate(ad_integer, ad_integer);
+  four_array_shape * shape;
+  dvar3_array * t;
+public:
+    void shallow_copy(const dvar4_array&);
+    dvar4_array(int,int);
+    dvar4_array sub(int,int);
+  void allocate(int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch);
+  void allocate(int hsl,int hsu,int sl,int sh,int nrl,
+                int nrh, const ivector& ncl, const ivector& nch);
+  void allocate(int hsl, int hsu, int sl, int sh, const ivector& nrl,
+                const ivector& nrh, const ivector& ncl, const ivector& nch);
+  void allocate(ad_integer,ad_integer,const index_type&,
+    const index_type&,const index_type&,
+    const index_type&,const index_type&,const index_type&);
+  void allocate(ad_integer,ad_integer,const index_type&,
+    const index_type&,const index_type&,
+    const index_type&);
+  void allocate(ad_integer,ad_integer,const index_type&,const index_type&);
+  void allocate(ad_integer,ad_integer);
 
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const d4_array &);
-   void allocate(const dvar4_array &);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   dvar4_array(int hsl, int hsu, int sl, int sh, ivector nrl, ivector nrh,
-	       ivector ncl, ivector nch);
-   dvar4_array(const d4_array & m1);
-   dvar4_array(const dvar4_array & m2);
-   dvar4_array(int, int, int, int, int, int, int, int);
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const d4_array&);
+  void allocate(const dvar4_array&);
+  int operator!(void) const { return (shape == NULL); }
+  dvar4_array(int hsl,int hsu, int sl,int sh,ivector nrl,ivector nrh,
+    ivector ncl,ivector nch);
+  dvar4_array(const d4_array& m1);
+  dvar4_array(const dvar4_array& m2);
+  dvar4_array(int,int,int,int,int,int,int,int);
+  
+  dvar4_array(ad_integer,ad_integer,const index_type&,const index_type&,const index_type&,
+    const index_type&,const index_type&,const index_type&);
 
-   dvar4_array(ad_integer, ad_integer, const index_type &,
-	       const index_type &, const index_type &, const index_type &,
-	       const index_type &, const index_type &);
-
-   dvar4_array(int hsl, int hsu, int sl, const ivector & sh,
-	       int nrl, const imatrix & nrh, int ncl, int nch);
-   void allocate(int hsl, int hsu, int sl, const ivector & sh,
-		 int nrl, const imatrix & nrh, int ncl, int nch);
-   //dvar4_array(int,int,int,ivector,int,imatrix,int,int);
-   dvar4_array();
-   ~dvar4_array();
-   dvar3_array & elem(int i)
+  dvar4_array(int hsl, int hsu, int sl, const ivector& sh,
+              int nrl, const imatrix& nrh, int ncl, int nch);
+  void allocate(int hsl, int hsu, int sl, const ivector& sh,
+                int nrl, const imatrix& nrh, int ncl, int nch);
+  //dvar4_array(int,int,int,ivector,int,imatrix,int,int);
+  dvar4_array();
+  ~dvar4_array();
+   dvar3_array& elem(int i) { return t[i];}
+   dvar_matrix& elem (int i ,int j) {return ((*this)(i))(j);}
+   dvar_vector& elem(int i,int j,int k) {return (((*this)(i,j))(k));}
+   prevariable elem(int i,int j,int k,int l)
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   dvar_matrix & elem(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   dvar_vector & elem(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   prevariable elem(int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-#ifdef USE_CONST
-   const dvar3_array & elem(int i) const
-   {
-      return t[i];
-   }
-   const dvar_matrix & elem(int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   const dvar_vector & elem(int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
+   #ifdef USE_CONST
+   const dvar3_array& elem(int i) const { return t[i]; }
+   const dvar_matrix& elem(int i, int j) const { return ((*this)(i))(j); }
+   const dvar_vector& elem(int i, int j, int k) const { return (((*this)(i,j))(k)); }
    const prevariable elem(int i, int j, int k, int l) const
    {
-      return (((*this) (i, j, k)) (l));
+     return ( ((*this)(i,j,k))(l));
    }
-#endif				//USE_CONST
+   #endif //USE_CONST
+  
+  d4_array vale(d4_array&);
+  dvar4_array& operator=(const d4_array&);
+  dvar4_array& operator=(const dvar4_array&);
+  #ifdef OPT_LIB
+    dvar3_array& operator ( ) (int i) { return t[i];}
+    dvar3_array& operator [] (int i) { return t[i];}
+    dvar_matrix& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    dvar_vector& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    prevariable operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i,j,k))(l));
+    }
+    #ifdef USE_CONST
+     inline const dvar3_array& operator()(int i) const { return t[i]; }
+     inline const dvar3_array& operator[](int i) const { return t[i]; }
+     inline const dvar_matrix& operator()(int i, int j) const { return ((*this)(i))(j); }
+     inline const dvar_vector& operator()(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+     inline const prevariable operator()(int i, int j, int k, int l) const
+     {
+       return ( ((*this)(i,j,k))(l));
+     }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const dvar3_array& operator()(int i) const;
+      const dvar3_array& operator[](int i) const;
+      const dvar_matrix& operator()(int i, int j) const;
+      const dvar_vector& operator()(int i, int j, int k) const;
+      const prevariable operator()(int i, int j, int k, int l) const;
+    #endif
+    dvar3_array& operator ( ) (int);
+    dvar3_array& operator [] (int);
+    dvar_matrix& operator ( ) (int,int);
+    dvar_vector& operator ( ) (int,int,int);
+    prevariable operator ( ) (int,int,int,int);
+  #endif
+  //access functions
+  friend class four_array_shape;
+  int indexmin(void) { return(shape->hslice_min);}
+  int indexmax(void) { return(shape->hslice_max);}
+  int hslicemin(void) { return(shape->hslice_min);}
+  int hslicemax(void) { return(shape->hslice_max);}
+  int slicemin(void) { return((*this)(hslicemin()).slicemin());}
+  int slicemax(void) { return((*this)(hslicemin()).slicemax());}
+  int rowmin(void) { return((*this)(hslicemin(),slicemin()).rowmin());}
+  int rowmax(void) { return((*this)(hslicemin(),slicemin()).rowmax());}
+  int colmin(void) 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmin());
+  }
+  int colmax(void) 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmax());
+  }
 
-   d4_array vale(d4_array &);
-   dvar4_array & operator=(const d4_array &);
-   dvar4_array & operator=(const dvar4_array &);
-#ifdef OPT_LIB
-   dvar3_array & operator ()(int i)
-   {
-      return t[i];
-   }
-   dvar3_array & operator [](int i)
-   {
-      return t[i];
-   }
-   dvar_matrix & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   dvar_vector & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   prevariable operator () (int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-#ifdef USE_CONST
-   inline const dvar3_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const dvar3_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const dvar_matrix & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const dvar_vector & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
-   inline const prevariable operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const dvar3_array & operator() (int i) const;
-   const dvar3_array & operator[] (int i) const;
-   const dvar_matrix & operator() (int i, int j) const;
-   const dvar_vector & operator() (int i, int j, int k) const;
-   const prevariable operator() (int i, int j, int k, int l) const;
-#endif
-   dvar3_array & operator ()(int);
-   dvar3_array & operator [](int);
-   dvar_matrix & operator ()(int, int);
-   dvar_vector & operator ()(int, int, int);
-   prevariable operator () (int, int, int, int);
-#endif
-   //access functions
-   friend class four_array_shape;
-   int indexmin(void)
-   {
-      return (shape->hslice_min);
-   }
-   int indexmax(void)
-   {
-      return (shape->hslice_max);
-   }
-   int hslicemin(void)
-   {
-      return (shape->hslice_min);
-   }
-   int hslicemax(void)
-   {
-      return (shape->hslice_max);
-   }
-   int slicemin(void)
-   {
-      return ((*this) (hslicemin()).slicemin());
-   }
-   int slicemax(void)
-   {
-      return ((*this) (hslicemin()).slicemax());
-   }
-   int rowmin(void)
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmin());
-   }
-   int rowmax(void)
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmax());
-   }
-   int colmin(void)
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmin());
-   }
-   int colmax(void)
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmax());
-   }
+  //int hslicemin(void) { return(shape->hslice_min);}
+  //int hslicemax(void) { return(shape->hslice_max);}
+  //int slicemin(void) { return(shape->slice_min);}
+  //int slicemax(void) { return(shape->slice_max);}
+  //int colmin(void) { return(shape->col_min);}
+  //int colmax(void) { return(shape->col_max);}
+  //int rowmin(void) { return(shape->row_min);}
+  //int rowmax(void) { return(shape->row_max);}
+  int hslicesize() {return (hslicemax()-hslicemin()+1);} // returns the number of rows
+  int slicesize() {return (slicemax()-slicemin()+1);} // returns the number of rows
+  int rowsize() {return (rowmax()-rowmin()+1);} // returns the number of rows
+  int colsize() {return (colmax()-colmin()+1);} // returns the number of columns
 
-   //int hslicemin(void) { return(shape->hslice_min);}
-   //int hslicemax(void) { return(shape->hslice_max);}
-   //int slicemin(void) { return(shape->slice_min);}
-   //int slicemax(void) { return(shape->slice_max);}
-   //int colmin(void) { return(shape->col_min);}
-   //int colmax(void) { return(shape->col_max);}
-   //int rowmin(void) { return(shape->row_min);}
-   //int rowmax(void) { return(shape->row_max);}
-   int hslicesize()
-   {
-      return (hslicemax() - hslicemin() + 1);
-   }				// returns the number of rows
-   int slicesize()
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize()
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize()
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-
-#ifdef USE_CONST
-   int indexmin(void) const
-   {
-      return (shape->hslice_min);
-   }
-   int indexmax(void) const
-   {
-      return (shape->hslice_max);
-   }
-   int hslicemin(void) const
-   {
-      return (shape->hslice_min);
-   }
-   int hslicemax(void) const
-   {
-      return (shape->hslice_max);
-   }
-   int slicemin(void) const
-   {
-      return ((*this) (hslicemin()).slicemin());
-   }
-   int slicemax(void) const
-   {
-      return ((*this) (hslicemin()).slicemax());
-   }
-   int rowmin(void) const
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmin());
-   }
-   int rowmax(void) const
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmax());
-   }
-   int colmin(void) const
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmax());
-   }
-   //int hslicemin(void) const { return(shape->hslice_min); }
-   //int hslicemax(void) const { return(shape->hslice_max); }
-   //int slicemin(void) const { return(shape->slice_min); }
-   //int slicemax(void) const { return(shape->slice_max); }
-   //int colmin(void) const { return(shape->col_min); }
-   //int colmax(void) const { return(shape->col_max); }
-   //int rowmin(void) const { return(shape->row_min); }
-   //int rowmax(void) const { return(shape->row_max); }
-   int hslicesize() const
-   {
-      return (hslicemax() - hslicemin() + 1);
-   }				// returns the number of rows
-   int slicesize() const
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize() const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-#endif
-   void initialize(void);
-   void operator/=(const prevariable & d);
-   void operator/=(const double &d);
+ #ifdef USE_CONST
+  int indexmin(void) const { return(shape->hslice_min); }
+  int indexmax(void) const { return(shape->hslice_max); }
+  int hslicemin(void) const { return(shape->hslice_min); }
+  int hslicemax(void) const { return(shape->hslice_max); }
+  int slicemin(void) const { return((*this)(hslicemin()).slicemin()); }
+  int slicemax(void) const { return((*this)(hslicemin()).slicemax()); }
+  int rowmin(void) const { return((*this)(hslicemin(),slicemin()).rowmin()); }
+  int rowmax(void) const { return((*this)(hslicemin(),slicemin()).rowmax()); }
+  int colmin(void) const 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmin());
+  }
+  int colmax(void) const 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmax());
+  }
+  //int hslicemin(void) const { return(shape->hslice_min); }
+  //int hslicemax(void) const { return(shape->hslice_max); }
+  //int slicemin(void) const { return(shape->slice_min); }
+  //int slicemax(void) const { return(shape->slice_max); }
+  //int colmin(void) const { return(shape->col_min); }
+  //int colmax(void) const { return(shape->col_max); }
+  //int rowmin(void) const { return(shape->row_min); }
+  //int rowmax(void) const { return(shape->row_max); }
+  int hslicesize() const { return (hslicemax() - hslicemin() + 1); } // returns the number of rows
+  int slicesize() const { return (slicemax() - slicemin() + 1); } // returns the number of rows
+  int rowsize() const { return (rowmax() - rowmin() + 1); } // returns the number of rows
+  int colsize() const { return (colmax() - colmin() + 1); } // returns the number of columns
+ #endif
+  void initialize(void);
+  void operator/=(const prevariable& d);
+  void operator/=(const double& d);
 };
+dvar4_array operator / (const d4_array& m,const prevariable& d);
+dvar4_array operator / (const dvar4_array& m, double d);
+dvar4_array operator / (const dvar4_array& m,const prevariable& d);
 
-dvar4_array operator/(const d4_array & m, const prevariable & d);
-dvar4_array operator/(const dvar4_array & m, double d);
-dvar4_array operator/(const dvar4_array & m, const prevariable & d);
+dvar5_array operator / (const d5_array& m,const prevariable& d);
+dvar5_array operator / (const dvar5_array& m, double d);
+dvar5_array operator / (const dvar5_array& m,const prevariable& d);
 
-dvar5_array operator/(const d5_array & m, const prevariable & d);
-dvar5_array operator/(const dvar5_array & m, double d);
-dvar5_array operator/(const dvar5_array & m, const prevariable & d);
+d4_array log(const d4_array& x);
+dvar4_array log(const dvar4_array& x);
+d4_array mfexp(const d4_array& x);
+dvar4_array mfexp(const dvar4_array& x);
+d4_array exp(const d4_array& x);
+dvar4_array exp(const dvar4_array& x);
+d4_array sqrt(const d4_array& x);
+dvar4_array sqrt(const dvar4_array& x);
 
-d4_array log(const d4_array & x);
-dvar4_array log(const dvar4_array & x);
-d4_array mfexp(const d4_array & x);
-dvar4_array mfexp(const dvar4_array & x);
-d4_array exp(const d4_array & x);
-dvar4_array exp(const dvar4_array & x);
-d4_array sqrt(const d4_array & x);
-dvar4_array sqrt(const dvar4_array & x);
+d5_array log(const d5_array& x);
+dvar5_array log(const dvar5_array& x);
+d5_array mfexp(const d5_array& x);
+dvar5_array mfexp(const dvar5_array& x);
+d5_array exp(const d5_array& x);
+dvar5_array exp(const dvar5_array& x);
+d5_array sqrt(const d5_array& x);
+dvar5_array sqrt(const dvar5_array& x);
 
-d5_array log(const d5_array & x);
-dvar5_array log(const dvar5_array & x);
-d5_array mfexp(const d5_array & x);
-dvar5_array mfexp(const dvar5_array & x);
-d5_array exp(const d5_array & x);
-dvar5_array exp(const dvar5_array & x);
-d5_array sqrt(const d5_array & x);
-dvar5_array sqrt(const dvar5_array & x);
+ostream& operator<<(const ostream& ostr, const d4_array & z);
+ostream& operator<<(const ostream& ostr, const d5_array & z);
+ostream& operator<<(const ostream& ostr, const d6_array & z);
+istream& operator>>(const istream& istr, const d4_array & z);
+istream& operator>>(const istream& istr, const d5_array & z);
+istream& operator>>(const istream& istr, const d6_array & z);
+ostream& operator<<(const ostream& ostr, const dvar4_array & z);
+ostream& operator<<(const ostream& ostr, const dvar5_array & z);
+ostream& operator<<(const ostream& ostr, const dvar6_array & z);
+istream& operator>>(const istream& istr, const dvar4_array & z);
+istream& operator>>(const istream& istr, const dvar5_array & z);
+istream& operator>>(const istream& istr, const dvar6_array & z);
 
-ostream & operator<<(const ostream & ostr, const d4_array & z);
-ostream & operator<<(const ostream & ostr, const d5_array & z);
-ostream & operator<<(const ostream & ostr, const d6_array & z);
-istream & operator>>(const istream & istr, const d4_array & z);
-istream & operator>>(const istream & istr, const d5_array & z);
-istream & operator>>(const istream & istr, const d6_array & z);
-ostream & operator<<(const ostream & ostr, const dvar4_array & z);
-ostream & operator<<(const ostream & ostr, const dvar5_array & z);
-ostream & operator<<(const ostream & ostr, const dvar6_array & z);
-istream & operator>>(const istream & istr, const dvar4_array & z);
-istream & operator>>(const istream & istr, const dvar5_array & z);
-istream & operator>>(const istream & istr, const dvar6_array & z);
-
 /**
  * Description not yet available.
  * \param
  */
-class fmmt:public fmm_control
+class fmmt : public fmm_control
 {
- private:
-   dvector w;
-   dvector funval;
-   int m;
-   int diagco;
- public:
-   double dmin, fbest, df;
-   double gmax;
-   dvector gbest;
-   dvector xbest;
-   dvector diag;
-   double eps;
-   double xtol;
-   double gtol;
-   int nvar;
-   long int iter;
-   int ireturn1;
-   int curriter;
-   ivector iprint1;
+private:
+  dvector w;
+  dvector funval;
+  int m;
+  int diagco;
+public:
+  double dmin,fbest,df;
+  double gmax;
+  dvector gbest;
+  dvector xbest;
+  dvector diag;
+  double eps;
+  double xtol;
+  double gtol;
+  int nvar;
+  long int iter;
+  int ireturn1;
+  int curriter;
+  ivector iprint1;
 
- public:
-   double minimize(const independent_variables & x,
-		   double (*pf) (const dvar_vector &));
-   fmmt(int _nvar, int _m = 7);
+public:
+  double minimize(const independent_variables & x,double (*pf)(const dvar_vector&));
+  fmmt(int _nvar,int _m=7);
 
-   double minimize(const independent_variables & x, const dvector & c,
-		   double (*pf) (const dvar_vector &, const dvector &));
+  double minimize(const independent_variables & x,const dvector& c,
+        double (*pf)(const dvar_vector&,const dvector&) );
 
-   void fmin(const double &f, const dvector & x, const dvector & g);
+  void fmin(const double& f, const dvector & x,const dvector& g);
 
-   dmatrix & hessian();
+  dmatrix& hessian();
 };
 
 /**
  * Description not yet available.
  * \param
  */
+
+
 class i4_array
 {
-   vector_shapex *shape;
-   i3_array *t;
- public:
-   void allocate(int hsl, int hsu, int sl, int sh, int nrl, int nrh,
-		 int ncl, int nch);
+  vector_shapex * shape;
+  i3_array * t;
+public:
+  void allocate(int hsl,int hsu,int sl,int sh,int nrl,int nrh,
+    int ncl,int nch);
 
-   void allocate(const ad_integer & hsl, const ad_integer & hsu,
-		 const index_type & sl, const index_type & sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch);
+  void allocate(const ad_integer& hsl,const ad_integer& hsu,
+    const index_type& sl,const index_type& sh,const index_type& nrl,
+    const index_type& nrh,const index_type& ncl,const index_type& nch);
 
-   void shallow_copy(const i4_array &);
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const i4_array &);
-   void allocate(const dvar4_array &);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   i4_array(int hsl, int hsu, int sl, int sh, ivector nrl, ivector nrh,
-	    ivector ncl, ivector nch);
+  void shallow_copy(const i4_array&);
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const i4_array&);
+  void allocate(const dvar4_array&);
+  int operator!(void) const { return (shape == NULL); }
+  i4_array(int hsl,int hsu, int sl,int sh,ivector nrl,ivector nrh,
+    ivector ncl,ivector nch);
 
-   i4_array(int hsl, int hsu);
-   void allocate(int hsl, int hsu);
+  i4_array(int hsl,int hsu);
+  void allocate(int hsl,int hsu);
 
-   i4_array(int hsl, int hsu, int sl, const ivector & sh, int nrl,
-	    const imatrix & nrh, int ncl, const i3_array & nch);
+  i4_array(int hsl, int hsu, int sl, const ivector& sh, int nrl,
+           const imatrix& nrh, int ncl, const i3_array& nch);
 
-   i4_array(const ad_integer & hsl, const ad_integer & hsh,
-	    const index_type & sl, const index_type & sh,
-	    const index_type & nrl, const index_type & nrh,
-	    const index_type & ncl, const index_type & nch);
-
-   i4_array & operator=(const i4_array &);
-   i4_array(const i4_array & m2);
-   i4_array(int, int, int, int, int, int, int, int);
-   //i4_array(int,int,int,ivector,int,imatrix,int,int);
-   i4_array(int hsl, int hsu, int sl, const ivector & sh,
-	    int nrl, const imatrix & nrh, int ncl, int nch);
-   i4_array();
-   ~i4_array();
-   i3_array & elem(int i)
+  i4_array(const ad_integer& hsl,const ad_integer& hsh,
+   const index_type& sl,const index_type& sh,
+   const index_type& nrl,const index_type& nrh,const index_type& ncl,
+   const index_type& nch);
+ 
+  i4_array& operator=(const i4_array&);
+  i4_array(const i4_array& m2);
+  i4_array(int,int,int,int,int,int,int,int);
+  //i4_array(int,int,int,ivector,int,imatrix,int,int);
+  i4_array(int hsl, int hsu, int sl, const ivector& sh,
+           int nrl, const imatrix& nrh, int ncl, int nch);
+  i4_array();
+  ~i4_array();
+   i3_array& elem(int i) { return t[i];}
+   imatrix& elem (int i ,int j) {return ((*this)(i))(j);}
+   ivector& elem(int i,int j,int k) {return (((*this)(i,j))(k));}
+   int& elem(int i,int j,int k,int l)
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   imatrix & elem(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   ivector & elem(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   int &elem(int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-#ifdef OPT_LIB
-   i3_array & operator ()(int i)
-   {
-      return t[i];
-   }
-   i3_array & operator [](int i)
-   {
-      return t[i];
-   }
-   imatrix & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   ivector & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   int &operator () (int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-#ifdef USE_CONST
-   inline const i3_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const i3_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const imatrix & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const ivector & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
-   inline const int &operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const i3_array & operator() (int i) const;
-   const i3_array & operator[] (int i) const;
-   const imatrix & operator() (int i, int j) const;
-   const ivector & operator() (int i, int j, int k) const;
-   const int &operator() (int i, int j, int k, int l) const;
-#endif
-   i3_array & operator ()(int);
-   i3_array & operator [](int);
-   imatrix & operator ()(int, int);
-   ivector & operator ()(int, int, int);
-   int &operator () (int, int, int, int);
-#endif
-   //access functions
-   friend class four_array_shape;
+  #ifdef OPT_LIB
+    i3_array& operator ( ) (int i) { return t[i];}
+    i3_array& operator [] (int i) { return t[i];}
+    imatrix& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    ivector& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    int& operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i,j,k))(l));
+    }
+    #ifdef USE_CONST
+     inline const i3_array& operator()(int i) const { return t[i]; }
+     inline const i3_array& operator[](int i) const { return t[i]; }
+     inline const imatrix& operator()(int i, int j) const { return ((*this)(i))(j); }
+     inline const ivector& operator()(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+     inline const int& operator()(int i, int j, int k, int l) const
+     {
+       return ( ((*this)(i,j,k))(l));
+     }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const i3_array& operator()(int i) const;
+      const i3_array& operator[](int i) const;
+      const imatrix& operator()(int i, int j) const;
+      const ivector& operator()(int i, int j, int k) const;
+      const int& operator()(int i, int j, int k, int l) const;
+    #endif
+    i3_array& operator ( ) (int);
+    i3_array& operator [] (int);
+    imatrix& operator ( ) (int,int);
+    ivector& operator ( ) (int,int,int);
+    int& operator ( ) (int,int,int,int);
+  #endif
+  //access functions
+  friend class four_array_shape;
 
-   int hslicemin(void)
-   {
-      return (shape->indexmin());
-   }
-   int indexmin(void)
-   {
-      return (shape->indexmin());
-   }
-   int hslicemax(void)
-   {
-      return (shape->indexmax());
-   }
-   int indexmax(void)
-   {
-      return (shape->indexmax());
-   }
-   int slicemin(void)
-   {
-      return ((*this) (hslicemin()).slicemin());
-   }
-   int slicemax(void)
-   {
-      return ((*this) (hslicemin()).slicemax());
-   }
-   int rowmin(void)
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmin());
-   }
-   int rowmax(void)
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmax());
-   }
-   int colmin(void)
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmin());
-   }
-   int colmax(void)
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmax());
-   }
+  int hslicemin(void) { return(shape->indexmin());}
+  int indexmin(void) { return(shape->indexmin());}
+  int hslicemax(void) { return(shape->indexmax());}
+  int indexmax(void) { return(shape->indexmax());}
+  int slicemin(void) { return((*this)(hslicemin()).slicemin());}
+  int slicemax(void) { return((*this)(hslicemin()).slicemax());}
+  int rowmin(void) { return((*this)(hslicemin(),slicemin()).rowmin());}
+  int rowmax(void) { return((*this)(hslicemin(),slicemin()).rowmax());}
+  int colmin(void) 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmin());
+  }
+  int colmax(void) 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmax());
+  }
 
-   int hslicesize()
-   {
-      return (hslicemax() - hslicemin() + 1);
-   }				// returns the number of rows
-   int size()
-   {
-      return (indexmax() - indexmin() + 1);
-   }				// returns the number of rows
-   int slicesize()
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize()
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize()
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-#ifdef USE_CONST
-   int hslicemin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int hslicemax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int slicemin(void) const
-   {
-      return ((*this) (hslicemin()).slicemin());
-   }
-   int slicemax(void) const
-   {
-      return ((*this) (hslicemin()).slicemax());
-   }
-   int rowmin(void) const
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmin());
-   }
-   int rowmax(void) const
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmax());
-   }
-   int colmin(void) const
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmax());
-   }
+  int hslicesize() {return (hslicemax()-hslicemin()+1);} // returns the number of rows
+  int size() {return (indexmax()-indexmin()+1);} // returns the number of rows
+  int slicesize() {return (slicemax()-slicemin()+1);} // returns the number of rows
+  int rowsize() {return (rowmax()-rowmin()+1);} // returns the number of rows
+  int colsize() {return (colmax()-colmin()+1);} // returns the number of columns
+ #ifdef USE_CONST
+  int hslicemin(void) const { return(shape->indexmin()); }
+  int indexmin(void) const { return(shape->indexmin()); }
+  int indexmax(void) const { return(shape->indexmax()); }
+  int hslicemax(void) const { return(shape->indexmax()); }
+  int slicemin(void) const { return((*this)(hslicemin()).slicemin());}
+  int slicemax(void) const { return((*this)(hslicemin()).slicemax()); }
+  int rowmin(void) const { return((*this)(hslicemin(),slicemin()).rowmin()); }
+  int rowmax(void) const { return((*this)(hslicemin(),slicemin()).rowmax()); }
+  int colmin(void) const 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmin());
+  }
+  int colmax(void) const
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmax());
+  }
 
-   int hslicesize() const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-   int size() const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-   int slicesize() const
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize() const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-#endif
-   void initialize(void);
+  int hslicesize() const { return (indexmax() - indexmin() + 1); } 
+  int size() const { return (indexmax() - indexmin() + 1); }
+  int slicesize() const { return (slicemax() - slicemin() + 1); } // returns the number of rows
+  int rowsize() const { return (rowmax() - rowmin() + 1); } // returns the number of rows
+  int colsize() const { return (colmax() - colmin() + 1); } // returns the number of columns
+ #endif
+  void initialize(void);
 };
 
 
@@ -7083,50 +6072,47 @@
  */
 class i5_array
 {
-   vector_shapex *shape;
-   i4_array *t;
- public:
-   void allocate(int hhsl, int hhsu);
+  vector_shapex * shape;
+  i4_array * t;
+public:
+  void allocate(int hhsl,int hhsu);
 
-   void allocate(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh,
-		 int nrl, int nrh, int ncl, int nch);
+  void allocate(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch);
 
-   void allocate(const ad_integer & hsl, const ad_integer & hsu,
-		 const index_type & sl, const index_type & sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch,
-		 const index_type & aa, const index_type & bb);
+  void allocate(const ad_integer& hsl,const ad_integer& hsu,
+    const index_type& sl,const index_type& sh,
+    const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch,
+    const index_type& aa,const index_type& bb);
 
-   void shallow_copy(const i5_array &);
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const i5_array &);
-   //void allocate(const dvar4_array&);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
-   i5_array(int hsl, int hsu);
-   i5_array(int hsl, int hsu, int sl, int sh, ivector nrl, ivector nrh,
-	    ivector ncl, ivector nch);
+  void shallow_copy(const i5_array&);
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const i5_array&);
+  //void allocate(const dvar4_array&);
+  int operator!(void) const { return (shape == NULL); }
+  i5_array(int hsl,int hsu);
+  i5_array(int hsl,int hsu, int sl,int sh,ivector nrl,ivector nrh,
+    ivector ncl,ivector nch);
 
-   i5_array(int hsl, int hsu, int sl, const ivector & sh, int nrl,
-	    const imatrix & nrh, int ncl, const i3_array & nch);
+  i5_array(int hsl, int hsu, int sl, const ivector& sh, int nrl,
+           const imatrix& nrh, int ncl, const i3_array& nch);
 
-   i5_array(const ad_integer & hsl, const ad_integer & hsh,
-	    const index_type & sl, const index_type & sh,
-	    const index_type & nrl, const index_type & nrh,
-	    const index_type & ncl, const index_type & nch,
-	    const index_type & aa, const index_type & bb);
-
-   i5_array & operator=(const i5_array &);
-   i5_array(const i5_array & m2);
-   i5_array(int, int, int, int, int, int, int, int);
-   //i5_array(int,int,int,ivector,int,imatrix,int,int);
-   i5_array(int hsl, int hsu, int sl, const ivector & sh,
-	    int nrl, const imatrix & nrh, int ncl, int nch);
-   i5_array();
-   ~i5_array();
+  i5_array(const ad_integer& hsl,const ad_integer& hsh,
+   const index_type& sl,const index_type& sh,
+   const index_type& nrl,const index_type& nrh,
+   const index_type& ncl,const index_type& nch,
+   const index_type& aa,const index_type& bb);
+ 
+  i5_array& operator=(const i5_array&);
+  i5_array(const i5_array& m2);
+  i5_array(int,int,int,int,int,int,int,int);
+  //i5_array(int,int,int,ivector,int,imatrix,int,int);
+  i5_array(int hsl, int hsu, int sl, const ivector& sh,
+           int nrl, const imatrix& nrh, int ncl, int nch);
+  i5_array();
+  ~i5_array();
    //i4_array& elem(int i) { return t[i];}
    //i3_array& elem (int i ,int j) {return ((*this)(i))(j);}
    int iop(void);
@@ -7135,209 +6121,107 @@
    //ivector& elem(int i,int j,int k,int l)
    int yyy(void);
    //int& elem(int i,int j,int k,int l,int ll) {return( ((*this)(i,j,k))(l,ll));}
-#ifdef OPT_LIB
-   i4_array & operator () (int i)
-   {
-      return t[i];
-   }
-   i4_array & operator [] (int i)
-   {
-      return t[i];
-   }
-   i3_array & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   imatrix & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   ivector & operator ()(int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   int &operator () (int i, int j, int k, int l, int ll)
-   {
-      return (((*this) (i, j, k)) (l, ll));
-   }
-#ifdef USE_CONST
-   inline const i4_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const i4_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const i3_array & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const imatrix & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
-   inline const ivector & operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   inline const int &operator() (int i, int j, int k, int l, int ll) const
-   {
-      return (((*this) (i, j, k)) (l, ll));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const i4_array & operator() (int i) const;
-   const i4_array & operator[] (int i) const;
-   const i3_array & operator() (int i, int j) const;
-   const imatrix & operator() (int i, int j, int k) const;
-   const ivector & operator() (int i, int j, int k, int l) const;
-   const int &operator() (int i, int j, int k, int l, int ll) const;
-#endif
-   i4_array & operator () (int);
-   i4_array & operator [] (int);
-   i3_array & operator () (int, int);
-   imatrix & operator () (int, int, int);
-   ivector & operator () (int, int, int, int);
-   int &operator () (int, int, int, int, int);
-#endif
-   //access functions
-   friend class four_array_shape;
+  #ifdef OPT_LIB
+    i4_array& operator ( ) (int i) { return t[i];}
+    i4_array& operator [] (int i) { return t[i];}
+    i3_array& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    imatrix& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    ivector& operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i,j,k))(l));
+    }
+    int& operator ( ) (int i,int j,int k,int l,int ll)
+    {
+      return ( ((*this)(i,j,k))(l,ll));
+    }
+    #ifdef USE_CONST
+     inline const i4_array& operator()(int i) const { return t[i]; }
+     inline const i4_array& operator[](int i) const { return t[i]; }
+     inline const i3_array& operator()(int i ,int j) const { return ((*this)(i))(j); }
+     inline const imatrix& operator()(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+     inline const ivector& operator()(int i, int j, int k, int l) const
+     {
+       return ( ((*this)(i,j,k))(l));
+     }
+     inline const int& operator()(int i, int j, int k, int l, int ll) const
+     {
+       return ( ((*this)(i,j,k))(l,ll));
+     }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const i4_array& operator()(int i) const;
+      const i4_array& operator[](int i) const;
+      const i3_array& operator()(int i,int j) const;
+      const imatrix& operator()(int i, int j, int k) const;
+      const ivector& operator()(int i, int j, int k, int l) const;
+      const int& operator()(int i, int j, int k, int l, int ll) const;
+    #endif
+    i4_array& operator ( ) (int);
+    i4_array& operator [] (int);
+    i3_array& operator () (int,int);
+    imatrix& operator ( ) (int,int,int);
+    ivector& operator ( ) (int,int,int,int);
+    int& operator ( ) (int,int,int,int,int);
+  #endif
+  //access functions
+  friend class four_array_shape;
 
-   int hslicemin(void)
-   {
-      return (shape->indexmin());
-   }
-   int indexmin(void)
-   {
-      return (shape->indexmin());
-   }
-   int hslicemax(void)
-   {
-      return (shape->indexmax());
-   }
-   int indexmax(void)
-   {
-      return (shape->indexmax());
-   }
-   int slicemin(void)
-   {
-      return ((*this) (hslicemin()).slicemin());
-   }
-   int slicemax(void)
-   {
-      return ((*this) (hslicemin()).slicemax());
-   }
-   int rowmin(void)
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmin());
-   }
-   int rowmax(void)
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmax());
-   }
-   int colmin(void)
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmin());
-   }
-   int colmax(void)
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmax());
-   }
+  int hslicemin(void) { return(shape->indexmin());}
+  int indexmin(void) { return(shape->indexmin());}
+  int hslicemax(void) { return(shape->indexmax());}
+  int indexmax(void) { return(shape->indexmax());}
+  int slicemin(void) { return((*this)(hslicemin()).slicemin());}
+  int slicemax(void) { return((*this)(hslicemin()).slicemax());}
+  int rowmin(void) { return((*this)(hslicemin(),slicemin()).rowmin());}
+  int rowmax(void) { return((*this)(hslicemin(),slicemin()).rowmax());}
+  int colmin(void) 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmin());
+  }
+  int colmax(void) 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmax());
+  }
 
-   int hslicesize()
-   {
-      return (hslicemax() - hslicemin() + 1);
-   }				// returns the number of rows
-   int size()
-   {
-      return (indexmax() - indexmin() + 1);
-   }				// returns the number of rows
-   int slicesize()
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize()
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize()
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-#ifdef USE_CONST
-   int hslicemin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int hslicemax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int slicemin(void) const
-   {
-      return ((*this) (hslicemin()).slicemin());
-   }
-   int slicemax(void) const
-   {
-      return ((*this) (hslicemin()).slicemax());
-   }
-   int rowmin(void) const
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmin());
-   }
-   int rowmax(void) const
-   {
-      return ((*this) (hslicemin(), slicemin()).rowmax());
-   }
-   int colmin(void) const
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmin());
-   }
-   int colmax(void) const
-   {
-      return ((*this) (hslicemin(), slicemin(), rowmax()).indexmax());
-   }
+  int hslicesize() {return (hslicemax()-hslicemin()+1);} // returns the number of rows
+  int size() {return (indexmax()-indexmin()+1);} // returns the number of rows
+  int slicesize() {return (slicemax()-slicemin()+1);} // returns the number of rows
+  int rowsize() {return (rowmax()-rowmin()+1);} // returns the number of rows
+  int colsize() {return (colmax()-colmin()+1);} // returns the number of columns
+ #ifdef USE_CONST
+  int hslicemin(void) const { return(shape->indexmin()); }
+  int indexmin(void) const { return(shape->indexmin()); }
+  int indexmax(void) const { return(shape->indexmax()); }
+  int hslicemax(void) const { return(shape->indexmax()); }
+  int slicemin(void) const { return((*this)(hslicemin()).slicemin()); }
+  int slicemax(void) const { return((*this)(hslicemin()).slicemax()); }
+  int rowmin(void) const { return((*this)(hslicemin(),slicemin()).rowmin()); }
+  int rowmax(void) const { return((*this)(hslicemin(),slicemin()).rowmax()); }
+  int colmin(void) const  
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmin());
+  }
+  int colmax(void) const 
+  { 
+    return((*this)(hslicemin(),slicemin(),rowmax()).indexmax());
+  }
 
-   int hslicesize() const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-   int size() const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-   int slicesize() const
-   {
-      return (slicemax() - slicemin() + 1);
-   }				// returns the number of rows
-   int rowsize() const
-   {
-      return (rowmax() - rowmin() + 1);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (colmax() - colmin() + 1);
-   }				// returns the number of columns
-#endif
-   void initialize(void);
+  int hslicesize() const { return (indexmax() - indexmin() + 1); } 
+  int size() const { return (indexmax() - indexmin() + 1); } 
+  int slicesize() const { return (slicemax() - slicemin() + 1); } // returns the number of rows
+  int rowsize() const { return (rowmax() - rowmin() + 1); } // returns the number of rows
+  int colsize() const { return (colmax()  -colmin() + 1); } // returns the number of columns
+ #endif
+  void initialize(void);
 };
+ostream& operator<<(const ostream& istr, const i5_array& z);
+istream& operator>>(const istream& istr, const i5_array& z);
+#endif  //  if defined(MFCL2_CONSTRUCTORS)
 
-ostream & operator<<(const ostream & istr, const i5_array & z);
-istream & operator>>(const istream & istr, const i5_array & z);
-#endif				//  if defined(MFCL2_CONSTRUCTORS)
+ostream& operator<<(const ostream& istr, const i4_array& z);
+istream& operator>>(const istream& istr, const i4_array& z);
 
-ostream & operator<<(const ostream & istr, const i4_array & z);
-istream & operator>>(const istream & istr, const i4_array & z);
 
 // ***************************************************************
 // ***************************************************************
@@ -7346,186 +6230,120 @@
  * Description not yet available.
  * \param
  */
+
 class d5_array
 {
-   vector_shape *shape;
-   d4_array *t;
- public:
-   d5_array(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh, int nrl,
-	    int nrh, int ncl, int nch);
-   void allocate(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh,
-		 int nrl, int nrh, int ncl, int nch);
+  vector_shape * shape;
+  d4_array * t;
+public:
+  d5_array(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch);
+  void allocate(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch);
 
-   void allocate(int imin, int imax);
-   void shallow_copy(const d5_array &);
-   d5_array(int imin, int imax);
+  void allocate(int imin,int imax);
+  void shallow_copy(const d5_array&);
+  d5_array(int imin,int imax);
 
-   d5_array(const ad_integer & hhsl, const ad_integer & hhsu,
-	    const index_type & hsl, const index_type & hsu,
-	    const index_type & sl, const index_type & sh,
-	    const index_type & nrl, const index_type & nrh,
-	    const index_type & ncl, const index_type & nch);
+  d5_array(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch);
 
-   void allocate(const ad_integer & hhsl, const ad_integer & hhsu,
-		 const index_type & hsl, const index_type & hsu,
-		 const index_type & sl, const index_type & sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch);
+  void allocate(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch);
 
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const d5_array &);
-   //void allocate(const dvar5_array&);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const d5_array&);
+  //void allocate(const dvar5_array&);
+  int operator!(void) const { return (shape == NULL); }
 
-   d5_array & operator=(const d5_array &);
-   d5_array(const d5_array & m2);
-   d5_array();
-   ~d5_array();
-   d4_array & elem(int i)
+  d5_array& operator=(const d5_array&);
+  d5_array(const d5_array& m2);
+  d5_array();
+  ~d5_array();
+   d4_array& elem(int i) { return t[i];}
+   d3_array& elem (int i ,int j) {return ((*this)(i))(j);}
+   dmatrix& elem(int i,int j,int k) {return (((*this)(i,j))(k));}
+   dvector& elem(int i,int j,int k,int l)
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   d3_array & elem(int i, int j)
+   double& elem(int i,int j,int k,int l,int _m)
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i))(j,k,l,_m));
    }
-   dmatrix & elem(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   dvector & elem(int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   double &elem(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
 #  ifdef USE_CONST
-   const d4_array & elem(int i) const
+   const d4_array& elem(int i) const { return t[i]; }
+   const d3_array& elem (int i ,int j) const { return ((*this)(i))(j); }
+   const dmatrix& elem(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+   const dvector& elem(int i, int j, int k, int l) const
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   const d3_array & elem(int i, int j) const
+   const double& elem(int i, int j, int k, int l, int _m) const
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i))(j,k,l,_m));
    }
-   const dmatrix & elem(int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
-   const dvector & elem(int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   const double &elem(int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
 #  endif
-#ifdef OPT_LIB
-   d4_array & operator () (int i)
-   {
-      return t[i];
-   }
-   d4_array & operator [](int i)
-   {
-      return t[i];
-   }
-   d3_array & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   dmatrix & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   dvector & operator ()(int i, int j, int k, int l)
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   double &operator () (int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-#ifdef USE_CONST
-   inline const d4_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const d4_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const d3_array & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const dmatrix & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i)) (j, k));
-   }
-   inline const dvector & operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   inline const double &operator () (int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const d4_array & operator() (int i) const;
-   const d4_array & operator[] (int i) const;
-   const d3_array & operator() (int i, int j) const;
-   const dmatrix & operator() (int i, int j, int k) const;
-   const dvector & operator() (int i, int j, int k, int l) const;
-   const double &operator() (int i, int j, int k, int l, int _m) const;
-#endif
-   d4_array & operator ()(int);
-   d4_array & operator [](int);
-   d3_array & operator ()(int, int);
-   dmatrix & operator ()(int, int, int);
-   dvector & operator ()(int, int, int, int);
-   double &operator () (int, int, int, int, int);
-#endif
-   //access functions
-   int indexmin(void)
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void)
-   {
-      return (shape->indexmax());
-   }
-   int size(void)
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#ifdef USE_CONST
-   int indexmin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int size(void) const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#endif
-   void initialize(void);
-   void operator /=(double d);
+  #ifdef OPT_LIB
+    d4_array& operator ( ) (int i) { return t[i];}
+    d4_array& operator [] (int i) { return t[i];}
+    d3_array& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    dmatrix& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    dvector& operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i))(j,k,l));
+    }
+    double& operator ( ) (int i,int j,int k,int l,int _m)
+    {
+      return ( ((*this)(i))(j,k,l,_m));
+    }
+    #ifdef USE_CONST
+     inline const d4_array& operator()(int i) const { return t[i]; }
+     inline const d4_array& operator[](int i) const { return t[i]; }
+     inline const d3_array& operator()(int i, int j) const {
+       return ((*this)(i))(j); }
+     inline const dmatrix& operator()(int i, int j, int k) const {
+       return (((*this)(i))(j,k));}
+     inline const dvector& operator()(int i, int j, int k, int l) const {
+       return ( ((*this)(i))(j,k,l)); }
+     inline const double& operator ( ) (int i,int j,int k,int l,int _m) const {
+       return ( ((*this)(i))(j,k,l,_m)); }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const d4_array& operator()(int i) const;
+      const d4_array& operator[](int i) const;
+      const d3_array& operator()(int i, int j) const;
+      const dmatrix& operator()(int i, int j, int k) const;
+      const dvector& operator()(int i, int j, int k, int l) const;
+      const double& operator()(int i, int j, int k, int l, int _m) const;
+    #endif
+    d4_array& operator ( ) (int);
+    d4_array& operator [] (int);
+    d3_array& operator ( ) (int,int);
+    dmatrix& operator ( ) (int,int,int);
+    dvector& operator ( ) (int,int,int,int);
+    double& operator ( ) (int,int,int,int,int);
+  #endif
+  //access functions
+  int indexmin(void) { return (shape->indexmin());}
+  int indexmax(void) { return (shape->indexmax());}
+  int size(void) { return (indexmax()-indexmin()+1);}
+ #ifdef USE_CONST
+  int indexmin(void) const { return (shape->indexmin());}
+  int indexmax(void) const { return (shape->indexmax());}
+  int size(void) const { return (indexmax()-indexmin()+1);}
+ #endif
+  void initialize(void);
+  void operator /= ( double d);
 };
 
-d5_array operator/(const d5_array & m, double d);
+d5_array operator/(const d5_array& m, double d);
 
 /**
  * Description not yet available.
@@ -7533,834 +6351,549 @@
  */
 class dvar5_array
 {
-   vector_shape *shape;
-   dvar4_array *t;
- public:
-   void shallow_copy(const dvar5_array &);
-   dvar5_array(int hhsl, int hhsu);
-   dvar5_array sub(int hhsl, int hhsu);
-   dvar5_array(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh,
-	       int nrl, int nrh, int ncl, int nch);
-   void allocate(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh,
-		 int nrl, int nrh, int ncl, int nch);
+  vector_shape * shape;
+  dvar4_array * t;
+public:
+  void shallow_copy(const dvar5_array&);
+  dvar5_array(int hhsl,int hhsu);
+  dvar5_array sub(int hhsl,int hhsu);
+  dvar5_array(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch);
+  void allocate(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch);
 
-   dvar5_array(const ad_integer & hhsl, const ad_integer & hhsu,
-	       const index_type & hsl, const index_type & hsu,
-	       const index_type & sl, const index_type & sh,
-	       const index_type & nrl, const index_type & nrh,
-	       const index_type & ncl, const index_type & nch);
+  dvar5_array(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch);
 
-   void allocate(int imin, int imax);
+  void allocate(int imin,int imax);
 
-   void allocate(const ad_integer & hhsl, const ad_integer & hhsu,
-		 const index_type & hsl, const index_type & hsu,
-		 const index_type & sl, const index_type & sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch);
+  void allocate(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch);
 
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const d5_array &);
-   void allocate(const dvar5_array &);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const d5_array&);
+  void allocate(const dvar5_array&);
+  int operator!(void) const { return (shape == NULL); }
 
-   dvar5_array & operator=(const d5_array &);
-   dvar5_array & operator=(const dvar5_array & m);
-   dvar5_array(const d5_array & m2);
-   dvar5_array(const dvar5_array & m2);
-   dvar5_array();
-   ~dvar5_array();
-   dvar4_array & elem(int i)
+  dvar5_array& operator=(const d5_array&);
+  dvar5_array& operator=(const dvar5_array& m);
+  dvar5_array(const d5_array& m2);
+  dvar5_array(const dvar5_array& m2);
+  dvar5_array();
+  ~dvar5_array();
+   dvar4_array& elem(int i) { return t[i];}
+   dvar3_array& elem (int i ,int j) {return ((*this)(i))(j);}
+   dvar_matrix& elem(int i,int j,int k) {return (((*this)(i,j))(k));}
+   dvar_vector& elem(int i,int j,int k,int l)
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   dvar3_array & elem(int i, int j)
+   prevariable elem(int i,int j,int k,int l,int _m)
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i))(j,k,l,_m));
    }
-   dvar_matrix & elem(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   dvar_vector & elem(int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   prevariable elem(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
 #  ifdef USE_CONST
-   const dvar4_array & elem(int i) const
-   {
-      return t[i];
-   }
-   const dvar3_array & elem(int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   const dvar_matrix & elem(int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
-   const dvar_vector & elem(int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   const prevariable elem(int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
+     const dvar4_array& elem(int i) const { return t[i]; }
+     const dvar3_array& elem(int i, int j) const { return ((*this)(i))(j); }
+     const dvar_matrix& elem(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+     const dvar_vector& elem(int i, int j, int k, int l) const
+     {
+       return ( ((*this)(i,j,k))(l));
+     }
+     const prevariable elem(int i, int j, int k, int l, int _m) const
+     {
+       return ( ((*this)(i))(j,k,l,_m));
+     }
 #  endif
-#ifdef OPT_LIB
-   dvar4_array & operator () (int i)
-   {
-      return t[i];
-   }
-   dvar4_array & operator [](int i)
-   {
-      return t[i];
-   }
-   dvar3_array & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   dvar_matrix & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   dvar_vector & operator ()(int i, int j, int k, int l)
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   prevariable operator () (int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-#ifdef USE_CONST
-   inline const dvar4_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const dvar4_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const dvar3_array & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const dvar_matrix & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i)) (j, k));
-   }
-   inline const dvar_vector & operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   inline const prevariable operator() (int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const dvar4_array & operator() (int i) const;
-   const dvar4_array & operator[] (int i) const;
-   const dvar3_array & operator() (int i, int j) const;
-   const dvar_matrix & operator() (int i, int j, int k) const;
-   const dvar_vector & operator() (int i, int j, int k, int l) const;
-   const prevariable operator() (int i, int j, int k, int l, int _m) const;
-#endif
-   dvar4_array & operator ()(int);
-   dvar4_array & operator [](int);
-   dvar3_array & operator ()(int, int);
-   dvar_matrix & operator ()(int, int, int);
-   dvar_vector & operator ()(int, int, int, int);
-   prevariable operator () (int, int, int, int, int);
-#endif
-   //access functions
-   int indexmin(void)
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void)
-   {
-      return (shape->indexmax());
-   }
-   int size(void)
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#ifdef USE_CONST
-   int indexmin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int size(void) const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#endif
-   void initialize(void);
-   void operator/=(const prevariable & d);
-   void operator/=(const double &d);
+  #ifdef OPT_LIB
+    dvar4_array& operator ( ) (int i) { return t[i];}
+    dvar4_array& operator [] (int i) { return t[i];}
+    dvar3_array& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    dvar_matrix& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    dvar_vector& operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i))(j,k,l));
+    }
+    prevariable operator ( ) (int i,int j,int k,int l,int _m)
+    {
+      return ( ((*this)(i))(j,k,l,_m));
+    }
+    #ifdef USE_CONST
+     inline const dvar4_array& operator()(int i) const { return t[i]; }
+     inline const dvar4_array& operator[](int i) const { return t[i]; }
+     inline const dvar3_array& operator()(int i, int j) const {
+       return ((*this)(i))(j); }
+     inline const dvar_matrix& operator()(int i, int j, int k) const {
+       return (((*this)(i))(j,k));}
+     inline const dvar_vector& operator()(int i, int j, int k, int l) const {
+       return ( ((*this)(i))(j,k,l)); }
+     inline const prevariable operator()(int i, int j, int k, int l, int _m) const {
+       return ( ((*this)(i))(j,k,l,_m)); }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const dvar4_array& operator()(int i) const;
+      const dvar4_array& operator[](int i) const;
+      const dvar3_array& operator()(int i, int j) const;
+      const dvar_matrix& operator()(int i, int j, int k) const;
+      const dvar_vector& operator()(int i, int j, int k, int l) const;
+      const prevariable operator()(int i, int j, int k, int l, int _m) const;
+    #endif
+    dvar4_array& operator ( ) (int);
+    dvar4_array& operator [] (int);
+    dvar3_array& operator ( ) (int,int);
+    dvar_matrix& operator ( ) (int,int,int);
+    dvar_vector& operator ( ) (int,int,int,int);
+    prevariable operator ( ) (int,int,int,int,int);
+  #endif
+  //access functions
+  int indexmin(void) { return (shape->indexmin());}
+  int indexmax(void) { return (shape->indexmax());}
+  int size(void) { return (indexmax()-indexmin()+1);}
+ #ifdef USE_CONST
+  int indexmin(void) const { return (shape->indexmin());}
+  int indexmax(void) const { return (shape->indexmax());}
+  int size(void) const { return (indexmax()-indexmin()+1);}
+ #endif
+  void initialize(void);
+  void operator/=(const prevariable& d);
+  void operator/=(const double& d);
 };
 
-dvar5_array operator/(const d5_array & m, const prevariable & d);
-dvar5_array operator/(const dvar5_array & m, double d);
-dvar5_array operator/(const dvar5_array & m, const prevariable & d);
+dvar5_array operator/(const d5_array& m, const prevariable& d);
+dvar5_array operator/(const dvar5_array& m, double d);
+dvar5_array operator/(const dvar5_array& m, const prevariable& d);
 
 /**
  * Description not yet available.
  * \param
  */
+
 class d6_array
 {
-   vector_shape *shape;
-   d5_array *t;
- public:
-   void shallow_copy(const d6_array &);
-   d6_array(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh, int nrl,
-	    int nrh, int ncl, int nch, int l6, int u6);
-   void allocate(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh,
-		 int nrl, int nrh, int ncl, int nch, int l6, int u6);
+  vector_shape * shape;
+  d5_array * t;
+public:
+  void shallow_copy(const d6_array&);
+  d6_array(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch,int l6,int u6);
+  void allocate(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch,int l6,int u6);
 
-   d6_array(const ad_integer & hhsl, const ad_integer & hhsu,
-	    const index_type & hsl, const index_type & hsu,
-	    const index_type & sl, const index_type & sh,
-	    const index_type & nrl, const index_type & nrh,
-	    const index_type & ncl, const index_type & nch,
-	    const index_type & l6, const index_type & u6);
+  d6_array(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch,
+    const index_type& l6,const index_type& u6);
 
-   void allocate(const ad_integer & hhsl, const ad_integer & hhsu,
-		 const index_type & hsl, const index_type & hsu,
-		 const index_type & sl, const index_type & sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch,
-		 const index_type & l6, const index_type & u6);
+  void allocate(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch,
+    const index_type& l6,const index_type& u6);
 
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const d6_array &);
-   //void allocate(const dvar5_array&);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const d6_array&);
+  //void allocate(const dvar5_array&);
+  int operator!(void) const { return (shape == NULL); }
 
-   d6_array & operator=(const d6_array &);
-   d6_array(const d6_array & m2);
-   d6_array();
-   ~d6_array();
-   d5_array & elem(int i)
+  d6_array& operator=(const d6_array&);
+  d6_array(const d6_array& m2);
+  d6_array();
+  ~d6_array();
+   d5_array& elem(int i) { return t[i];}
+   d4_array& elem (int i ,int j) {return ((*this)(i))(j);}
+   d3_array& elem(int i,int j,int k) {return (((*this)(i,j))(k));}
+   dmatrix& elem(int i,int j,int k,int l)
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   d4_array & elem(int i, int j)
+   dvector& elem(int i,int j,int k,int l,int _m)
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i))(j,k,l,_m));
    }
-   d3_array & elem(int i, int j, int k)
+   double& elem(int i,int j,int k,int l,int _m,int _n)
    {
-      return (((*this) (i, j)) (k));
+     return ( ((*this)(i))(j,k,l,_m,_n));
    }
-   dmatrix & elem(int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   dvector & elem(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   double &elem(int i, int j, int k, int l, int _m, int _n)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
 #  ifdef USE_CONST
-   const d5_array & elem(int i) const
+   const d5_array& elem(int i) const { return t[i]; }
+   const d4_array& elem (int i ,int j) const { return ((*this)(i))(j); }
+   const d3_array& elem(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+   const dmatrix& elem(int i, int j, int k, int l) const
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   const d4_array & elem(int i, int j) const
+   const dvector& elem(int i, int j, int k, int l, int _m) const
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i))(j,k,l,_m));
    }
-   const d3_array & elem(int i, int j, int k) const
+   const double& elem(int i, int j, int k, int l, int _m, int _n) const
    {
-      return (((*this) (i, j)) (k));
+     return ( ((*this)(i))(j,k,l,_m,_n));
    }
-   const dmatrix & elem(int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   const dvector & elem(int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   const double &elem(int i, int j, int k, int l, int _m, int _n) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
 #  endif
-#ifdef OPT_LIB
-   d5_array & operator () (int i)
-   {
-      return t[i];
-   }
-   d5_array & operator [](int i)
-   {
-      return t[i];
-   }
-   d4_array & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   d3_array & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   dmatrix & operator ()(int i, int j, int k, int l)
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   dvector & operator ()(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   double &operator () (int i, int j, int k, int l, int _m, int _n)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-#ifdef USE_CONST
-   inline const d5_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const d5_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const d4_array & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const d3_array & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i)) (j, k));
-   }
-   inline const dmatrix & operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   inline const dvector & operator() (int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   inline const double &operator() (int i, int j, int k, int l, int _m,
-				    int _n) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const d5_array & operator() (int i) const;
-   const d5_array & operator[] (int i) const;
-   const d4_array & operator() (int i, int j) const;
-   const d3_array & operator() (int i, int j, int k) const;
-   const dmatrix & operator() (int i, int j, int k, int l) const;
-   const dvector & operator() (int i, int j, int k, int l, int _m) const;
-   const double &operator() (int i, int j, int k, int l, int _m,
-			     int _n) const;
-#endif
-   d5_array & operator ()(int);
-   d5_array & operator [](int);
-   d4_array & operator ()(int, int);
-   d3_array & operator ()(int, int, int);
-   dmatrix & operator ()(int, int, int, int);
-   dvector & operator ()(int, int, int, int, int);
-   double &operator () (int, int, int, int, int, int);
-#endif
-   //access functions
-   int indexmin(void)
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void)
-   {
-      return (shape->indexmax());
-   }
-   int size(void)
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#ifdef USE_CONST
-   int indexmin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int size(void) const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#endif
-   void initialize(void);
-   void operator /=(double d);
+  #ifdef OPT_LIB
+    d5_array& operator ( ) (int i) { return t[i];}
+    d5_array& operator [] (int i) { return t[i];}
+    d4_array& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    d3_array& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    dmatrix& operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i))(j,k,l));
+    }
+    dvector& operator ( ) (int i,int j,int k,int l,int _m)
+    {
+      return ( ((*this)(i))(j,k,l,_m));
+    }
+    double& operator ( ) (int i,int j,int k,int l,int _m,int _n)
+    {
+      return ( ((*this)(i))(j,k,l,_m,_n));
+    }
+    #ifdef USE_CONST
+     inline const d5_array& operator()(int i) const { return t[i]; }
+     inline const d5_array& operator[](int i) const { return t[i]; }
+     inline const d4_array& operator()(int i, int j) const {
+       return ((*this)(i))(j); }
+     inline const d3_array& operator()(int i, int j, int k) const {
+       return (((*this)(i))(j,k));}
+     inline const dmatrix& operator()(int i, int j, int k, int l) const {
+       return ( ((*this)(i))(j,k,l)); }
+     inline const dvector& operator()(int i, int j, int k, int l, int _m) const {
+       return ( ((*this)(i))(j,k,l,_m)); }
+     inline const double& operator()(int i, int j, int k, int l, int _m, int _n) const {
+       return ( ((*this)(i))(j,k,l,_m,_n)); }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const d5_array& operator()(int i) const;
+      const d5_array& operator[](int i) const;
+      const d4_array& operator()(int i, int j) const;
+      const d3_array& operator()(int i, int j, int k) const;
+      const dmatrix& operator()(int i, int j, int k, int l) const;
+      const dvector& operator()(int i, int j, int k, int l, int _m) const;
+      const double& operator()(int i, int j, int k, int l, int _m, int _n) const;
+    #endif
+    d5_array& operator ( ) (int);
+    d5_array& operator [] (int);
+    d4_array& operator ( ) (int,int);
+    d3_array& operator ( ) (int,int,int);
+    dmatrix& operator ( ) (int,int,int,int);
+    dvector& operator ( ) (int,int,int,int,int);
+    double& operator ( ) (int,int,int,int,int,int);
+  #endif
+  //access functions
+  int indexmin(void) { return (shape->indexmin());}
+  int indexmax(void) { return (shape->indexmax());}
+  int size(void) { return (indexmax()-indexmin()+1);}
+ #ifdef USE_CONST
+  int indexmin(void) const { return (shape->indexmin());}
+  int indexmax(void) const { return (shape->indexmax());}
+  int size(void) const { return (indexmax()-indexmin()+1);}
+ #endif
+  void initialize(void);
+  void operator /= ( double d);
 };
+d6_array operator / (const d6_array& m, double d);
 
-d6_array operator/(const d6_array & m, double d);
-
 /**
  * Description not yet available.
  * \param
  */
+
 class dvar6_array
 {
-   vector_shape *shape;
-   dvar5_array *t;
- public:
-   void shallow_copy(const dvar6_array &);
-   dvar6_array(int hhsl, int hhsu);
-   void allocate(int hhsl, int hhsu);
-   dvar6_array(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh,
-	       int nrl, int nrh, int ncl, int nch, int l6, int u6);
-   void allocate(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh,
-		 int nrl, int nrh, int ncl, int nch, int l6, int u6);
+  vector_shape * shape;
+  dvar5_array * t;
+public:
+  void shallow_copy(const dvar6_array&);
+  dvar6_array(int hhsl,int hhsu);
+  void allocate(int hhsl,int hhsu);
+  dvar6_array(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch,int l6,int u6);
+  void allocate(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch,int l6,int u6);
 
-   dvar6_array(const ad_integer & hhsl, const ad_integer & hhsu,
-	       const index_type & hsl, const index_type & hsu,
-	       const index_type & sl, const index_type & sh,
-	       const index_type & nrl, const index_type & nrh,
-	       const index_type & ncl, const index_type & nch,
-	       const index_type & l6, const index_type & u6);
+  dvar6_array(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch,
+    const index_type& l6,const index_type& u6);
 
-   void allocate(const ad_integer & hhsl, const ad_integer & hhsu,
-		 const index_type & hsl, const index_type & hsu,
-		 const index_type & sl, const index_type & sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch,
-		 const index_type & l6, const index_type & u6);
+  void allocate(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch,
+    const index_type& l6,const index_type& u6);
 
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const d6_array &);
-   void allocate(const dvar6_array &);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const d6_array&);
+  void allocate(const dvar6_array&);
+  int operator!(void) const { return (shape == NULL); }
 
-   dvar6_array & operator=(const d6_array &);
-   dvar6_array & operator=(const dvar6_array & m);
-   dvar6_array(const d6_array & m2);
-   dvar6_array(const dvar6_array & m2);
-   dvar6_array();
-   ~dvar6_array();
-   dvar5_array & elem(int i)
+  dvar6_array& operator=(const d6_array&);
+  dvar6_array& operator=(const dvar6_array& m);
+  dvar6_array(const d6_array& m2);
+  dvar6_array(const dvar6_array& m2);
+  dvar6_array();
+  ~dvar6_array();
+   dvar5_array& elem(int i) { return t[i];}
+   dvar4_array& elem (int i ,int j) {return ((*this)(i))(j);}
+   dvar3_array& elem(int i,int j,int k) {return (((*this)(i,j))(k));}
+   dvar_matrix& elem(int i,int j,int k,int l)
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   dvar4_array & elem(int i, int j)
+   dvar_vector& elem(int i,int j,int k,int l,int _m)
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i))(j,k,l,_m));
    }
-   dvar3_array & elem(int i, int j, int k)
+   prevariable elem(int i,int j,int k,int l,int _m,int _n)
    {
-      return (((*this) (i, j)) (k));
+     return ( ((*this)(i))(j,k,l,_m,_n));
    }
-   dvar_matrix & elem(int i, int j, int k, int l)
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   dvar_vector & elem(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   prevariable elem(int i, int j, int k, int l, int _m, int _n)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
 #  ifdef USE_CONST
-   const dvar5_array & elem(int i) const
-   {
-      return t[i];
-   }
-   const dvar4_array & elem(int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   const dvar3_array & elem(int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
-   const dvar_matrix & elem(int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   const dvar_vector & elem(int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   const prevariable elem(int i, int j, int k, int l, int _m, int _n) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
+     const dvar5_array& elem(int i) const { return t[i]; }
+     const dvar4_array& elem(int i, int j) const { return ((*this)(i))(j); }
+     const dvar3_array& elem(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+     const dvar_matrix& elem(int i, int j, int k, int l) const
+     {
+       return ( ((*this)(i,j,k))(l));
+     }
+     const dvar_vector& elem(int i, int j, int k, int l, int _m) const
+     {
+       return ( ((*this)(i))(j,k,l,_m));
+     }
+     const prevariable elem(int i, int j, int k, int l, int _m, int _n) const
+     {
+       return ( ((*this)(i))(j,k,l,_m,_n));
+     }
 #  endif
-#ifdef OPT_LIB
-   dvar5_array & operator () (int i)
-   {
-      return t[i];
-   }
-   dvar5_array & operator [](int i)
-   {
-      return t[i];
-   }
-   dvar4_array & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   dvar3_array & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   dvar_matrix & operator ()(int i, int j, int k, int l)
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   dvar_vector & operator ()(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   prevariable operator () (int i, int j, int k, int l, int _m, int _n)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-#ifdef USE_CONST
-   inline const dvar5_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const dvar5_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const dvar4_array & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const dvar3_array & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i)) (j, k));
-   }
-   inline const dvar_matrix & operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   inline const dvar_vector & operator() (int i, int j, int k, int l,
-					  int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   inline const prevariable operator() (int i, int j, int k, int l, int _m,
-					int _n) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const dvar5_array & operator() (int i) const;
-   const dvar5_array & operator[] (int i) const;
-   const dvar4_array & operator() (int i, int j) const;
-   const dvar3_array & operator() (int i, int j, int k) const;
-   const dvar_matrix & operator() (int i, int j, int k, int l) const;
-   const dvar_vector & operator() (int i, int j, int k, int l,
-				   int _m) const;
-   const prevariable operator() (int i, int j, int k, int l, int _m,
-				 int _n) const;
-#endif
-   dvar5_array & operator ()(int);
-   dvar5_array & operator [](int);
-   dvar4_array & operator ()(int, int);
-   dvar3_array & operator ()(int, int, int);
-   dvar_matrix & operator ()(int, int, int, int);
-   dvar_vector & operator ()(int, int, int, int, int);
-   prevariable operator () (int, int, int, int, int, int);
-#endif
-   //access functions
-   int indexmin(void)
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void)
-   {
-      return (shape->indexmax());
-   }
-   int size(void)
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#ifdef USE_CONST
-   int indexmin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int size(void) const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#endif
-   void initialize(void);
-   void operator/=(const prevariable & d);
-   void operator/=(const double &d);
+  #ifdef OPT_LIB
+    dvar5_array& operator ( ) (int i) { return t[i];}
+    dvar5_array& operator [] (int i) { return t[i];}
+    dvar4_array& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    dvar3_array& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    dvar_matrix& operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i))(j,k,l));
+    }
+    dvar_vector& operator ( ) (int i,int j,int k,int l,int _m)
+    {
+      return ( ((*this)(i))(j,k,l,_m));
+    }
+    prevariable operator ( ) (int i,int j,int k,int l,int _m,int _n)
+    {
+      return ( ((*this)(i))(j,k,l,_m,_n));
+    }
+    #ifdef USE_CONST
+     inline const dvar5_array& operator()(int i) const { return t[i];}
+     inline const dvar5_array& operator[](int i) const { return t[i];}
+     inline const dvar4_array& operator()(int i, int j) const {
+       return ((*this)(i))(j); }
+     inline const dvar3_array& operator()(int i, int j, int k) const {
+       return (((*this)(i))(j,k));}
+     inline const dvar_matrix& operator()(int i, int j, int k, int l) const {
+       return ( ((*this)(i))(j,k,l)); }
+     inline const dvar_vector& operator()(int i, int j, int k, int l, int _m) const {
+       return ( ((*this)(i))(j,k,l,_m)); }
+     inline const prevariable operator()(int i, int j, int k, int l, int _m, int _n) const {
+       return ( ((*this)(i))(j,k,l,_m,_n)); }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const dvar5_array& operator()(int i) const;
+      const dvar5_array& operator[](int i) const;
+      const dvar4_array& operator()(int i, int j) const;
+      const dvar3_array& operator()(int i, int j, int k) const;
+      const dvar_matrix& operator()(int i, int j, int k, int l) const;
+      const dvar_vector& operator()(int i, int j, int k, int l, int _m) const;
+      const prevariable operator()(int i, int j, int k, int l, int _m, int _n) const;
+    #endif
+    dvar5_array& operator ( ) (int);
+    dvar5_array& operator [] (int);
+    dvar4_array& operator ( ) (int,int);
+    dvar3_array& operator ( ) (int,int,int);
+    dvar_matrix& operator ( ) (int,int,int,int);
+    dvar_vector& operator ( ) (int,int,int,int,int);
+    prevariable operator ( ) (int,int,int,int,int,int);
+  #endif
+  //access functions
+  int indexmin(void) { return (shape->indexmin());}
+  int indexmax(void) { return (shape->indexmax());}
+  int size(void) { return (indexmax()-indexmin()+1);}
+ #ifdef USE_CONST
+  int indexmin(void) const { return (shape->indexmin());}
+  int indexmax(void) const { return (shape->indexmax());}
+  int size(void) const { return (indexmax()-indexmin()+1);}
+ #endif
+  void initialize(void);
+  void operator/=(const prevariable& d);
+  void operator/=(const double& d);
 };
 
-dvar6_array operator/(const d6_array & m, const prevariable & d);
-dvar6_array operator/(const dvar6_array & m, double d);
-dvar6_array operator/(const dvar6_array & m, const prevariable & d);
+dvar6_array operator/(const d6_array& m, const prevariable& d);
+dvar6_array operator/(const dvar6_array& m, double d);
+dvar6_array operator/(const dvar6_array& m, const prevariable& d);
 
 /**
  * Description not yet available.
  * \param
  */
+
 class d7_array
 {
-   vector_shape *shape;
-   d6_array *t;
- public:
-   void allocate(int l7, int u7);
-   d7_array(int l7, int u7, int hhsl, int hhsu, int hsl, int hsu, int sl,
-	    int sh, int nrl, int nrh, int ncl, int nch, int l6, int u6);
-   void allocate(int l7, int u7, int hhsl, int hhsu, int hsl, int hsu,
-		 int sl, int sh, int nrl, int nrh, int ncl, int nch,
-		 int l6, int u6);
+  vector_shape * shape;
+  d6_array * t;
+public:
+  void allocate(int l7,int u7);
+  d7_array(int l7,int u7,int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,
+    int nrl,int nrh,int ncl,int nch,int l6,int u6);
+  void allocate(int l7,int u7,int hhsl,int hhsu,int hsl,int hsu,int sl,
+    int sh,int nrl,int nrh,int ncl,int nch,int l6,int u6);
 
-   d7_array(const ad_integer & hhsl, const ad_integer & hhsu,
-	    const index_type & l7, const index_type & u7,
-	    const index_type & hsl, const index_type & hsu,
-	    const index_type & sl, const index_type & sh,
-	    const index_type & nrl, const index_type & nrh,
-	    const index_type & ncl, const index_type & nch,
-	    const index_type & l6, const index_type & u6);
+  d7_array(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& l7,const index_type& u7, 
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch,
+    const index_type& l6,const index_type& u6);
 
-   void allocate(const ad_integer & hhsl, const ad_integer & hhsu,
-		 const index_type & l7, const index_type & u7,
-		 const index_type & hsl, const index_type & hsu,
-		 const index_type & sl, const index_type & sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch,
-		 const index_type & l6, const index_type & u6);
+  void allocate(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& l7,const index_type& u7,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch,
+    const index_type& l6,const index_type& u6);
 
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const d7_array &);
-   //void allocate(const dvar5_array&);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const d7_array&);
+  //void allocate(const dvar5_array&);
+  int operator!(void) const { return (shape == NULL); }
 
-   d7_array & operator=(const d7_array &);
-   d7_array(d7_array & m2);
-   d7_array();
-   ~d7_array();
-   d6_array & elem(int i)
+  d7_array& operator=(const d7_array&);
+  d7_array(d7_array& m2);
+  d7_array();
+  ~d7_array();
+   d6_array& elem(int i) { return t[i];}
+   d5_array& elem (int i ,int j) {return ((*this)(i))(j);}
+   d4_array& elem(int i,int j,int k) {return (((*this)(i,j))(k));}
+   d3_array& elem(int i,int j,int k,int l)
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   d5_array & elem(int i, int j)
+   dmatrix& elem(int i,int j,int k,int l,int _m)
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i))(j,k,l,_m));
    }
-   d4_array & elem(int i, int j, int k)
+   dvector& elem(int i,int j,int k,int l,int _m,int _n)
    {
-      return (((*this) (i, j)) (k));
+     return ( ((*this)(i))(j,k,l,_m,_n));
    }
-   d3_array & elem(int i, int j, int k, int l)
+   double& elem(int i,int j,int k,int l,int _m,int _n,int _p)
    {
-      return (((*this) (i, j, k)) (l));
+     return ( ((*this)(i))(j,k,l,_m,_n,_p));
    }
-   dmatrix & elem(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   dvector & elem(int i, int j, int k, int l, int _m, int _n)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-   double &elem(int i, int j, int k, int l, int _m, int _n, int _p)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n, _p));
-   }
 #  ifdef USE_CONST
-   const d6_array & elem(int i) const
+   const d6_array& elem(int i) const { return t[i];}
+   const d5_array& elem(int i, int j) const { return ((*this)(i))(j); }
+   const d4_array& elem(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+   const d3_array& elem(int i, int j, int k, int l) const
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   const d5_array & elem(int i, int j) const
+   const dmatrix& elem(int i, int j, int k, int l, int _m) const
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i))(j,k,l,_m));
    }
-   const d4_array & elem(int i, int j, int k) const
+   const dvector& elem(int i, int j, int k, int l, int _m, int _n) const
    {
-      return (((*this) (i, j)) (k));
+     return ( ((*this)(i))(j,k,l,_m,_n));
    }
-   const d3_array & elem(int i, int j, int k, int l) const
+   const double& elem(int i, int j, int k, int l, int _m, int _n, int _p) const
    {
-      return (((*this) (i, j, k)) (l));
+     return ( ((*this)(i))(j,k,l,_m,_n,_p));
    }
-   const dmatrix & elem(int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   const dvector & elem(int i, int j, int k, int l, int _m, int _n) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-   const double &elem(int i, int j, int k, int l, int _m, int _n, int _p) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n, _p));
-   }
 #  endif
-#ifdef OPT_LIB
-   d6_array & operator () (int i)
-   {
-      return t[i];
-   }
-   d6_array & operator [](int i)
-   {
-      return t[i];
-   }
-   d5_array & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   d4_array & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   d3_array & operator ()(int i, int j, int k, int l)
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   dmatrix & operator ()(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   dvector & operator ()(int i, int j, int k, int l, int _m, int _n)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-   double &operator () (int i, int j, int k, int l, int _m, int _n, int _p)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n, _p));
-   }
-#ifdef USE_CONST
-   inline const d6_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const d6_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const d5_array & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const d4_array & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i)) (j, k));
-   }
-   inline const d3_array & operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   inline const dmatrix & operator() (int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   inline const dvector & operator() (int i, int j, int k, int l, int _m,
-				      int _n) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-   inline const double &operator() (int i, int j, int k, int l, int _m,
-				    int _n, int _p) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n, _p));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const d6_array & operator() (int i) const;
-   const d6_array & operator[] (int i) const;
-   const d5_array & operator() (int i, int j) const;
-   const d4_array & operator() (int i, int j, int k) const;
-   const d3_array & operator() (int i, int j, int k, int l) const;
-   const dmatrix & operator() (int i, int j, int k, int l, int _m) const;
-   const dvector & operator() (int i, int j, int k, int l, int _m,
-			       int _n) const;
-   const double &operator() (int i, int j, int k, int l, int _m, int _n,
-			     int _p) const;
-#endif
-   d6_array & operator ()(int);
-   d6_array & operator [](int);
-   d5_array & operator ()(int, int);
-   d4_array & operator ()(int, int, int);
-   d3_array & operator ()(int, int, int, int);
-   dmatrix & operator ()(int, int, int, int, int);
-   dvector & operator ()(int, int, int, int, int, int);
-   double &operator () (int, int, int, int, int, int, int);
-#endif
-   //access functions
-   int indexmin(void)
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void)
-   {
-      return (shape->indexmax());
-   }
-   int size(void)
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#ifdef USE_CONST
-   int indexmin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int size(void) const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#endif
-   void initialize(void);
-   void operator /=(double d);
+  #ifdef OPT_LIB
+    d6_array& operator ( ) (int i) { return t[i];}
+    d6_array& operator [] (int i) { return t[i];}
+    d5_array& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    d4_array& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    d3_array& operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i))(j,k,l));
+    }
+    dmatrix& operator ( ) (int i,int j,int k,int l,int _m)
+    {
+      return ( ((*this)(i))(j,k,l,_m));
+    }
+    dvector& operator ( ) (int i,int j,int k,int l,int _m,int _n)
+    {
+      return ( ((*this)(i))(j,k,l,_m,_n));
+    }
+    double& operator ( ) (int i,int j,int k,int l,int _m,int _n,int _p)
+    {
+      return ( ((*this)(i))(j,k,l,_m,_n,_p));
+    }
+    #ifdef USE_CONST
+     inline const d6_array& operator()(int i) const { return t[i]; }
+     inline const d6_array& operator[](int i) const { return t[i]; }
+     inline const d5_array& operator()(int i, int j) const {
+       return ((*this)(i))(j); }
+     inline const d4_array& operator()(int i, int j, int k) const {
+       return (((*this)(i))(j,k));}
+     inline const d3_array& operator()(int i, int j, int k, int l) const {
+       return ( ((*this)(i))(j,k,l)); }
+     inline const dmatrix& operator()(int i, int j, int k, int l, int _m) const {
+       return ( ((*this)(i))(j,k,l,_m)); }
+     inline const dvector& operator()(int i, int j, int k, int l, int _m, int _n) const {
+       return ( ((*this)(i))(j,k,l,_m,_n)); }
+     inline const double& operator()(int i, int j, int k, int l, int _m, int _n, int _p) const {
+       return ( ((*this)(i))(j,k,l,_m,_n,_p)); }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const d6_array& operator()(int i) const;
+      const d6_array& operator[](int i) const;
+      const d5_array& operator()(int i, int j) const;
+      const d4_array& operator()(int i, int j, int k) const;
+      const d3_array& operator()(int i, int j, int k, int l) const;
+      const dmatrix& operator()(int i, int j, int k, int l, int _m) const;
+      const dvector& operator()(int i, int j, int k, int l, int _m, int _n) const;
+      const double& operator()(int i, int j, int k, int l, int _m, int _n, int _p) const;
+    #endif
+    d6_array& operator ( ) (int);
+    d6_array& operator [] (int);
+    d5_array& operator ( ) (int,int);
+    d4_array& operator ( ) (int,int,int);
+    d3_array& operator ( ) (int,int,int,int);
+    dmatrix& operator ( ) (int,int,int,int,int);
+    dvector& operator ( ) (int,int,int,int,int,int);
+    double& operator ( ) (int,int,int,int,int,int,int);
+  #endif
+  //access functions
+  int indexmin(void) { return (shape->indexmin());}
+  int indexmax(void) { return (shape->indexmax());}
+  int size(void) { return (indexmax()-indexmin()+1);}
+ #ifdef USE_CONST
+  int indexmin(void) const { return (shape->indexmin());}
+  int indexmax(void) const { return (shape->indexmax());}
+  int size(void) const { return (indexmax()-indexmin()+1);}
+ #endif
+  void initialize(void);
+  void operator /= ( double d);
 };
 
-d7_array operator/(const d7_array & m, double d);
+d7_array operator/(const d7_array& m, double d);
 
 /**
  * Description not yet available.
@@ -8368,240 +6901,160 @@
  */
 class dvar7_array
 {
-   vector_shape *shape;
-   dvar6_array *t;
- public:
-   dvar7_array(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh,
-	       int nrl, int nrh, int ncl, int nch, int l6, int u6, int l7,
-	       int u7);
-   void allocate(int hhsl, int hhsu);
-   void allocate(int hhsl, int hhsu, int hsl, int hsu, int sl, int sh,
-		 int nrl, int nrh, int ncl, int nch, int l6, int u6,
-		 int l7, int u7);
+  vector_shape * shape;
+  dvar6_array * t;
+public:
+  dvar7_array(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch,int l6,int u6,int l7,int u7);
+  void allocate(int hhsl,int hhsu);
+  void allocate(int hhsl,int hhsu,int hsl,int hsu,int sl,int sh,int nrl,
+    int nrh,int ncl,int nch,int l6,int u6,int l7,int u7);
 
-   dvar7_array(const ad_integer & hhsl, const ad_integer & hhsu,
-	       const index_type & l7, const index_type & u7,
-	       const index_type & hsl, const index_type & hsu,
-	       const index_type & sl, const index_type & sh,
-	       const index_type & nrl, const index_type & nrh,
-	       const index_type & ncl, const index_type & nch,
-	       const index_type & l6, const index_type & u6);
+  dvar7_array(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& l7,const index_type& u7,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch,
+    const index_type& l6,const index_type& u6);
 
-   void allocate(const ad_integer & hhsl, const ad_integer & hhsu,
-		 const index_type & l7, const index_type & u7,
-		 const index_type & hsl, const index_type & hsu,
-		 const index_type & sl, const index_type & sh,
-		 const index_type & nrl, const index_type & nrh,
-		 const index_type & ncl, const index_type & nch,
-		 const index_type & l6, const index_type & u6);
+  void allocate(const ad_integer& hhsl,const ad_integer& hhsu,
+    const index_type& l7,const index_type& u7,
+    const index_type& hsl,const index_type& hsu, const index_type& sl,
+    const index_type& sh,const index_type& nrl,const index_type& nrh,
+    const index_type& ncl,const index_type& nch,
+    const index_type& l6,const index_type& u6);
 
-   void deallocate(void);
-   void allocate(void);
-   void allocate(const d7_array &);
-   void allocate(const dvar7_array &);
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+  void deallocate(void);
+  void allocate(void);
+  void allocate(const d7_array&);
+  void allocate(const dvar7_array&);
+  int operator!(void) const { return (shape == NULL); }
 
-   dvar7_array & operator=(const d7_array &);
-   dvar7_array & operator=(const dvar7_array & m);
-   dvar7_array(d7_array & m2);
-   dvar7_array(dvar7_array & m2);
-   dvar7_array();
-   ~dvar7_array();
-   dvar6_array & elem(int i)
+  dvar7_array& operator=(const d7_array&);
+  dvar7_array& operator=(const dvar7_array& m);
+  dvar7_array(d7_array& m2);
+  dvar7_array(dvar7_array& m2);
+  dvar7_array();
+  ~dvar7_array();
+   dvar6_array& elem(int i) { return t[i];}
+   dvar5_array& elem (int i ,int j) {return ((*this)(i))(j);}
+   dvar4_array& elem(int i,int j,int k) {return (((*this)(i,j))(k));}
+   dvar3_array& elem(int i,int j,int k,int l)
    {
-      return t[i];
+     return ( ((*this)(i,j,k))(l));
    }
-   dvar5_array & elem(int i, int j)
+   dvar_matrix& elem(int i,int j,int k,int l,int _m)
    {
-      return ((*this) (i)) (j);
+     return ( ((*this)(i))(j,k,l,_m));
    }
-   dvar4_array & elem(int i, int j, int k)
+   dvar_vector& elem(int i,int j,int k,int l,int _m,int _n)
    {
-      return (((*this) (i, j)) (k));
+     return ( ((*this)(i))(j,k,l,_m,_n));
    }
-   dvar3_array & elem(int i, int j, int k, int l)
+   prevariable elem(int i,int j,int k,int l,int _m,int _n,int _p)
    {
-      return (((*this) (i, j, k)) (l));
+     return ( ((*this)(i))(j,k,l,_m,_n,_p));
    }
-   dvar_matrix & elem(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   dvar_vector & elem(int i, int j, int k, int l, int _m, int _n)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-   prevariable elem(int i, int j, int k, int l, int _m, int _n, int _p)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n, _p));
-   }
 #  ifdef USE_CONST
-   const dvar6_array & elem(int i) const
-   {
-      return t[i];
-   }
-   const dvar5_array & elem(int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   const dvar4_array & elem(int i, int j, int k) const
-   {
-      return (((*this) (i, j)) (k));
-   }
-   const dvar3_array & elem(int i, int j, int k, int l) const
-   {
-      return (((*this) (i, j, k)) (l));
-   }
-   const dvar_matrix & elem(int i, int j, int k, int l, int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   const dvar_vector & elem(int i, int j, int k, int l, int _m, int _n) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-   const prevariable elem(int i, int j, int k, int l, int _m, int _n,
-			  int _p) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n, _p));
-   }
+     const dvar6_array& elem(int i) const { return t[i]; }
+     const dvar5_array& elem(int i, int j) const { return ((*this)(i))(j); }
+     const dvar4_array& elem(int i, int j, int k) const { return (((*this)(i,j))(k)); }
+     const dvar3_array& elem(int i, int j, int k, int l) const
+     {
+       return ( ((*this)(i,j,k))(l));
+     }
+     const dvar_matrix& elem(int i, int j, int k, int l, int _m) const
+     {
+       return ( ((*this)(i))(j,k,l,_m));
+     }
+     const dvar_vector& elem(int i, int j, int k, int l, int _m, int _n) const
+     {
+       return ( ((*this)(i))(j,k,l,_m,_n));
+     }
+     const prevariable elem(int i, int j, int k, int l, int _m, int _n, int _p) const
+     {
+       return ( ((*this)(i))(j,k,l,_m,_n,_p));
+     }
 #  endif
-#ifdef OPT_LIB
-   dvar6_array & operator () (int i)
-   {
-      return t[i];
-   }
-   dvar6_array & operator [](int i)
-   {
-      return t[i];
-   }
-   dvar5_array & operator ()(int i, int j)
-   {
-      return ((*this) (i)) (j);
-   }
-   dvar4_array & operator ()(int i, int j, int k)
-   {
-      return (((*this) (i, j)) (k));
-   }
-   dvar3_array & operator ()(int i, int j, int k, int l)
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   dvar_matrix & operator ()(int i, int j, int k, int l, int _m)
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   dvar_vector & operator ()(int i, int j, int k, int l, int _m, int _n)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-   prevariable operator () (int i, int j, int k, int l, int _m, int _n,
-			    int _p)
-   {
-      return (((*this) (i)) (j, k, l, _m, _n, _p));
-   }
-#ifdef USE_CONST
-   inline const dvar6_array & operator() (int i) const
-   {
-      return t[i];
-   }
-   inline const dvar6_array & operator[] (int i) const
-   {
-      return t[i];
-   }
-   inline const dvar5_array & operator() (int i, int j) const
-   {
-      return ((*this) (i)) (j);
-   }
-   inline const dvar4_array & operator() (int i, int j, int k) const
-   {
-      return (((*this) (i)) (j, k));
-   }
-   inline const dvar3_array & operator() (int i, int j, int k, int l) const
-   {
-      return (((*this) (i)) (j, k, l));
-   }
-   inline const dvar_matrix & operator() (int i, int j, int k, int l,
-					  int _m) const
-   {
-      return (((*this) (i)) (j, k, l, _m));
-   }
-   inline const dvar_vector & operator() (int i, int j, int k, int l,
-					  int _m, int _n) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n));
-   }
-   inline const prevariable operator() (int i, int j, int k, int l, int _m,
-					int _n, int _p) const
-   {
-      return (((*this) (i)) (j, k, l, _m, _n, _p));
-   }
-#endif
-#else
-#ifdef USE_CONST
-   const dvar6_array & operator() (int i) const;
-   const dvar6_array & operator[] (int i) const;
-   const dvar5_array & operator() (int i, int j) const;
-   const dvar4_array & operator() (int i, int j, int k) const;
-   const dvar3_array & operator() (int i, int j, int k, int l) const;
-   const dvar_matrix & operator() (int i, int j, int k, int l,
-				   int _m) const;
-   const dvar_vector & operator() (int i, int j, int k, int l, int _m,
-				   int _n) const;
-   const prevariable operator() (int i, int j, int k, int l, int _m,
-				 int _n, int _p) const;
-#endif
-   dvar6_array & operator ()(int);
-   dvar6_array & operator [](int);
-   dvar5_array & operator ()(int, int);
-   dvar4_array & operator ()(int, int, int);
-   dvar3_array & operator ()(int, int, int, int);
-   dvar_matrix & operator ()(int, int, int, int, int);
-   dvar_vector & operator ()(int, int, int, int, int, int);
-   prevariable operator () (int, int, int, int, int, int, int);
-#endif
-   //access functions
-   int indexmin(void)
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void)
-   {
-      return (shape->indexmax());
-   }
-   int size(void)
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#ifdef USE_CONST
-   int indexmin(void) const
-   {
-      return (shape->indexmin());
-   }
-   int indexmax(void) const
-   {
-      return (shape->indexmax());
-   }
-   int size(void) const
-   {
-      return (indexmax() - indexmin() + 1);
-   }
-#endif
-   void initialize(void);
-   void operator/=(const prevariable & d);
-   void operator/=(const double &d);
+  #ifdef OPT_LIB
+    dvar6_array& operator ( ) (int i) { return t[i];}
+    dvar6_array& operator [] (int i) { return t[i];}
+    dvar5_array& operator ( ) (int i ,int j) {return ((*this)(i))(j);}
+    dvar4_array& operator ( ) (int i,int j,int k) {return (((*this)(i,j))(k));}
+    dvar3_array& operator ( ) (int i,int j,int k,int l)
+    {
+      return ( ((*this)(i))(j,k,l));
+    }
+    dvar_matrix& operator ( ) (int i,int j,int k,int l,int _m)
+    {
+      return ( ((*this)(i))(j,k,l,_m));
+    }
+    dvar_vector& operator ( ) (int i,int j,int k,int l,int _m,int _n)
+    {
+      return ( ((*this)(i))(j,k,l,_m,_n));
+    }
+    prevariable operator ( ) (int i,int j,int k,int l,int _m,int _n,int _p)
+    {
+      return ( ((*this)(i))(j,k,l,_m,_n,_p));
+    }
+    #ifdef USE_CONST
+     inline const dvar6_array& operator()(int i) const { return t[i]; }
+     inline const dvar6_array& operator[](int i) const { return t[i]; }
+     inline const dvar5_array& operator()(int i, int j) const {
+       return ((*this)(i))(j); }
+     inline const dvar4_array& operator()(int i, int j, int k) const {
+       return (((*this)(i))(j,k));}
+     inline const dvar3_array& operator()(int i, int j, int k, int l) const {
+       return ( ((*this)(i))(j,k,l)); }
+     inline const dvar_matrix& operator()(int i, int j, int k, int l, int _m) const {
+       return ( ((*this)(i))(j,k,l,_m)); }
+     inline const dvar_vector& operator()(int i, int j, int k, int l, int _m, int _n) const {
+       return ( ((*this)(i))(j,k,l,_m,_n)); }
+     inline const prevariable operator()(int i, int j, int k, int l, int _m, int _n, int _p) const {
+       return ( ((*this)(i))(j,k,l,_m,_n,_p)); }
+    #endif
+  #else
+    #ifdef USE_CONST
+      const dvar6_array& operator()(int i) const;
+      const dvar6_array& operator[](int i) const;
+      const dvar5_array& operator()(int i, int j) const;
+      const dvar4_array& operator()(int i, int j, int k) const;
+      const dvar3_array& operator()(int i, int j, int k, int l) const;
+      const dvar_matrix& operator()(int i, int j, int k, int l, int _m) const;
+      const dvar_vector& operator()(int i, int j, int k, int l, int _m, int _n) const;
+      const prevariable operator()(int i, int j, int k, int l, int _m, int _n, int _p) const;
+    #endif
+    dvar6_array& operator ( ) (int);
+    dvar6_array& operator [] (int);
+    dvar5_array& operator ( ) (int,int);
+    dvar4_array& operator ( ) (int,int,int);
+    dvar3_array& operator ( ) (int,int,int,int);
+    dvar_matrix& operator ( ) (int,int,int,int,int);
+    dvar_vector& operator ( ) (int,int,int,int,int,int);
+    prevariable operator ( ) (int,int,int,int,int,int,int);
+  #endif
+  //access functions
+  int indexmin(void) { return (shape->indexmin());}
+  int indexmax(void) { return (shape->indexmax());}
+  int size(void) { return (indexmax()-indexmin()+1);}
+ #ifdef USE_CONST
+  int indexmin(void) const { return (shape->indexmin());}
+  int indexmax(void) const { return (shape->indexmax());}
+  int size(void) const { return (indexmax()-indexmin()+1);}
+ #endif
+  void initialize(void);
+  void operator/=(const prevariable& d);
+  void operator/=(const double& d);
 };
 
-dvar7_array operator/(const d7_array & m, const prevariable & d);
-dvar7_array operator/(const dvar7_array & m, double d);
-dvar7_array operator/(const dvar7_array & m, const prevariable & d);
+dvar7_array operator/(const d7_array& m, const prevariable& d);
+dvar7_array operator/(const dvar7_array& m, double d);
+dvar7_array operator/(const dvar7_array& m, const prevariable& d);
 
 
-#endif				// #if defined(USE_HIGHER_ARRAYS)
 
+#endif // #if defined(USE_HIGHER_ARRAYS)
+
 class lmatrix;
 
 /**
@@ -8610,177 +7063,136 @@
  */
 class lmatrix_position
 {
- public:
-   int row_min;
-   int row_max;
-   ivector lb;
-   ivector ub;
-   ptr_vector ptr;
-   lmatrix_position(const lmatrix &);
-   lmatrix_position(int min, int max);
-   lmatrix_position(const lmatrix_position &);
-   lvector_position operator () (int i);
+public:
+  int row_min;
+  int row_max;
+  ivector lb;
+  ivector ub;
+  ptr_vector ptr;
+  lmatrix_position(const lmatrix&);
+  lmatrix_position(int min,int max);
+  lmatrix_position(const lmatrix_position&);
+  lvector_position operator () (int i);
 };
 
 lmatrix_position restore_lmatrix_position(void);
-lmatrix restore_lmatrix_value(const lmatrix_position &);
+lmatrix restore_lmatrix_value(const lmatrix_position&);
 
 /**
  * Description not yet available.
  * \param
  */
-class lmatrix
-{
- protected:
-   lvector * m;
-   mat_shape *shape;
-   friend char *fform(const char *, const dmatrix &);
 
+ class lmatrix
+ {
+  protected:
+    lvector * m;
+    mat_shape * shape;
+    friend char* fform(const char*, const dmatrix&);
+
  public:
 
-   int operator!(void) const
-   {
-      return (shape == NULL);
-   }
+    int operator!(void) const { return (shape == NULL); }
 
-   lmatrix(int, int);
-   // makes a matrix [0..nr][0..nc]
+    lmatrix( int ,  int );
+              // makes a matrix [0..nr][0..nc]
 
-   lmatrix(int, int, int, int);
-   // makes a matrix [nrl..nrh][ncl..nch]
-   lmatrix(int, int, int, const ivector &);
-   lmatrix(int, int, const ivector &, const ivector &);
-   lmatrix(const ad_integer & nrl, const ad_integer & nrh,
-	   const index_type & ncl, const index_type & nch);
+    lmatrix( int,  int,  int,  int );
+             // makes a matrix [nrl..nrh][ncl..nch]
+    lmatrix(int, int, int, const ivector&);
+    lmatrix(int, int, const ivector&, const ivector&);
+    lmatrix(const ad_integer& nrl,const ad_integer& nrh,
+      const index_type& ncl,const index_type& nch);
 
-   lmatrix & operator=(const lmatrix & t);
-   lmatrix & operator=(const imatrix & t);
-   lmatrix(const lmatrix &);
-   // copy initializer
-   lmatrix(const lmatrix_position &);
-   lmatrix(void);
+    lmatrix& operator=(const lmatrix& t);
+    lmatrix& operator=(const imatrix& t);
+    lmatrix(const lmatrix&);
+             // copy initializer
+    lmatrix(const lmatrix_position&);
+    lmatrix(void);
 
    ~lmatrix();
 
-   void save_lmatrix_value(void);
-   void save_lmatrix_position(void);
-   lmatrix restore_lmatrix_value(const lmatrix_position & mpos);
-   lmatrix_position restore_lmatrix_position(void);
+    void save_lmatrix_value(void);
+    void save_lmatrix_position(void);
+    lmatrix restore_lmatrix_value(const lmatrix_position& mpos);
+    lmatrix_position restore_lmatrix_position(void);
 
-   void allocate(const lmatrix & dm);
-   void allocate(int nrl, int nrh, int ncl, int nch);
-   void allocate(int nrl, int nrh, int ncl, const ivector & nch);
-   void allocate(int nrl, int nrh, const ivector & ncl,
-		 const ivector & nch);
-   void allocate(const ad_integer & nrl, const ad_integer & nrh,
-		 const index_type & ncl, const index_type & nch);
-   void deallocate();
+    void allocate(const lmatrix& dm);
+    void allocate(int nrl,int nrh,int ncl,int nch);
+    void allocate(int nrl,int nrh,int ncl,const ivector& nch);
+    void allocate(int nrl,int nrh,const ivector& ncl,const ivector& nch);
+    void allocate(const ad_integer& nrl,const ad_integer& nrh,
+      const index_type& ncl,const index_type& nch);
+    void deallocate();
 
 #ifdef OPT_LIB
-   inline lvector & operator() (int i)
-   {
-      return m[i];
-   }
-   inline AD_LONG_INT & operator() (int i, int j)
-   {
-      return (*((*(m + i)).v + j));
-   }
-   inline lvector & operator[] (int i)
-   {
-      return m[i];
-   }
+ inline lvector& operator() (int i) {return m[i];}
+ inline AD_LONG_INT& operator() (int i,int j) {return(*((*(m+i)).v+j));}
+ inline lvector& operator[] (int i) {return m[i];}
 #else
-   lvector & operator [] (int);
-   lvector & operator () (int);
-   AD_LONG_INT & operator () (int, int);
+  lvector& operator [] (int);
+  lvector& operator () (int);
+  AD_LONG_INT& operator () (int,int);
 #endif
 
 #ifdef USE_CONST
-#ifdef OPT_LIB
-   inline const lvector & operator() (int i) const
-   {
-      return m[i];
-   }
-   inline const AD_LONG_INT & operator() (int i, int j) const
-   {
-      return (*((*(m + i)).v + j));
-   }
-   inline const lvector & operator[] (int i) const
-   {
-      return m[i];
-   }
-#else
-   const lvector & operator[] (int) const;
-   const lvector & operator() (int) const;
-   const AD_LONG_INT & operator() (int, int) const;
+ #ifdef OPT_LIB
+  inline const lvector& operator()(int i) const { return m[i]; }
+  inline const AD_LONG_INT& operator()(int i, int j) const
+    {return(*((*(m+i)).v+j));}
+  inline const lvector& operator[](int i) const { return m[i]; }
+ #else
+    const lvector& operator[](int) const;
+    const lvector& operator()(int) const;
+    const AD_LONG_INT& operator()(int, int) const;
 #endif
 #endif
 
-   int colmin(void) const
-   {
-      return (shape->col_min);
-   }
-   int colmax(void) const
-   {
-      return (shape->col_max);
-   }
-   int rowmin(void) const
-   {
-      return (shape->row_min);
-   }
-   int rowmax(void) const
-   {
-      return (shape->row_max);
-   }
-   int rowsize() const
-   {
-      return (shape->nrows);
-   }				// returns the number of rows
-   int colsize() const
-   {
-      return (shape->ncols);
-   }				// returns the number of columns
+    int colmin(void) const { return (shape->col_min); }
+    int colmax(void) const { return (shape->col_max); }
+    int rowmin(void) const { return (shape->row_min); }
+    int rowmax(void) const { return (shape->row_max); }
+    int rowsize() const { return (shape->nrows); } // returns the number of rows
+    int colsize() const { return (shape->ncols); } // returns the number of columns
 
-   void write_on(const ostream &) const;
-   void write_on(const uostream &) const;
-   void read_from(const istream &);
-   void read_from(const uistream &);
-   void initialize(void);
-   friend class i3_array;
-};				//end of class lmatrix
-
+    void write_on(const ostream&) const;
+    void write_on(const uostream&) const;
+    void read_from(const istream&);
+    void read_from(const uistream&);
+    void initialize(void);
+    friend class i3_array;
+}; //end of class lmatrix
 // void dmatrix::allocate(int nrl,int nrh,const index_type& ncl,
   // const index_type& nch)
-class index_guts;
-class index_type;
-class number_index;
-class vector_index;
-class matrix_index;
-class i3_index;
+  class index_guts;
+  class index_type;
+  class number_index;
+  class vector_index;
+  class matrix_index;
+  class i3_index;
 
 /**
  * Description not yet available.
  * \param
  */
-class adkludge
-{
-   char x;
-};
+  class adkludge
+  {
+    char x;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class pre_index_type
-{
-   const index_type *a;
-   int i;
- public:
-   pre_index_type(const index_type * _a, int _i):a(_a), i(_i)
-   {
-   }
-   friend class index_type;
-};
+  class pre_index_type
+  {
+    const index_type * a;
+    int i;
+  public:
+    pre_index_type( const index_type * _a, int _i) : a(_a) , i(_i) {}
+    friend class index_type;
+  };
 
 class data_int;
 
@@ -8788,281 +7200,185 @@
  * Description not yet available.
  * \param
  */
-class ad_integer
-{
- protected:
-   int d;
- public:
-   operator  int () const
-   {
-      return d;
-   }
-   //operator int () { return d;}
-   ad_integer(const int &_d, const adkludge & k):d(_d)
-   {
-   }
-   ad_integer(int _d):d(_d)
-   {
-   }
-   ad_integer(const index_type & it);
-   ad_integer make_ad_integer(int _d)
-   {
-      adkludge adk;
-      return ad_integer(d, adk);
-   }
+  class ad_integer
+  {
+  protected:
+    int d;
+  public:
+    operator int () const { return d;}
+    //operator int () { return d;}
+    ad_integer(const int& _d, const adkludge& k) : d(_d) {}
+    ad_integer(int _d) : d(_d) {}
+    ad_integer(const index_type& it);
+    ad_integer make_ad_integer(int _d) { adkludge adk; return ad_integer(d, adk);}
 #if defined(_MSC_VER)
 //#  if (_MSC_VER  < 1200)
-   ad_integer(const data_int & _d);
+    ad_integer(const data_int& _d);
 //#  endif
 #else
-   ad_integer(const data_int & _d);
+    ad_integer(const data_int& _d);
 #endif
-};
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class index_guts
-{
-   friend class ad_integer;
- protected:
-   int *ncopies;
- public:
-   virtual index_guts * operator [] (int) = 0;
-   virtual int isinteger(void) const
-   {
-      return 1;
-   }
-   virtual int dimension(void) const
-   {
-      return -1;
-   }
-   virtual operator  int ()
-   {
-      cerr << "Error in index_type"
-	 " -- object not dereferenced enough" << endl;
-      ad_exit(1);
-      return 1;
-   }
-   virtual int indexmin(void) = 0;
-   virtual int indexmax(void) = 0;
-   index_guts();
-   index_guts(const index_guts & ig);
-   virtual ~ index_guts();
-   friend class index_type;
-};
+  class index_guts
+  {
+    friend class ad_integer;
+  protected:
+    int * ncopies;
+  public:
+    virtual index_guts * operator [] (int) = 0;
+    virtual int  isinteger(void) const { return 1;}
+    virtual int  dimension (void) const { return -1;}
+    virtual operator int () { cerr << "Error in index_type"
+     " -- object not dereferenced enough" << endl; ad_exit(1); return 1;}
+    virtual int indexmin(void)=0;
+    virtual int indexmax(void)=0;
+    index_guts(); 
+    index_guts(const index_guts& ig);
+    virtual ~index_guts();
+    friend class index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class index_type:public smart_counter
-{
-   index_guts *p;
- public:
-   int integer(void) const;
-   int isinteger(void) const
-   {
-      return p->isinteger();
-   }
-   int dimension(void) const
-   {
-      return p->dimension();
-   }
-   index_type(int x);
-   //index_type(const data_int& x);
-   index_type(const ivector & x);
-   index_type(const imatrix & x);
-   index_type(const i3_array & x);
-   index_type(const i4_array & x);
-   index_type(const pre_index_type & pit);
-   index_type(const index_type & pit);
-   //index_type (i4_array& x) { p = new i4_index(x);}
-   ~index_type();
-   index_type operator [] (int i);
-   index_type operator () (int i);
-   index_type operator [] (int i) const;
-   index_type operator () (int i) const;
-   int indexmin(void) const
-   {
-      return p->indexmin();
-   }
-   int indexmax(void) const
-   {
-      return p->indexmax();
-   }
-   friend class ad_integer;
-};
+  class index_type : public smart_counter
+  {
+    index_guts * p;
+  public:
+    int integer(void) const;
+    int isinteger(void) const { return p->isinteger();}
+    int dimension(void) const { return p->dimension();}
+    index_type(int x);
+    //index_type(const data_int& x);
+    index_type(const ivector& x);
+    index_type(const imatrix& x);
+    index_type(const i3_array& x);
+    index_type(const i4_array& x);
+    index_type(const pre_index_type& pit);
+    index_type(const index_type& pit);
+    //index_type (i4_array& x) { p = new i4_index(x);}
+    ~index_type ();
+    index_type operator [] (int i);
+    index_type operator () (int i);
+    index_type operator [] (int i) const; 
+    index_type operator () (int i) const; 
+    int indexmin(void) const { return p->indexmin();}
+    int indexmax(void) const { return p->indexmax();}
+    friend class ad_integer;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class number_index:public ad_integer, public index_guts
-{
- private:
-   virtual int isinteger(void) const
-   {
-      return 0;
-   }
-   virtual int dimension(void) const
-   {
-      return 0;
-   }
-   virtual index_guts *operator [] (int i);
-   virtual int indexmin(void)
-   {
-      return 1;
-   }
-   virtual int indexmax(void)
-   {
-      return 1;
-   }
- public:
-   virtual ~ number_index()
-   {
-   }
- number_index(int i):ad_integer(i)
-   {
-   }
-   // only overload this for number_index ... will fail for other classes 
-   virtual operator  int ()
-   {
-      return d;
-   }
-   friend class index_type;
-};
+  class number_index : public ad_integer, public index_guts
+  {
+  private:
+    virtual int  isinteger(void) const { return 0;}
+    virtual int  dimension(void) const { return 0;}
+    virtual index_guts * operator [] (int i);
+    virtual int indexmin(void){return 1;}
+    virtual int indexmax(void){return 1;}
+  public:
+    virtual ~number_index() {}
+    number_index(int i) : ad_integer(i) {}
+    // only overload this for number_index ... will fail for other classes 
+    virtual operator int () { return d;} 
+    friend class index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class vector_index:public ivector, public index_guts
-{
-   virtual index_guts *operator [] (int i)
-   {
+  class vector_index : public ivector, public index_guts
+  {
+    virtual index_guts * operator [] (int i)
+    {
       return new number_index(ivector::operator [](i));
-   }
- public:
-   virtual int dimension(void) const
-   {
-      return 1;
-   }
-   //vector_index(const ivector& v) : ivector(v){}
-   vector_index(const ivector & v);
-   virtual ~ vector_index();
-   virtual int indexmin(void)
-   {
-      return ivector::indexmin();
-   }
-   virtual int indexmax(void)
-   {
-      return ivector::indexmax();
-   }
-   friend class index_type;
-};
+    }
+  public:
+    virtual int  dimension(void) const { return 1;}
+    //vector_index(const ivector& v) : ivector(v){}
+    vector_index(const ivector& v);
+    virtual ~vector_index();
+    virtual int indexmin(void){return ivector::indexmin();}
+    virtual int indexmax(void){return ivector::indexmax();}
+    friend class index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class matrix_index:public imatrix, public index_guts
-{
- private:
-   virtual index_guts * operator [] (int i);
-   //{
-   //  return new vector_index(imatrix::operator [](i));
-   //}
- public:
-   virtual int dimension(void) const
-   {
-      return 2;
-   }
-   virtual ~ matrix_index();
-   matrix_index(const imatrix & v):imatrix(v)
-   {
-   }
-   virtual int indexmin(void)
-   {
-      return imatrix::rowmin();
-   }
-   virtual int indexmax(void)
-   {
-      return imatrix::rowmax();
-   }
-   friend class index_type;
-};
+  class matrix_index : public imatrix, public index_guts
+  {
+  private:
+    virtual index_guts * operator [] (int i);
+    //{
+    //  return new vector_index(imatrix::operator [](i));
+    //}
+  public:
+    virtual int  dimension(void) const { return 2;}
+    virtual ~matrix_index();
+    matrix_index(const imatrix& v) : imatrix(v){}
+    virtual int indexmin(void){return imatrix::rowmin();}
+    virtual int indexmax(void){return imatrix::rowmax();}
+    friend class index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class i3_index:public i3_array, public index_guts
-{
-   virtual index_guts *operator [] (int i)
-   {
+  class i3_index : public i3_array, public index_guts
+  {
+    virtual index_guts * operator [] (int i)
+    {
       return new matrix_index(i3_array::operator [](i));
-   }
- public:
-   i3_index(i3_array & v):i3_array(v)
-   {
-   }
-   virtual int dimension(void) const
-   {
-      return 3;
-   }
-   virtual int indexmin(void)
-   {
-      return i3_array::slicemin();
-   }
-   virtual int indexmax(void)
-   {
-      return i3_array::slicemax();
-   }
-   friend class index_type;
-};
+    }
+  public:
+    i3_index(i3_array& v) : i3_array(v){}
+    virtual int  dimension(void) const { return 3;}
+    virtual int indexmin(void){return i3_array::slicemin();}
+    virtual int indexmax(void){return i3_array::slicemax();}
+    friend class index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class i4_index:public i4_array, public index_guts
-{
-   virtual index_guts *operator [] (int i)
-   {
+  class i4_index : public i4_array, public index_guts
+  {
+    virtual index_guts * operator [] (int i)
+    {
       return new i3_index(i4_array::operator [](i));
-   }
- public:
-   virtual int dimension(void) const
-   {
-      return 4;
-   }
-   i4_index(i4_array & v):i4_array(v)
-   {
-   }
-   virtual int indexmin(void)
-   {
-      return i4_array::slicemin();
-   }
-   virtual int indexmax(void)
-   {
-      return i4_array::slicemax();
-   }
-   friend class index_type;
-};
+    }
+  public:
+    virtual int  dimension(void) const { return 4;}
+    i4_index(i4_array& v) : i4_array(v){}
+    virtual int indexmin(void){return i4_array::slicemin();}
+    virtual int indexmax(void){return i4_array::slicemax();}
+    friend class index_type;
+  };
 
-void ad_begin_funnel(void);
+  void ad_begin_funnel(void);
 
 /**
  * Description not yet available.
  * \param
  */
-class vector_range_exception
-{
-   vector_range_exception(int i, int imin, int imax);
-   friend class dvector;
-   friend class dvar_vector;
+class vector_range_exception{
+  vector_range_exception(int i,int imin,int imax);
+  friend class dvector;
+  friend class dvar_vector;
 };
 
 /**
@@ -9071,188 +7387,130 @@
  */
 class spdll_exception
 {
- public:
-   int e;
-   spdll_exception(int _e = 0)
-   {
-      e = _e;
-   }
+public:
+ int e;
+ spdll_exception(int _e=0){e=_e;}
 };
 
 /**
  * Description not yet available.
  * \param
  */
-class random_number_generator	/// Random number generator
+class random_number_generator /// Random number generator
 {
-   unsigned long *mt;		///< the array for the state vector
-   int mti;			///< mti==N+1 means mt[N] is not initialized
- public:
-   random_number_generator(int seed);
-   ~random_number_generator();
-   double better_rand(void);
-   void reinitialize(int seed);
+ unsigned long *mt; ///< the array for the state vector
+ int mti; ///< mti==N+1 means mt[N] is not initialized
+public:
+ random_number_generator(int seed);
+ ~random_number_generator();
+ double better_rand(void);
+ void reinitialize(int seed);
 };
 
-double randpoisson(double lambda, const random_number_generator & rng);
+double randpoisson(double lambda,const random_number_generator& rng);
 
 // note that od is the overdispersion od >1
-double randnegbinomial(double mu, double tau,
-		       const random_number_generator & rng);
-double randn(const random_number_generator & rng);
-double randu(const random_number_generator & rng);
-double gasdev(const random_number_generator & _rng);
-double expdev(const random_number_generator & _rng);
-double sgamma(double a, const random_number_generator & _rng);
-banded_symmetric_dmatrix value(const banded_symmetric_dvar_matrix & v);
-banded_symmetric_dmatrix restore_banded_symmetric_dvar_matrix_value(const
-								    dvar_matrix_position
-								    &
-								    mpos);
+double randnegbinomial(double mu,double tau,const random_number_generator& rng);
+double randn(const random_number_generator& rng);
+double randu(const random_number_generator& rng);
+double gasdev(const random_number_generator& _rng);
+double expdev(const random_number_generator& _rng);
+double sgamma(double a,const random_number_generator& _rng);
+banded_symmetric_dmatrix value(const banded_symmetric_dvar_matrix&v);
+banded_symmetric_dmatrix restore_banded_symmetric_dvar_matrix_value(const dvar_matrix_position& mpos);
 
 /**
  * Description not yet available.
  * \param
  */
+
 class banded_symmetric_dmatrix
 {
-   int bw;
-   dmatrix d;
- public:
-   const dmatrix & get_dmatrix(void) const
-   {
-      return d;
-   }
-   void initialize(void);
-   int bandwidth(void) const
-   {
-      return bw;
-   }
-   int indexmin(void) const
-   {
-      return d(0).indexmin();
-   }
-   int indexmax(void) const
-   {
-      return d(0).indexmax();
-   }
-   int rowmin(void) const
-   {
-      return d.rowmin();
-   }
-   int rowmax(void) const
-   {
-      return d.rowmax();
-   }
+  int bw;
+  dmatrix d; 
+public:
+  const dmatrix& get_dmatrix(void) const { return d;}
+  void initialize(void);
+  int bandwidth(void) const { return bw; }
+  int indexmin(void) const { return d(0).indexmin(); }
+  int indexmax(void) const { return d(0).indexmax(); }
+  int rowmin(void) const { return d.rowmin(); }
+  int rowmax(void) const { return d.rowmax(); }
+  
+  banded_symmetric_dmatrix(void) : bw(-1), d() {}
+  banded_symmetric_dmatrix(const banded_symmetric_dmatrix&,int,int);
+ 
+  banded_symmetric_dmatrix sub(int l,int u);
+ 
+  void shift(int);
 
-   banded_symmetric_dmatrix(void):bw(-1), d()
-   {
-   }
-   banded_symmetric_dmatrix(const banded_symmetric_dmatrix &, int, int);
+  banded_symmetric_dmatrix& operator = (const banded_symmetric_dmatrix&);
+  banded_symmetric_dmatrix(int _min,int _max,int _bw);
 
-   banded_symmetric_dmatrix sub(int l, int u);
+  banded_symmetric_dmatrix(const dvar_matrix_position& mpos);
+  void save_dmatrix_value(void) const;
+  void save_dmatrix_position(void) const;
+  void save_dmatrix_derivatives(const dvar_matrix_position&) const;
 
-   void shift(int);
-
-   banded_symmetric_dmatrix & operator =(const banded_symmetric_dmatrix &);
-   banded_symmetric_dmatrix(int _min, int _max, int _bw);
-
-   banded_symmetric_dmatrix(const dvar_matrix_position & mpos);
-   void save_dmatrix_value(void) const;
-   void save_dmatrix_position(void) const;
-   void save_dmatrix_derivatives(const dvar_matrix_position &) const;
-
 #if defined(OPT_LIB)
-   inline double &operator () (register int i, register int j)
-   {
-      return (*((d.m[i - j]).v + i));
-   }
-   inline dvector operator () (register int i)
-   {
-      return (d.m[i]);
-   }
+  inline double& operator () (register int i, register int j)
+	  { return ( *((d.m[i-j]).v+i )); }
+  inline dvector operator () (register int i)
+	  { return  (d.m[i]); }
 #  ifdef USE_CONST
-   inline const double &operator() (register int i, register int j) const
-   {
-      return (*((d.m[i - j]).v + i));
-   }
-   inline const dvector operator() (register int i) const
-   {
-      return (d.m[i]);
-   }
+  inline const double& operator()(register int i, register int j) const
+	  { return ( *((d.m[i-j]).v+i )); }
+  inline const dvector operator()(register int i) const
+	  { return  (d.m[i]); }
 #  endif
 #else
-   double &operator () (int i, int j);
-   dvector operator () (int i);
+  double& operator () (int i,int j);
+  dvector operator () (int i);
 #  ifdef USE_CONST
-   const double &operator() (int i, int j) const;
-   const dvector operator() (int i) const;
+  const double& operator()(int i, int j) const;
+  const dvector operator()(int i) const;
 #  endif
 
 #endif
-   friend banded_symmetric_dmatrix value(const banded_symmetric_dvar_matrix
-					 & v);
-   friend banded_symmetric_dmatrix
-      restore_banded_symmetric_dvar_matrix_value(const dvar_matrix_position
-						 & mpos);
-   friend double norm2(const banded_symmetric_dmatrix & B);
-   friend double sumsq(const banded_symmetric_dmatrix & B);
+  friend banded_symmetric_dmatrix value(const banded_symmetric_dvar_matrix &v);
+  friend banded_symmetric_dmatrix restore_banded_symmetric_dvar_matrix_value(const dvar_matrix_position& mpos);
+  friend double norm2(const banded_symmetric_dmatrix& B);
+  friend double sumsq(const banded_symmetric_dmatrix& B);
 };
-
 /**
  * Description not yet available.
  * \param
  */
 class banded_symmetric_dvar_matrix
 {
-   int bw;
-   dvar_matrix d;
- public:
-   void initialize(void);
-   int bandwidth(void) const
-   {
-      return bw;
-   }
-   int indexmin(void) const
-   {
-      return d(0).indexmin();
-   }
-   int indexmax(void) const
-   {
-      return d(0).indexmax();
-   }
-   int rowmin(void) const
-   {
-      return d.rowmin();
-   }
-   int rowmax(void) const
-   {
-      return d.rowmax();
-   }
+  int bw;
+  dvar_matrix d; 
+public:
+  void initialize(void);
+  int bandwidth(void) const{return bw;}
+  int indexmin(void) const{return d(0).indexmin();}
+  int indexmax(void) const{return d(0).indexmax();}
+  int rowmin(void) const {return d.rowmin();}
+  int rowmax(void) const {return d.rowmax();}
+  
+  void save_dvar_matrix_value(void) const;
+  void save_dvar_matrix_position(void) const;
+  banded_symmetric_dvar_matrix(int _min,int _max,int _bw);
+  banded_symmetric_dvar_matrix(const banded_symmetric_dvar_matrix&);
 
-   void save_dvar_matrix_value(void) const;
-   void save_dvar_matrix_position(void) const;
-   banded_symmetric_dvar_matrix(int _min, int _max, int _bw);
-   banded_symmetric_dvar_matrix(const banded_symmetric_dvar_matrix &);
-
 #if defined(OPT_LIB)
-   prevariable operator () (int i, int j)
-   {
-      return ((d.m[i - j]).va + i);
-   }
-   dvar_vector operator () (int i)
-   {
-      return (d.m[i]);
-   }
+  prevariable operator () (int i,int j)
+	  { return ( (d.m[i-j]).va+i ); }
+  dvar_vector operator () (int i)
+	  { return  (d.m[i]); }
 #else
-   prevariable operator () (int i, int j);
-   dvar_vector operator () (int i);
+  prevariable operator () (int i,int j);
+  dvar_vector operator () (int i);
 #endif
-   friend banded_symmetric_dmatrix value(const banded_symmetric_dvar_matrix
-					 & v);
-   friend dvariable norm(const banded_symmetric_dvar_matrix & B);
-   friend dvariable norm2(const banded_symmetric_dvar_matrix & B);
-   friend dvariable sumsq(const banded_symmetric_dvar_matrix & B);
+  friend banded_symmetric_dmatrix value(const banded_symmetric_dvar_matrix&v);
+  friend dvariable norm(const banded_symmetric_dvar_matrix& B);
+  friend dvariable norm2(const banded_symmetric_dvar_matrix& B);
+  friend dvariable sumsq(const banded_symmetric_dvar_matrix& B);
 };
 
 /**
@@ -9261,75 +7519,46 @@
  */
 class banded_lower_triangular_dmatrix
 {
-   int bw;
-   dmatrix d;
- public:
-   void initialize(void);
-   void shift(int);
-   int bandwidth(void) const
-   {
-      return bw;
-   }
-   int indexmin(void) const
-   {
-      return d(0).indexmin();
-   }
-   int indexmax(void) const
-   {
-      return d(0).indexmax();
-   }
-   int rowmin(void) const
-   {
-      return d.rowmin();
-   }
-   int rowmax(void) const
-   {
-      return d.rowmax();
-   }
-
-   void save_dmatrix_value(void) const;
-   void save_dmatrix_position(void) const;
-   banded_lower_triangular_dmatrix(const dvar_matrix_position & mpos);
-   banded_lower_triangular_dmatrix(int _min, int _max, int _bw);
-   banded_lower_triangular_dmatrix(const banded_lower_triangular_dmatrix
-				   &);
-   banded_lower_triangular_dmatrix & operator =(const
-						banded_lower_triangular_dmatrix
-						&);
-   void save_dmatrix_derivatives(const dvar_matrix_position &) const;
-   friend banded_lower_triangular_dmatrix
-      restore_banded_lower_triangular_dvar_matrix_value(const
-							dvar_matrix_position
-							& mpos);
+  int bw;
+  dmatrix d; 
+public:
+  void initialize(void);
+  void shift(int);
+  int bandwidth(void) const { return bw; }
+  int indexmin(void) const { return d(0).indexmin(); }
+  int indexmax(void) const { return d(0).indexmax(); }
+  int rowmin(void) const { return d.rowmin(); }
+  int rowmax(void) const { return d.rowmax(); }
+  
+  void save_dmatrix_value(void) const;
+  void save_dmatrix_position(void) const;
+ banded_lower_triangular_dmatrix (const dvar_matrix_position& mpos);
+ banded_lower_triangular_dmatrix(int _min,int _max,int _bw);
+ banded_lower_triangular_dmatrix(const banded_lower_triangular_dmatrix&);
+ banded_lower_triangular_dmatrix& operator =(const banded_lower_triangular_dmatrix&);
+ void save_dmatrix_derivatives(const dvar_matrix_position&) const;
+ friend  banded_lower_triangular_dmatrix restore_banded_lower_triangular_dvar_matrix_value(const dvar_matrix_position& mpos);
 #if defined(OPT_LIB)
-   inline double &operator () (register int i, register int j)
-   {
-      return (*((d.m[i - j]).v + i));
-   }
-   inline dvector operator () (register int i)
-   {
-      return (d.m[i]);
-   }
+  inline double& operator () (register int i, register int j)
+	  { return ( *((d.m[i-j]).v+i )); }
+  inline dvector operator () (register int i)
+	  { return  (d.m[i]); }
 #  ifdef USE_CONST
-   inline const double &operator() (register int i, register int j) const
-   {
-      return (*((d.m[i - j]).v + i));
-   }
-   inline const dvector operator() (register int i) const
-   {
-      return (d.m[i]);
-   }
+  inline const double& operator()(register int i, register int j) const
+	  { return ( *((d.m[i-j]).v+i )); }
+  inline const dvector operator()(register int i) const
+	  { return  (d.m[i]); }
 #  endif
 #else
-   double &operator () (int i, int j);
-   dvector operator () (int i);
+  double& operator () (int i,int j);
+  dvector operator () (int i);
 #  ifdef USE_CONST
-   const double &operator() (int i, int j) const;
-   const dvector operator() (int i) const;
+  const double& operator()(int i, int j) const;
+  const dvector operator()(int i) const;
 #  endif
 #endif
-   friend banded_lower_triangular_dmatrix value
-      (const banded_lower_triangular_dvar_matrix & v);
+  friend banded_lower_triangular_dmatrix value
+    (const banded_lower_triangular_dvar_matrix&v);
 };
 
 /**
@@ -9338,180 +7567,141 @@
  */
 class banded_lower_triangular_dvar_matrix
 {
-   int bw;
-   dvar_matrix d;
- public:
-   int bandwidth(void) const
-   {
-      return bw;
-   }
-   int indexmin(void) const
-   {
-      return d(0).indexmin();
-   }
-   int indexmax(void) const
-   {
-      return d(0).indexmax();
-   }
-   int rowmin(void) const
-   {
-      return d.rowmin();
-   }
-   int rowmax(void) const
-   {
-      return d.rowmax();
-   }
-   void initialize(void);
-   void save_dvar_matrix_value(void) const;
-   void save_dvar_matrix_position(void) const;
+  int bw;
+  dvar_matrix d; 
+public:
+  int bandwidth(void) const { return bw; }
+  int indexmin(void) const { return d(0).indexmin(); }
+  int indexmax(void) const { return d(0).indexmax(); }
+  int rowmin(void) const { return d.rowmin(); }
+  int rowmax(void) const { return d.rowmax(); }
+  void initialize(void);
+  void save_dvar_matrix_value(void) const;
+  void save_dvar_matrix_position(void) const;
+  
+  banded_lower_triangular_dvar_matrix(int _min,int _max,int _bw);
+  banded_lower_triangular_dvar_matrix
+    (const banded_lower_triangular_dvar_matrix&);
 
-   banded_lower_triangular_dvar_matrix(int _min, int _max, int _bw);
-   banded_lower_triangular_dvar_matrix
-      (const banded_lower_triangular_dvar_matrix &);
-
 #if defined(OPT_LIB)
-   inline prevariable operator () (register int i, register int j)
-   {
-      return ((d.m[i - j]).va + i);
-   }
-   inline dvar_vector operator () (register int i)
-   {
-      return (d.m[i]);
-   }
+  inline prevariable operator () (register int i, register int j)
+	  { return ( (d.m[i-j]).va+i ); }
+  inline dvar_vector operator () (register int i)
+	  { return  (d.m[i]); }
 #  ifdef USE_CONST
-   inline const prevariable operator() (register int i, register int j) const
-   {
-      return ((d.m[i - j]).va + i);
-   }
-   inline const dvar_vector operator() (register int i) const
-   {
-      return (d.m[i]);
-   }
+  inline const prevariable operator()(register int i, register int j) const
+	  { return ( (d.m[i-j]).va+i ); }
+  inline const dvar_vector operator()(register int i) const
+	  { return  (d.m[i]); }
 # endif
 #else
-   prevariable operator () (int i, int j);
-   dvar_vector operator () (int i);
+  prevariable operator () (int i,int j);
+  dvar_vector operator () (int i);
 #  ifdef USE_CONST
-   const prevariable operator() (int i, int j) const;
-   const dvar_vector operator() (int i) const;
+  const prevariable operator()(int i, int j) const;
+  const dvar_vector operator()(int i) const;
 # endif
 #endif
-   inline double &elem_value(register int i, register int j)
-   {
-      return *(double *) ((d.m[i - j]).va + i);
-   }
+  inline double& elem_value (register int i, register int j)
+  { return * (double*) ((d.m[i-j]).va+i); }
 #ifdef USE_CONST
-   inline const double &elem_value(register int i, register int j) const
-   {
-      return *(double *) ((d.m[i - j]).va + i);
-   }
+  inline const double& elem_value(register int i, register int j) const
+    { return * (double*) ((d.m[i-j]).va+i); }
 #endif
-   friend banded_lower_triangular_dmatrix value
-      (const banded_lower_triangular_dvar_matrix & v);
+  friend banded_lower_triangular_dmatrix value
+    (const banded_lower_triangular_dvar_matrix &v);
 };
 
-ostream & operator<<(const ostream & ofs,
-		     const banded_symmetric_dmatrix & S);
-ostream & operator<<(const ostream & ofs,
-		     const banded_symmetric_dvar_matrix & S);
-ostream & operator<<(const ostream & ofs,
-		     const banded_lower_triangular_dmatrix & S);
-ostream & operator<<(const ostream & ofs,
-		     const banded_lower_triangular_dvar_matrix & S);
 
+ostream& operator << (const ostream& ofs,const banded_symmetric_dmatrix& S);
+ostream& operator << (const ostream& ofs,const banded_symmetric_dvar_matrix& S);
+ostream& operator << (const ostream& ofs,const banded_lower_triangular_dmatrix& S);
+ostream& operator << (const ostream& ofs,const banded_lower_triangular_dvar_matrix& S);
+
 // check to see how this is transposed before using 
-dmatrix solve(const banded_symmetric_dmatrix & m, const dmatrix & M);
-dmatrix solve(const dmatrix & m, const dmatrix & M);
-dvector solve(const banded_symmetric_dmatrix & m, const dvector & v);
+dmatrix solve(const banded_symmetric_dmatrix& m,const dmatrix& M);
+dmatrix solve(const dmatrix& m,const dmatrix& M);
+dvector solve(const banded_symmetric_dmatrix& m,const dvector&v);
 
 banded_lower_triangular_dmatrix choleski_decomp
-   (const banded_symmetric_dmatrix & S, const int &ierr);
+  (const banded_symmetric_dmatrix& S,const int& ierr);
 
 banded_lower_triangular_dvar_matrix choleski_decomp_positive
-   (const banded_symmetric_dvar_matrix & S, double eps, dvariable & fpen);
+  (const banded_symmetric_dvar_matrix& S,double eps,dvariable& fpen);
 
-dvariable ln_det_choleski(const banded_symmetric_dvar_matrix & S,
-			  const int &ierr);
-double ln_det_choleski(const banded_symmetric_dmatrix & S,
-		       const int &ierr);
+dvariable ln_det_choleski(const banded_symmetric_dvar_matrix& S,const int& ierr);
+double ln_det_choleski(const banded_symmetric_dmatrix& S,const int& ierr);
 
 banded_lower_triangular_dvar_matrix choleski_decomp
-   (const banded_symmetric_dvar_matrix & S, const int &ierr);
+  (const banded_symmetric_dvar_matrix& S,const int& ierr);
 
 banded_lower_triangular_dmatrix
-   restore_banded_lower_triangular_dvar_matrix_derivatives
-   (const dvar_matrix_position & pos);
+  restore_banded_lower_triangular_dvar_matrix_derivatives
+  (const dvar_matrix_position& pos);
 
 banded_lower_triangular_dmatrix
-   restore_banded_lower_triangular_dvar_matrix_value
-   (const dvar_matrix_position & pos);
+  restore_banded_lower_triangular_dvar_matrix_value
+  (const dvar_matrix_position& pos);
 
 banded_symmetric_dmatrix restore_bounded_symmetric_dvar_matrix_derivatives
-   (const dvar_matrix_position & pos);
+  (const dvar_matrix_position& pos);
 
 unsigned long max(unsigned long u, unsigned long v);
 unsigned long min(unsigned long u, unsigned long v);
 double max(CGNU_DOUBLE u, CGNU_DOUBLE v);
 double min(CGNU_DOUBLE u, CGNU_DOUBLE v);
-int max(int i, int j, int k);
-int max(int i, int j);
+int max(int i,int j,int k);
+int max(int i,int j);
 
-dvar_vector solve(const banded_lower_triangular_dvar_matrix & m,
-		  const dvar_vector & v);
+dvar_vector solve(const banded_lower_triangular_dvar_matrix& m,const dvar_vector&v);
+  
+void check_choleski_decomp(const banded_symmetric_dvar_matrix& MM,
+  int& ierr);
 
-void check_choleski_decomp(const banded_symmetric_dvar_matrix & MM,
-			   int &ierr);
+dvector solve(const banded_lower_triangular_dmatrix& m,const dvector&v);
+dvector solve_trans(const banded_lower_triangular_dmatrix& m,const dvector&v);
+int admax(int i,int j);
 
-dvector solve(const banded_lower_triangular_dmatrix & m,
-	      const dvector & v);
-dvector solve_trans(const banded_lower_triangular_dmatrix & m,
-		    const dvector & v);
-int admax(int i, int j);
+dmatrix diagonal_matrix(const dvector& v);
+dvar_matrix diagonal_matrix(const dvar_vector& v);
+dvector diagonal(const dmatrix&);
+ivector diagonal(const imatrix&);
+dvar_vector diagonal(const dvar_matrix&);
 
-dmatrix diagonal_matrix(const dvector & v);
-dvar_matrix diagonal_matrix(const dvar_vector & v);
-dvector diagonal(const dmatrix &);
-ivector diagonal(const imatrix &);
-dvar_vector diagonal(const dvar_matrix &);
-
 double gammln(double xx);
-//dvariable gammln(const dvariable& xx);
 dvariable gammln(const prevariable& xx);
-ivector histogram(double min, double max, int nbin, const dvector& input);
+ivector histogram(double min,double max,int nbin,const dvector& input);
 
-double cumd_cauchy(const double &x);
-double density_cauchy(const double &x);
-double log_density_cauchy(const double &x);
-double inv_cumd_cauchy(const double &x);
-dvariable inv_cumd_cauchy(const prevariable & x);
-dvariable cumd_cauchy(const prevariable & x);
-dvariable kludge_cumd_cauchy(const prevariable & x);
+double cumd_cauchy(const double& x);
+double density_cauchy(const double& x);
+double log_density_cauchy(const double& x);
+double inv_cumd_cauchy(const double& x);
+dvariable inv_cumd_cauchy(const prevariable& x);
+dvariable cumd_cauchy(const prevariable& x);
+dvariable kludge_cumd_cauchy(const prevariable& x);
 
-double log_negbinomial_density(double x, double mu, double tau);
+double log_negbinomial_density(double x,double mu, double tau);
 
-dvariable log_negbinomial_density(double x, const prevariable & mu,
-				  const prevariable & tau);
+dvariable log_negbinomial_density(double x,const prevariable& mu,
+  const prevariable&  tau);
 
-dvariable log_density_poisson(double x, const prevariable & mu);
-double log_density_poisson(double x, double mu);
+dvariable log_density_poisson(double x,const prevariable& mu);
+double log_density_poisson(double x,double mu);
 
 
 //double negbinomial_density(double x,double r, double mu);
-
-
+    
+    
 /**
  * Description not yet available.
  * \param
  */
 class pre_column_print
 {
-   dvector *ptr;
- public:
-   pre_column_print(const dvector & v)
-   {
-      ptr = (dvector *) (&v);
-   }
-   friend ostream & operator<<(const ostream &, const pre_column_print &);
+  dvector * ptr;
+public:
+  pre_column_print(const dvector& v) {ptr=(dvector*)(&v);}
+  friend ostream& operator << (const ostream&,const pre_column_print&);
 };
 
 /**
@@ -9520,513 +7710,442 @@
  */
 class pre_zero_print
 {
-   dvector *ptr;
- public:
-   pre_zero_print(const dvector & v)
-   {
-      ptr = (dvector *) (&v);
-   }
-   friend ostream & operator<<(const ostream &, const pre_zero_print &);
+  dvector * ptr;
+public:
+  pre_zero_print(const dvector& v) {ptr=(dvector*)(&v);}
+  friend ostream& operator << (const ostream&,const pre_zero_print&);
 };
 
-ostream & operator<<(const ostream &, const pre_column_print &);
-ostream & operator<<(const ostream &, const pre_zero_print &);
+ostream& operator << (const ostream&,const pre_column_print&);
+ostream& operator << (const ostream&,const pre_zero_print&);
 
-pre_column_print column_print(const dvector & v);
-pre_zero_print zero_print(const dvector & v);
+pre_column_print column_print(const dvector& v);
+pre_zero_print zero_print(const dvector& v);
 
-dvector VEC(const dmatrix &);
-dmatrix MAT(const dvector &, int i, int j);
+dvector VEC(const dmatrix&);
+dmatrix MAT(const dvector&,int i,int j);
 
-dvar_vector VEC(const dvar_matrix &);
-dvar_matrix MAT(const dvar_vector &, int i, int j);
+dvar_vector VEC(const dvar_matrix&);
+dvar_matrix MAT(const dvar_vector&,int i,int j);
 
-dmatrix operator-(const dmatrix & m);
-dvar_matrix operator-(const dvar_matrix & m);
+dmatrix operator - (const dmatrix & m);
+dvar_matrix operator - (const dvar_matrix & m);
 
-ivector sgn(const dvector &);
-ivector sgn(const dvar_vector &);
+ivector sgn(const dvector&);
+ivector sgn(const dvar_vector&);
 
-int allocated(const ivector & v);
-int allocated(const lvector & v);
-int allocated(const dvector & v);
-int allocated(const dvar_vector & v);
+int allocated(const ivector& v);
+int allocated(const lvector& v);
+int allocated(const dvector& v);
+int allocated(const dvar_vector& v);
 
-int allocated(const imatrix & v);
-int allocated(const dmatrix & v);
-int allocated(const dvar_matrix & v);
+int allocated(const imatrix& v);
+int allocated(const dmatrix& v);
+int allocated(const dvar_matrix& v);
 
-int allocated(const i3_array & v);
-int allocated(const d3_array & v);
-int allocated(const dvar3_array & v);
+int allocated(const i3_array& v);
+int allocated(const d3_array& v);
+int allocated(const dvar3_array& v);
 
-int allocated(const i4_array & v);
-int allocated(const d4_array & v);
-int allocated(const dvar4_array & v);
+int allocated(const i4_array& v);
+int allocated(const d4_array& v);
+int allocated(const dvar4_array& v);
 
-int allocated(const d5_array & v);
-int allocated(const dvar5_array & v);
+int allocated(const d5_array& v);
+int allocated(const dvar5_array& v);
 
-int allocated(const d6_array & v);
-int allocated(const dvar6_array & v);
+int allocated(const d6_array& v);
+int allocated(const dvar6_array& v);
 
-int allocated(const d7_array & v);
-int allocated(const dvar7_array & v);
+int allocated(const d7_array& v);
+int allocated(const dvar7_array& v);
 
-dvar_matrix positive_definite_matrix(const dvar_matrix & MM, double eps,
-				     dvariable & fpen);
+dvar_matrix positive_definite_matrix(const dvar_matrix& MM,double eps,
+  dvariable& fpen);
 
-dvar_matrix empirical_covariance(const dvar_matrix & v1);
-dvar_matrix empirical_covariance(const dvar_matrix & v1,
-				 const imatrix & missflags);
+dvar_matrix empirical_covariance(const dvar_matrix& v1);
+dvar_matrix empirical_covariance(const dvar_matrix& v1,
+  const imatrix& missflags);
 
-void gauss_hermite(const dvector & _x, const dvector & _w);
-void normalized_gauss_hermite(const dvector & _x, const dvector & _w);
-void gauss_legendre(double x1, double x2, const dvector & _x,
-		    const dvector & _w);
-void gauss_legendre(const dvector & _x, const dvector & _w);
+void gauss_hermite(const dvector& _x,const dvector& _w);
+void normalized_gauss_hermite(const dvector& _x,const dvector& _w);
+void gauss_legendre(double x1, double x2, const dvector& _x, const dvector& _w);
+void gauss_legendre(const dvector& _x, const dvector& _w);
 
 //dvariable beta(const prevariable&,const prevariable&);
 
-double betacf(const double _a, const double _b, double _x, int maxit = 100);
+//dvariable betacf(const dvariable& _a,const dvariable& _b, const dvariable& _x,int maxit=100);
 
-dvariable betacf(const dvariable& _a, const dvariable& _b, const dvariable& _x, int maxit = 100);
+//double betacf(const double& _a,const double& _b,const double& _x,int maxit=100);
 
-dvariable betai(const dvariable a, const dvariable b, const dvariable x, int maxit = 100);
-double betai(const double a,const double b,const double x, int maxit=100);
+//dvariable betai(const dvariable a,const dvariable b,const dvariable x, int maxit=100);
+//double betai(const double a,const double b,const double x, int maxit=100);
 
-/*
-double betai(double _aa, double _bb, double _xx);
-dvariable betai(const dvariable & _a, const dvariable & _b,
-		const dvariable & _x);
-double incbet(const double a, const double b, const double x);
-dvariable incbet(const dvariable & _a, const dvariable & _b,
-		 const dvariable & _x);
+double betai(double _aa, double _bb, double _xx,int MAXIT=100);
+dvariable betai(const dvariable& _a,const dvariable& _b,const dvariable& _x);
+double incbet(const double a,const double b,const double x);
+dvariable incbet(const dvariable& _a,const dvariable& _b,const dvariable & _x);
 
 df1_three_variable incbet(const df1_three_variable & _aa,
-			  const df1_three_variable & _bb,
-			  const df1_three_variable & _xx);
-*/
+				 const df1_three_variable & _bb,
+				 const df1_three_variable & _xx);
 
-dvar_matrix tensor_prod(const dvar_matrix & a, const dvar_matrix & b);
+dvar_matrix tensor_prod(const dvar_matrix& a,const dvar_matrix & b);
 
 extern "C" void exit_handler(int k);
 
-class double_index_guts;
-class double_index_type;
-class double_number_index;
-class double_vector_index;
-class double_matrix_index;
-class double_i3_index;
+  class double_index_guts;
+  class double_index_type;
+  class double_number_index;
+  class double_vector_index;
+  class double_matrix_index;
+  class double_i3_index;
 
 /**
  * Description not yet available.
  * \param
  */
-class pre_double_index_type
-{
-   const double_index_type *a;
-   int i;
- public:
-   pre_double_index_type(const double_index_type * _a, int _i):a(_a), i(_i)
-   {
-   }
-   friend class double_index_type;
-};
+  class pre_double_index_type
+  {
+    const double_index_type * a;
+    int i;
+  public:
+    pre_double_index_type( const double_index_type * _a,int _i) : a(_a),i(_i){}
+    friend class double_index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class ad_double
-{
- protected:
-   double d;
- public:
-   operator  double () const
-   {
-      return d;
-   }
-   ad_double(const double &_d, const adkludge & k):d(_d)
-   {
-   }
-   ad_double(double _d):d(_d)
-   {
-   }
-   ad_double(const double_index_type & it);
-   ad_double make_ad_double(double _d)
-   {
-      adkludge adk;
-      return ad_double(d, adk);
-   }
-   ad_double & operator =(const ad_double &);
-};
+  class ad_double
+  {
+  protected:
+    double d;
+  public:
+    operator double () const { return d;}
+    ad_double(const double& _d, const adkludge& k) : d(_d) {}
+    ad_double(double _d) : d(_d) {}
+    ad_double(const double_index_type& it);
+    ad_double make_ad_double(double _d) {adkludge adk; return ad_double(d,adk);}
+    ad_double& operator = (const ad_double&);
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class double_index_guts
-{
-   friend class ad_double;
- protected:
-   int *ncopies;
- public:
-   virtual double_index_guts * operator [] (int) = 0;
-   virtual int isdouble(void) const
-   {
-      return 1;
-   }
-   virtual operator  double ()
-   {
-      cerr << "Error in double_index_type"
-	 " -- object not dereferenced enough" << endl;
-      ad_exit(1);
-      return 1;
-   }
-   virtual int indexmin(void) = 0;
-   virtual int indexmax(void) = 0;
-   double_index_guts();
-   double_index_guts(const double_index_guts & ig);
-   virtual ~ double_index_guts();
-   friend class double_index_type;
-};
+  class double_index_guts
+  {
+    friend class ad_double;
+  protected:
+    int * ncopies;
+  public:
+    virtual double_index_guts * operator [] (int) = 0;
+    virtual int  isdouble(void) const { return 1;}
+    virtual operator double () { cerr << "Error in double_index_type"
+     " -- object not dereferenced enough" << endl; ad_exit(1); return 1;}
+    virtual int indexmin(void)=0;
+    virtual int indexmax(void)=0;
+    double_index_guts(); 
+    double_index_guts(const double_index_guts& ig);
+    virtual ~double_index_guts();
+    friend class double_index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class double_index_type
-{
-   double_index_guts *p;
- public:
-   double ddouble(void) const;
-   int isdouble(void) const
-   {
-      return p->isdouble();
-   }
-   double_index_type(double x);
-   //index_type(const data_int& x);
-   double_index_type(const dvector & x);
-   double_index_type(const dmatrix & x);
-   double_index_type(const d3_array & x);
-   double_index_type(const pre_double_index_type & pit);
-   double_index_type(const double_index_type & pit);
-   //index_type (i4_array& x) { p = new i4_index(x);}
-   ~double_index_type();
-   double_index_type operator [] (int i);
-   double_index_type operator () (int i);
-   double_index_type operator [] (int i) const;
-   double_index_type operator () (int i) const;
-   int indexmin(void) const
-   {
-      return p->indexmin();
-   }
-   int indexmax(void) const
-   {
-      return p->indexmax();
-   }
-   friend class ad_integer;
-};
+  class double_index_type
+  {
+    double_index_guts * p;
+  public:
+    double ddouble(void) const;
+    int isdouble(void) const { return p->isdouble();}
+    double_index_type(double x);
+    //index_type(const data_int& x);
+    double_index_type(const dvector& x);
+    double_index_type(const dmatrix& x);
+    double_index_type(const d3_array& x);
+    double_index_type(const pre_double_index_type& pit);
+    double_index_type(const double_index_type& pit);
+    //index_type (i4_array& x) { p = new i4_index(x);}
+    ~double_index_type ();
+    double_index_type operator [] (int i);
+    double_index_type operator () (int i);
+    double_index_type operator [] (int i) const; 
+    double_index_type operator () (int i) const; 
+    int indexmin(void) const { return p->indexmin();}
+    int indexmax(void) const { return p->indexmax();}
+    friend class ad_integer;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class double_index:public ad_double, public double_index_guts
-{
- private:
-   virtual int isdouble_(void) const
-   {
-      return 0;
-   }
-   virtual double_index_guts *operator [] (int i);
-   virtual int indexmin(void)
-   {
-      return 1;
-   }
-   virtual int indexmax(void)
-   {
-      return 1;
-   }
- public:
-   virtual ~ double_index()
-   {
-   }
- double_index(double i):ad_double(i)
-   {
-   }
-   // only overload this for number_index ... will fail for other classes 
-   virtual operator  double ()
-   {
-      return d;
-   }
-   friend class double_index_type;
-};
+  class double_index : public ad_double, public double_index_guts
+  {
+  private:
+    virtual int  isdouble_(void) const { return 0;}
+    virtual double_index_guts * operator [] (int i);
+    virtual int indexmin(void){return 1;}
+    virtual int indexmax(void){return 1;}
+  public:
+    virtual ~double_index() {}
+    double_index(double i) : ad_double(i) {}
+    // only overload this for number_index ... will fail for other classes 
+    virtual operator double () { return d;} 
+    friend class double_index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class dvector_index:public dvector, public double_index_guts
-{
-   virtual double_index_guts *operator [] (int i)
-   {
+  class dvector_index : public dvector, public double_index_guts
+  {
+    virtual double_index_guts * operator [] (int i)
+    {
       return new double_index(dvector::operator [](i));
-   }
- public:
-   //vector_index(const ivector& v) : ivector(v){}
-   dvector_index(const dvector & v);
-   virtual ~ dvector_index();
-   virtual int indexmin(void)
-   {
-      return dvector::indexmin();
-   }
-   virtual int indexmax(void)
-   {
-      return dvector::indexmax();
-   }
-   friend class double_index_type;
-};
+    }
+  public:
+    //vector_index(const ivector& v) : ivector(v){}
+    dvector_index(const dvector& v);
+    virtual ~dvector_index();
+    virtual int indexmin(void){return dvector::indexmin();}
+    virtual int indexmax(void){return dvector::indexmax();}
+    friend class double_index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class dmatrix_index:public dmatrix, public double_index_guts
-{
- private:
-   virtual double_index_guts * operator [] (int i);
-   //{
-   //return new dvector_index(dmatrix::operator [](i));
-   //}
- public:
-   virtual ~ dmatrix_index();
-   dmatrix_index(const dmatrix & v):dmatrix(v)
-   {
-   }
-   virtual int indexmin(void)
-   {
-      return dmatrix::rowmin();
-   }
-   virtual int indexmax(void)
-   {
-      return dmatrix::rowmax();
-   }
-   friend class double_index_type;
-};
+  class dmatrix_index : public dmatrix, public double_index_guts
+  {
+  private:
+    virtual double_index_guts * operator [] (int i);
+    //{
+      //return new dvector_index(dmatrix::operator [](i));
+    //}
+  public:
+    virtual ~dmatrix_index();
+    dmatrix_index(const dmatrix& v) : dmatrix(v){}
+    virtual int indexmin(void){return dmatrix::rowmin();}
+    virtual int indexmax(void){return dmatrix::rowmax();}
+    friend class double_index_type;
+  };
 
 /**
  * Description not yet available.
  * \param
  */
-class d3_index:public d3_array, public double_index_guts
-{
-   virtual double_index_guts *operator [] (int i)
-   {
+  class d3_index : public d3_array, public double_index_guts
+  {
+    virtual double_index_guts * operator [] (int i)
+    {
       return new dmatrix_index(d3_array::operator [](i));
-   }
- public:
-   d3_index(d3_array & v):d3_array(v)
-   {
-   }
-   virtual int indexmin(void)
-   {
-      return d3_array::slicemin();
-   }
-   virtual int indexmax(void)
-   {
-      return d3_array::slicemax();
-   }
-   friend class index_type;
-};
+    }
+  public:
+    d3_index(d3_array& v) : d3_array(v){}
+    virtual int indexmin(void){return d3_array::slicemin();}
+    virtual int indexmax(void){return d3_array::slicemax();}
+    friend class index_type;
+  };
 
-dvariable mf_upper_bound(const prevariable & x, double M,
-			 prevariable & fpen);
-double mf_upper_bound(const double &x, double M, prevariable & fpen);
+  dvariable mf_upper_bound(const prevariable& x,double M,prevariable& fpen);
+  double mf_upper_bound(const double& x,double M,prevariable& fpen);
 
-int operator==(double v0, const prevariable & v1);
-int operator<=(double v0, const prevariable & v1);
-int operator>=(double v0, const prevariable & v1);
-int operator>(double v0, const prevariable & v1);
-int operator<(double v0, const prevariable & v1);
-int operator!=(double v0, const prevariable & v1);
+   int operator ==(double v0,const prevariable& v1);
+   int operator <=(double v0,const prevariable& v1);
+   int operator >=(double v0,const prevariable& v1);
+   int operator >(double v0,const prevariable& v1);
+   int operator <(double v0,const prevariable& v1);
+   int operator !=(double v0,const prevariable& v1);
 
-dvariable cumd_bivariate_normal(const prevariable & xu,
-				const prevariable & yu,
-				const prevariable & rho, int nbox);
+  dvariable cumd_bivariate_normal(const prevariable& xu,const prevariable& yu,
+    const prevariable& rho,int nbox);
 
-dvariable cumbvn(const dvariable & x, const dvariable & y,
-		 const dvariable & rho);
+  dvariable cumbvn(const dvariable& x,const dvariable& y,const dvariable& rho);
 
-dvariable cumbvn(const dvariable & xl, const dvariable & yl,
-		 const dvariable & xu, const dvariable & yu,
-		 const dvariable & rho);
+  dvariable cumbvn(const dvariable& xl,const dvariable& yl,
+    const dvariable& xu,const dvariable& yu,const dvariable& rho);
 
-double ghk(const dvector & lower, const dvector & upper,
-	   const dmatrix & Sigma, const dmatrix & eps);
+  double ghk(const dvector& lower,const dvector& upper,
+    const dmatrix& Sigma,const dmatrix& eps);
 
-double ghk_choleski(const dvector & lower, const dvector & upper,
-		    const dmatrix & ch, const dmatrix & eps);
+  double ghk_choleski(const dvector& lower,const dvector& upper,
+    const dmatrix& ch,const dmatrix& eps);
 
-dvariable ghk_choleski_m(const dvar_vector & upper,
-			 const dvar_matrix & ch, const dmatrix & eps);
+  dvariable ghk_choleski_m(const dvar_vector& upper,
+    const dvar_matrix& ch, const dmatrix& eps);
 
-double ghk(const dvector & lower, const dvector & upper,
-	   const dmatrix & Sigma, const dmatrix & eps, int i);
+  double ghk(const dvector& lower,const dvector& upper,
+    const dmatrix& Sigma,const dmatrix& eps,int i);
 
-dvariable ghk(const dvar_vector & lower, const dvar_vector & upper,
-	      const dvar_matrix & Sigma, const dmatrix & eps);
+  dvariable ghk(const dvar_vector& lower,const dvar_vector& upper,
+    const dvar_matrix& Sigma,const dmatrix& eps);
 
-dvariable ghk(const dvar_vector & lower, const dvar_vector & upper,
-	      const dvar_matrix & Sigma, const dmatrix & eps, int i);
+  dvariable ghk(const dvar_vector& lower,const dvar_vector& upper,
+    const dvar_matrix& Sigma,const dmatrix& eps,int i);
 
-dvariable ghk_choleski_m_cauchy(const dvar_vector & upper,
-				const dvar_matrix & ch,
-				const dmatrix & eps);
-
-dvariable ghk_choleski_m_logistic(const dvar_vector & upper,
-				  const dvar_matrix & ch,
-				  const dmatrix & eps);
-
+  dvariable ghk_choleski_m_cauchy(const dvar_vector& upper,
+    const dvar_matrix& ch, const dmatrix& eps);
+  
+  dvariable ghk_choleski_m_logistic(const dvar_vector& upper,
+    const dvar_matrix& ch, const dmatrix& eps);
+  
 /**
  * Description not yet available.
  * \param
  */
 class function_minimizer_exception
-{
- public:
-   function_minimizer_exception(void)
-   {
-   }
-};
+  {
+  public:
+    function_minimizer_exception(void){}
+  };
 
+  
+  void tracing_message(int traceflag,const char *s);
+  void tracing_message(int traceflag,const char *s,int *pn);
+  void tracing_message(int traceflag,const char *s,double *pd);
+  void tracing_message(int traceflag,const char *s,double d);
 
-void tracing_message(int traceflag, const char *s);
-void tracing_message(int traceflag, const char *s, int *pn);
-void tracing_message(int traceflag, const char *s, double *pd);
-void tracing_message(int traceflag, const char *s, double d);
 
+  int sub_unallocated(const dvar_vector& m);
+  int sub_unallocated(const dvar_matrix& m);
+  int sub_unallocated(const dvar3_array& m);
+  int sub_unallocated(const dvar4_array& m);
+  int sub_unallocated(const dvar5_array& m);
+  int sub_unallocated(const dvector& m);
+  int sub_unallocated(const dmatrix& m);
+  int sub_unallocated(const d3_array& m);
+  int sub_unallocated(const d4_array& m);
+  int sub_unallocated(const d5_array& m);
+  int sub_unallocated(const ivector& m);
+  int sub_unallocated(const imatrix& m);
+  int sub_unallocated(const i3_array& m);
+  int sub_unallocated(const i4_array& m);
 
-int sub_unallocated(const dvar_vector & m);
-int sub_unallocated(const dvar_matrix & m);
-int sub_unallocated(const dvar3_array & m);
-int sub_unallocated(const dvar4_array & m);
-int sub_unallocated(const dvar5_array & m);
-int sub_unallocated(const dvector & m);
-int sub_unallocated(const dmatrix & m);
-int sub_unallocated(const d3_array & m);
-int sub_unallocated(const d4_array & m);
-int sub_unallocated(const d5_array & m);
-int sub_unallocated(const ivector & m);
-int sub_unallocated(const imatrix & m);
-int sub_unallocated(const i3_array & m);
-int sub_unallocated(const i4_array & m);
+  void check_derivative_values(const char * s);
+  void check_derivative_values(const char * s,int i);
+  void check_derivative_values_break(const char * s,int i,int b);
+  void df_check_derivative_values(void);
+  void df_check_derivative_values_indexed(void);
+  void df_check_derivative_values_indexed_break(void);
+  extern int ad_kill_flag;
+  void reset_gradient_stack(void);
 
-void check_derivative_values(const char *s);
-void check_derivative_values(const char *s, int i);
-void check_derivative_values_break(const char *s, int i, int b);
-void df_check_derivative_values(void);
-void df_check_derivative_values_indexed(void);
-void df_check_derivative_values_indexed_break(void);
-extern int ad_kill_flag;
-void reset_gradient_stack(void);
-
-#define AD_SET_DERIVATIVES1(depvar,indvar,df)  \
+  #define AD_SET_DERIVATIVES1(depvar,indvar,df)  \
      gradient_structure::GRAD_STACK1->set_gradient_stack2(default_evaluation2,\
        &(value(depvar)), &(value(indvar)),df);
 
-#define AD_SET_DERIVATIVES2(depvar,indvar1,df1,indvar2,df2)  \
+  #define AD_SET_DERIVATIVES2(depvar,indvar1,df1,indvar2,df2)  \
      gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation3,\
        &(value(depvar)), &(value(indvar1)),df1,&(value(indvar2)),df2);
 
-#define AD_SET_DERIVATIVES3(depvar,indvar1,df1,indvar2,df2,indvar3,df3)  \
+  #define AD_SET_DERIVATIVES3(depvar,indvar1,df1,indvar2,df2,indvar3,df3)  \
     gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation3ind,\
       &(value(depvar)), &(value(indvar1)),df1,&(value(indvar2)),df2, \
       &(value(indvar3)),df3);
 
-#define AD_SET_DERIVATIVES4(depvar,indvar1,df1,indvar2,df2,indvar3,df3,indvar4,df4)  \
+  #define AD_SET_DERIVATIVES4(depvar,indvar1,df1,indvar2,df2,indvar3,df3,indvar4,df4)  \
     gradient_structure::GRAD_STACK1->set_gradient_stack(default_evaluation4ind,\
       &(value(depvar)), &(value(indvar1)),df1,&(value(indvar2)),df2, \
       &(value(indvar3)),df3, \
       &(value(indvar4)),df4);
 
-#define ADJOINT_CODE(x) \
+  #define ADJOINT_CODE(x) \
      gradient_structure::GRAD_STACK1->set_gradient_stack(x);
 
-int make_sub_directory(const char *s);
+  int make_sub_directory(const char * s);
 #include <adstring.hpp>
-adstring get_string_marker(void);
-class adpvm_manager;
-class adtimer;
+  adstring get_string_marker(void);
+  class adpvm_manager;
+  class adtimer;
 
+  class adpthreads_manager
+  {
+    static __ADMBTHREAD__ int slave_number;
+  public:
+    static int is_slave(void) { if (slave_number)
+                                  return 1;
+                                else
+                                  return 0; }
+    static int is_master(void) { if (slave_number) 
+                                  return 0;
+                                else
+                                  return 1; }
+    int get_slave_number(void) { return slave_number; }
+    void set_slave_number(int n) { slave_number=n; }
+    adpthreads_manager(int n) { slave_number=n;}
+    adpthreads_manager(void) { slave_number=0;}
+  };
+
 /**
  * Description not yet available.
  * \param
  */
 class ad_comm
 {
- protected:
-   ad_comm(int argc, char *argv[]);
-   ad_comm(void);
-   void allocate(void);
-   virtual ~ ad_comm();
- public:
-   static int time_flag;
-   static int bandwidth;
-   static int print_hess_and_exit_flag;
-   static int no_pvm_flag;
-   static int no_atlas_flag;
-   static int no_ln_det_choleski_flag;
-   static adtimer *ptm;
-   static adtimer *ptm1;
-   virtual void get_slave_assignments(void);
-   static adpvm_manager *pvm_manager;
-   static adstring subdir;
-   static streampos change_datafile_name(const adstring & s,
-					 const streampos & off = 0);
-   static streampos change_pinfile_name(const adstring & s,
-					const streampos & off = 0);
-   static cifstream *global_datafile;
-   static cifstream *global_parfile;
-   static ofstream *global_savefile;
-   static ofstream *global_logfile;
-   static uostream *global_bsavefile;
-   static uistream *global_bparfile;
-   static adstring adprogram_name;
-   static adstring working_directory_path;
-   static char option_flags[];
-   static int argc;
-   static unsigned int wd_flag;
-   static unsigned char directory_prefix;
-   static char **argv;
+protected:
+  ad_comm(int argc,char * argv[]);
+  ad_comm(void);
+  void allocate(void);
+  virtual ~ad_comm();
+public:
+  static int time_flag;
+  static int bandwidth;
+  static int print_hess_and_exit_flag;
+  static int no_pvm_flag;
+  static int no_atlas_flag;
+  static int no_ln_det_choleski_flag;
+  static adtimer * ptm;
+  static adtimer * ptm1;
+  virtual void get_slave_assignments(void);
+  static adpvm_manager * pvm_manager;
+  static __ADMBTHREAD__ adpthreads_manager * pthreads_manager;
+  static adstring subdir;
+  static streampos change_datafile_name(const adstring& s,const streampos& off=0);
+  static streampos change_pinfile_name(const adstring& s,const streampos& off=0);
+  static cifstream * global_datafile;
+  static cifstream * global_parfile;
+  static ofstream *  global_savefile;
+  static ofstream *  global_logfile;
+  static uostream *  global_bsavefile;
+  static uistream * global_bparfile;
+  static adstring adprogram_name;
+  static adstring working_directory_path;
+  static char option_flags[];
+  static int argc;
+  static unsigned int wd_flag;
+  static unsigned char directory_prefix;
+  static char ** argv;
 };
 
 
-int option_match(int argc, char *argv[], const char *string);
-int option_match(int argc, char *argv[], const char *string,
-		 const int &nopt);
-int option_match(char *s, const char *string, const int &_nopt);
-int option_match(char *s, const char *string);
-int ad_chdir(const char *s);
-void ad_getcd(const adstring & s);
+int option_match(int argc,char * argv[], const char * string);
+int option_match(int argc,char * argv[], const char * string,const int& nopt);
+int option_match(char * s, const char * string, const int& _nopt);
+int option_match(char * s, const char * string);
+int ad_chdir(const char * s);
+void ad_getcd(const adstring& s);
 void grad_chk(void);
-void send_dv3_to_master(const dvar3_array & v);
+void send_dv3_to_master(const dvar3_array& v);
 
-inline dvariable inv(const prevariable & x)
-{
-   return 1.0 / x;
-}
+inline dvariable inv(const prevariable& x) { return 1.0/x; }
 
-double gamma_density(double _x, double r, double mu);
-dvariable gamma_density(const prevariable & _x, double r, double mu);
-dvariable gamma_density(const dvariable & _x, const dvariable & _r,
-			const dvariable & _mu);
+double gamma_density(double _x,double r, double mu);
+dvariable gamma_density(const prevariable& _x,double r, double mu);
+dvariable gamma_density(const dvariable& _x,const dvariable& _r,
+  const  dvariable& _mu);
 
-double log_gamma_density(double _x, double r, double mu);
-dvariable log_gamma_density(const prevariable & _x, double r, double mu);
-dvariable log_gamma_density(const dvariable & _x, const dvariable & _r,
-			    const dvariable & _mu);
+double log_gamma_density(double _x,double r, double mu);
+dvariable log_gamma_density(const prevariable& _x,double r, double mu);
+dvariable log_gamma_density(const dvariable& _x,const dvariable& _r,
+  const  dvariable& _mu);
 
 
 
@@ -10038,15 +8157,15 @@
  * Description not yet available.
  * \param
  */
-class adtimer
-{
-   timeval tv;
-   timeval tvold;
- public:
-   double get_elapsed_time_and_reset(void);	// return time in milliseconds;
-   double get_elapsed_time(void);	// return time in milliseconds;
-   adtimer(void);
-};
+  class adtimer
+  {
+    timeval tv;
+    timeval tvold;
+  public:
+    double get_elapsed_time_and_reset(void);  // return time in milliseconds;
+    double get_elapsed_time(void);  // return time in milliseconds;
+    adtimer (void);
+  };
 
 #else
 #include <windows.h>
@@ -10055,15 +8174,15 @@
  * Description not yet available.
  * \param
  */
-class adtimer
-{
-   DWORD t;
-   DWORD told;
- public:
-   double get_elapsed_time_and_reset(void);	// return time in milliseconds;
-   double get_elapsed_time(void);	// return time in milliseconds;
-   adtimer(void);
-};
+  class adtimer
+  {
+    DWORD t;
+    DWORD told;
+  public:
+    double get_elapsed_time_and_reset(void);  // return time in milliseconds;
+    double get_elapsed_time(void);  // return time in milliseconds;
+    adtimer (void);
+  };
 
 #endif
 #if defined(max)
@@ -10074,14 +8193,14 @@
 #endif
 
 // M is a postiive definite symmetric matrix
-dvariable ln_det_choleski(const dvar_matrix & M);
-dvariable ln_det_choleski_error(const dvar_matrix &, int &ierr);
+dvariable ln_det_choleski(const dvar_matrix& M);
+dvariable ln_det_choleski_error(const dvar_matrix&, int& ierr);
 
 // the autodif wrapper to the ATLAS routines
 
 // M is a postiive definite symmetric matrix
 dvector atlas_solve_spd(const dmatrix & M, const dvector & x);
-dvector atlas_solve_spd(const dmatrix & M, const dvector & x, int &ierr);
+dvector atlas_solve_spd(const dmatrix & M, const dvector & x, int& ierr);
 dmatrix atlas_solve_spd(const dmatrix & M, const dmatrix & x);
 dmatrix atlas_solve_spd_trans(const dmatrix & M, const dmatrix & x);
 
@@ -10089,232 +8208,189 @@
  * Description not yet available.
  * \param
  */
-class lower_triangular_dmatrix:public dmatrix
+class lower_triangular_dmatrix : public dmatrix
 {
- public:
-   lower_triangular_dmatrix(int, int);
+public:
+  lower_triangular_dmatrix(int,int);
 };
-dmatrix symmetrize(const lower_triangular_dmatrix & M);
-dvector solve(const lower_triangular_dmatrix & M, const dvector & v);
-dvector lower_triangular_solve(const dmatrix & M, const dvector & v);
-dvar_vector lower_triangular_solve(const dvar_matrix & M,
-				   const dvar_vector & v);
-dvector solve_trans(const lower_triangular_dmatrix & M, const dvector & v);
-dmatrix fillout(const lower_triangular_dmatrix & M);
-dmatrix fillout_trans(const lower_triangular_dmatrix & M);
-
+dmatrix symmetrize(const lower_triangular_dmatrix& M);
+dvector solve(const lower_triangular_dmatrix& M,const dvector& v);
+dvector lower_triangular_solve(const dmatrix& M,const dvector& v);
+dvar_vector lower_triangular_solve(const dvar_matrix& M,const dvar_vector& v);
+dvector solve_trans(const lower_triangular_dmatrix& M,const dvector& v);
+dmatrix fillout(const lower_triangular_dmatrix& M);
+dmatrix fillout_trans(const lower_triangular_dmatrix& M);
+    
 lower_triangular_dmatrix lower_triangular_choleski_decomp_positive
-   (const dmatrix & MM, const int &_ierr);
+  (const dmatrix& MM,const int& _ierr);
 
-dvar_vector solve_trans(const banded_lower_triangular_dvar_matrix & M,
-			const dvector & y);
+dvar_vector solve_trans(const banded_lower_triangular_dvar_matrix& M,
+  const dvector& y);
 
-inline int admax(int i, int j)
-{
-   if (i > j)
-      return i;
-   else
-      return j;
-}
+inline int admax(int i,int j) { if (i>j) return i; else return j; }
+inline int admin(int i,int j) { if (i>j) return j; else return i; }
 
-inline int admin(int i, int j)
-{
-   if (i > j)
-      return j;
-   else
-      return i;
-}
+d4_array orthpoly2(int n,int m,int d1,int d2);
+double dot(const dmatrix& M,const dmatrix& d2);
 
-d4_array orthpoly2(int n, int m, int d1, int d2);
-double dot(const dmatrix & M, const dmatrix & d2);
+double norm(const banded_symmetric_dmatrix& B);
+double norm2(const banded_symmetric_dmatrix& B);
+double sumsq(const banded_symmetric_dmatrix& B);
+dvariable norm(const banded_symmetric_dvar_matrix& B);
+dvariable norm2(const banded_symmetric_dvar_matrix& B);
+dvariable sumsq(const banded_symmetric_dvar_matrix& B);
 
-double norm(const banded_symmetric_dmatrix & B);
-double norm2(const banded_symmetric_dmatrix & B);
-double sumsq(const banded_symmetric_dmatrix & B);
-dvariable norm(const banded_symmetric_dvar_matrix & B);
-dvariable norm2(const banded_symmetric_dvar_matrix & B);
-dvariable sumsq(const banded_symmetric_dvar_matrix & B);
+double lower_triangular_ln_det(const dmatrix& m);
+double lower_triangular_ln_det(const dmatrix& m,int& sgn);
 
-double lower_triangular_ln_det(const dmatrix & m);
-double lower_triangular_ln_det(const dmatrix & m, int &sgn);
+dvariable lower_triangular_ln_det(const dvar_matrix& m);
+dvariable lower_triangular_ln_det(const dvar_matrix& m,int& sgn);
+double bounder(double x,double min,double max, double scale);
+dvariable bounder(const prevariable&  x,double min,double max, double scale);
+dmatrix inv(const dmatrix& m1,const double& _ln_det, const int& _sgn);
+dmatrix inv_with_lu(const dmatrix& a,const ivector & indx,double d);
 
-dvariable lower_triangular_ln_det(const dvar_matrix & m);
-dvariable lower_triangular_ln_det(const dvar_matrix & m, int &sgn);
-double bounder(double x, double min, double max, double scale);
-dvariable bounder(const prevariable & x, double min, double max,
-		  double scale);
-dmatrix inv(const dmatrix & m1, const double &_ln_det, const int &_sgn);
-
-double gamma_deviate(double _x, double _a);
-dvariable gamma_deviate(const prevariable & _x, const prevariable & _a);
+double gamma_deviate(double _x,double _a);
+dvariable gamma_deviate(const prevariable& _x,const prevariable& _a);
 void ad_set_new_handler(void);
 
-dvariable inv_cumd_gamma(const prevariable & _y, const prevariable & _a);
-double inv_cumd_gamma(double _y, double _a);
+dvariable inv_cumd_gamma(const prevariable& _y,const prevariable& _a);
+double inv_cumd_gamma( double _y,double _a);
 extern int just_to_link_fvar1;
 
-dvector inv_cumd_pareto(const dvector & _y, double alpha, double xm);
+dvector inv_cumd_pareto(const dvector& _y,double alpha,double xm);
 
-dvector cumd_upper_trunc_pareto(const dvector & _y, double alpha,
-				double xm);
+dvector cumd_upper_trunc_pareto(const dvector& _y,double alpha,double xm);
 
-dvector cumd_pareto(const dvector & _y, double alpha, double xm);
+dvector cumd_pareto(const dvector& _y,double alpha,double xm);
 
-dvector inv_cumd_upper_trunc_pareto(const dvector & _y,
-				    double alpha, double xmin,
-				    double xmax);
+dvector inv_cumd_upper_trunc_pareto(const dvector& _y,
+  double alpha,double xmin,double xmax);
 
-dvar_vector inv_cumd_upper_trunc_pareto(const dvar_vector & _y,
-					const prevariable & alpha,
-					const prevariable & xmin,
-					const prevariable & xmax);
+dvar_vector inv_cumd_upper_trunc_pareto(const dvar_vector& _y,
+  const prevariable& alpha,const prevariable& xmin,const prevariable& xmax);
 
-dvar_vector inv_cumd_pareto(const dvar_vector & _y,
-			    const prevariable & alpha,
-			    const prevariable & xm);
+dvar_vector inv_cumd_pareto(const dvar_vector& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-dvar_vector ln_upper_trunc_pareto_density(const dvar_vector & _y,
-					  const prevariable & alpha,
-					  const prevariable & xm);
+dvar_vector ln_upper_trunc_pareto_density(const dvar_vector& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-dvar_vector ln_pareto_density(const dvar_vector & _y,
-			      const prevariable & alpha,
-			      const prevariable & xm);
+dvar_vector ln_pareto_density(const dvar_vector& _y,const prevariable& alpha,
+  const prevariable& xm);
 
 dvar_vector ln_pareto_upper_trunc_density(const dvar_vector & y,
-					  const prevariable & alpha,
-					  const prevariable & xmin,
-					  const prevariable & xmax);
+  const prevariable& alpha, const prevariable&  xmin,const prevariable& xmax);
 
-dvar_vector pareto_density(const dvar_vector & _y,
-			   const prevariable & alpha,
-			   const prevariable & xm);
+dvar_vector pareto_density(const dvar_vector& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-dvariable ln_upper_trunc_pareto_density(const prevariable & _y,
-					const prevariable & alpha,
-					const prevariable & xmin,
-					const prevariable & xmax);
+dvariable ln_upper_trunc_pareto_density(const prevariable& _y,
+  const prevariable& alpha, const prevariable& xmin, const prevariable& xmax);
 
-dvariable ln_pareto_density(const prevariable & _y,
-			    const prevariable & alpha,
-			    const prevariable & xm);
+dvariable ln_pareto_density(const prevariable& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-dvariable pareto_density(const prevariable & _y, const prevariable & alpha,
-			 const prevariable & xm);
+dvariable pareto_density(const prevariable& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-dvar_vector cumd_pareto(const dvar_vector & _y, const prevariable & alpha,
-			const prevariable & xm);
+dvar_vector cumd_pareto(const dvar_vector& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-dvar_vector cumd_upper_trunc_pareto(const dvar_vector & _y,
-				    const prevariable & alpha,
-				    const prevariable & xmin,
-				    const prevariable & xmax);
+dvar_vector cumd_upper_trunc_pareto(const dvar_vector& _y,
+  const prevariable& alpha,const prevariable& xmin,const prevariable& xmax);
 
-dvariable inv_cumd_pareto(const prevariable & _y,
-			  const prevariable & alpha,
-			  const prevariable & xm);
+dvariable inv_cumd_pareto(const prevariable& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-dvariable cumd_upper_trunc_pareto(const prevariable & _y,
-				  const prevariable & alpha,
-				  const prevariable & xmin,
-				  const prevariable & xmax);
+dvariable cumd_upper_trunc_pareto(const prevariable& _y,
+  const prevariable& alpha ,const prevariable& xmin,const prevariable& xmax);
 
-dvariable cumd_pareto(const prevariable & _y, const prevariable & alpha,
-		      const prevariable & xm);
+dvariable cumd_pareto(const prevariable& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-dvariable inv_cumd_pareto(const prevariable & _y,
-			  const prevariable & alpha,
-			  const prevariable & xm);
+dvariable inv_cumd_pareto(const prevariable& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-dvariable cumd_pareto(const prevariable & _y, const prevariable & alpha,
-		      const prevariable & xm);
+dvariable cumd_pareto(const prevariable& _y,const prevariable& alpha,
+  const prevariable& xm);
 
-double inv_cumd_upper_trunc_pareto(double _y, double alpha, double xmin,
-				   double xmax);
+double inv_cumd_upper_trunc_pareto(double _y,double alpha,double xmin,
+  double xmax);
 
-double inv_cumd_pareto(double _y, double alpha, double xm);
+double inv_cumd_pareto(double _y,double alpha,double xm);
 
-double cumd_pareto(double _y, double alpha, double xm);
+double cumd_pareto(double _y,double alpha,double xm);
 
 
-double robust_normal_logistic_mixture_deviate(double x, double spread =
-					      3.0);
-double robust_normal_mixture_deviate(double x, double spread = 3.0);
-dvariable robust_normal_mixture_deviate(const prevariable & x,
-					double spread = 3.0);
+double robust_normal_logistic_mixture_deviate(double x,double spread=3.0);
+double robust_normal_mixture_deviate(double x,double spread=3.0);
+dvariable robust_normal_mixture_deviate(const prevariable& x,double spread=3.0);
 
-dvector lower_triagnular_solve_trans(const dmatrix & M, const dvector & y);
-dvector lower_triagular_solve(const dmatrix & m, const dvector & v);
-dvector choleski_solve_error(dmatrix M, dvector & v, int &ierror);
-dvector choleski_solve_neghess_error(dmatrix M, dvector & v, int &ierror);
+dvector lower_triagnular_solve_trans(const dmatrix& M,const dvector& y);
+dvector lower_triagular_solve(const dmatrix& m,const dvector&v);
+dvector choleski_solve_error(dmatrix M,dvector& v,int& ierror);
+dvector choleski_solve_neghess_error(dmatrix M,dvector& v,int& ierror);
 
-dvariable cumd_gamma(const dvariable & x, const dvariable & a);
-double cumd_gamma(double x, double a);
+dvariable cumd_gamma(const dvariable& x,const dvariable& a);
+double cumd_gamma(double x,double a);
 
-dvariable cumd_normal_cauchy_mixture(const prevariable & _x, double _a);
-dvar_vector cumd_normal_cauchy_mixture(const dvar_vector & _x, double _a);
+dvariable cumd_normal_cauchy_mixture(const prevariable& _x,double _a);
+dvar_vector cumd_normal_cauchy_mixture(const dvar_vector& _x,double _a);
 
-dvariable cumd_normal_mixture(const prevariable & _x, double _a);
-dvar_vector cumd_normal_mixture(const dvar_vector & _x, double _a);
+dvariable cumd_normal_mixture(const prevariable& _x,double _a);
+dvar_vector cumd_normal_mixture(const dvar_vector& _x,double _a);
 
-dvariable inv_cumd_normal_mixture(const prevariable & _x, double _a);
-dvariable inv_cumd_normal_logistic_mixture(const prevariable & _x,
-					   double _a);
+dvariable inv_cumd_normal_mixture(const prevariable& _x,double _a);
+dvariable inv_cumd_normal_logistic_mixture(const prevariable& _x,double _a);
 
-double inv_cumd_normal_mixture(double _x, double _a);
-double inv_cumd_normal_logistic_mixture(double _x, double _a);
+double inv_cumd_normal_mixture(double _x,double _a);
+double inv_cumd_normal_logistic_mixture(double _x,double _a);
 
-double inv_cumd_t(double n, double y, double eps = 1.e-7);
+double inv_cumd_t(double n,double y,double eps=1.e-7);
 
-dvariable inv_cumd_t(const prevariable & n, const prevariable & y,
-		     double eps = 1.e-7);
+dvariable inv_cumd_t(const prevariable& n,const prevariable& y,
+  double eps=1.e-7);
 
-double inv_cumd_beta_stable(double a, double b, double y, double eps =
-			    1.e-7);
-dvariable inv_cumd_beta_stable(const prevariable & _a,
-			       const prevariable & _b,
-			       const prevariable & _y, double eps = 1.e-7);
+double inv_cumd_beta_stable(double a,double b,double y,double eps=1.e-7);
+dvariable inv_cumd_beta_stable(const prevariable& _a,const prevariable& _b,
+  const prevariable& _y,double eps=1.e-7);
 
-dvariable norm_to_gamma(const prevariable & v, const prevariable & alpha,
-			double bound = 0.999999);
+dvariable norm_to_gamma(const prevariable & v,const prevariable& alpha,
+  double bound=0.999999);
 
-double norm_to_gamma(double v, double alpha, double bound = 0.999999);
+double norm_to_gamma(double v,double alpha,double bound=0.999999);
 
-dmatrix eigenvectors(const banded_symmetric_dmatrix & _SS,
-		     const dvector & e);
-dvector eigenvalues(const banded_symmetric_dmatrix & _SS);
-dvector get_eigen_values(const dvector & _d, const dvector & _e);
-dvar_vector get_eigen_values(const dvar_vector & _d,
-			     const dvar_vector & _e);
-dvector get_eigen_values(const dvector & _d, const dvector & _e,
-			 const dmatrix & _z);
+dmatrix eigenvectors(const banded_symmetric_dmatrix& _SS,const dvector& e);
+dvector eigenvalues(const banded_symmetric_dmatrix& _SS);
+dvector get_eigen_values(const dvector& _d,const dvector& _e);
+dvar_vector get_eigen_values(const dvar_vector& _d,const dvar_vector& _e);
+dvector get_eigen_values(const dvector& _d,const dvector& _e,const dmatrix&_z);
 
-dvariable beta_deviate(const prevariable & _x, const prevariable & _a,
-		       const prevariable & _b, double eps = 1.e-7);
-double beta_deviate(double x, double a, double b, double eps = 1.e-7);
+dvariable beta_deviate(const prevariable& _x,const prevariable& _a,
+  const prevariable& _b,double eps=1.e-7);
+double beta_deviate(double x,double a,double b,double eps=1.e-7);
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 //#include <f2c.h>
-   int smbfct_(int *neqns, ivector & xadj, ivector & adjncy,
-	       ivector & perm, ivector & invp, ivector & xlnz, int *maxlnz,
-	       ivector & xnzsub, ivector & nzsub, int *maxsub,
-	       ivector & rchlnk, ivector & mrglnk, ivector & marker,
-	       int *flag__);
-
+ int smbfct_(int *neqns, ivector& xadj, ivector& adjncy, 
+    ivector& perm, ivector& invp, ivector& xlnz, int *maxlnz, ivector& xnzsub, 
+    ivector& nzsub, int *maxsub, ivector& rchlnk, ivector& mrglnk, 
+    ivector& marker, int *flag__);
+ 
 //  int smbfct_(int *neqns, int *xadj, int *adjncy, 
-//      int *perm, int *invp, int *xlnz, int *maxlnz, int 
-//      *xnzsub, int *nzsub, int *maxsub, int *rchlnk, int *
-//      mrglnk, int *marker, int *flag__);
+// 	int *perm, int *invp, int *xlnz, int *maxlnz, int 
+// 	*xnzsub, int *nzsub, int *maxsub, int *rchlnk, int *
+// 	mrglnk, int *marker, int *flag__);
 #ifdef __cplusplus
-}
+ }
 #endif
 
-dmatrix orthpoly_constant_begin(int n, int deg, int nconst);
-dmatrix orthpoly_constant_begin_end(int n, int deg, int nconst_begin,
-				    int enddeg, int nconst_end);
+  dmatrix orthpoly_constant_begin(int n,int deg,int nconst);
+  dmatrix orthpoly_constant_begin_end(int n,int deg,int nconst_begin,
+    int enddeg,int nconst_end);
 #if defined(USE_DD)
 #  include <ddfvar.hpp>
 #  include <qdfvar.hpp>
@@ -10323,314 +8399,219 @@
 void test_the_pointer(void);
 
 // stuff for debugging the grad stack
-void set_gradstack_flag(char *str, int i, int j);
-void set_gradstack_flag(char *str);
-void report_gradstack_flag(void);
+  void set_gradstack_flag(char* str,int i,int j);
+  void set_gradstack_flag(char* str);
+  void report_gradstack_flag(void);
 
-dvariable log_der_logistic(double a, double b, const prevariable & x);
-double logistic(double a, double b, const double &x);
-double dflogistic(double a, double b, const double &x);
-dvariable logistic(double a, double b, const prevariable & x);
-dvariable dflogistic(double a, double b, const prevariable & x);
-double log_density_negbinomial(double x, double mu, double tau);
+  dvariable log_der_logistic(double a,double b,const prevariable& x);
+  double logistic(double a,double b,const double& x);
+  double dflogistic(double a,double b,const double& x);
+  dvariable logistic(double a,double b,const prevariable& x);
+  dvariable dflogistic(double a,double b,const prevariable& x);
+  double log_density_negbinomial(double x,double mu,double tau);
 
 /**
  * Description not yet available.
  * \param
  */
-class sing_val_decomp
-{
-   dmatrix a;
-   dvector w;
-   dmatrix v;
- public:
-   sing_val_decomp()
-   {
-   };
-   sing_val_decomp(const dmatrix & _a, const dvector & _w,
-		   const dmatrix & _v);
-   dmatrix get_u(void)
-   {
-      return a;
-   }
-   dvector get_w(void)
-   {
-      return w;
-   }
-   dmatrix get_v(void)
-   {
-      return v;
-   }
-};
+  class sing_val_decomp 
+  {
+    dmatrix a;
+    dvector w;
+    dmatrix v;
+  public:
+    sing_val_decomp() {};
+    sing_val_decomp(const dmatrix& _a, const dvector & _w,const dmatrix& _v);
+    dmatrix get_u(void){return a;}
+    dvector get_w(void){return w;}
+    dmatrix get_v(void){return v;}
+  };
 
-sing_val_decomp singval_decomp(const dmatrix & _a);
-banded_lower_triangular_dmatrix choleski_decomp_trust_bound(const
-							    banded_symmetric_dmatrix
-							    & _M,
-							    const int
-							    &_ierr);
+  sing_val_decomp singval_decomp(const dmatrix &_a);
+  banded_lower_triangular_dmatrix choleski_decomp_trust_bound(
+    const banded_symmetric_dmatrix& _M,const int& _ierr);
 
-dvariable avg(const prevariable & x, const prevariable & y);
-double avg(double x, double y);
+  dvariable avg( const prevariable& x,const prevariable& y);
+  double avg(double x,double y);
 
 /**
  * Description not yet available.
  * \param
  */
-class multi_index
-{
-   int mind;
-   int maxd;
-   int depth;
-   ivector index;
- public:
-   multi_index(int min, int max, int dim);
-   ivector & operator () (void)
-   {
-      return index;
-   }
-   void operator ++(void);
-   int get_depth(void)
-   {
-      return depth;
-   }
-   int get_offset(void);
-   void initialize();
-};
+  class multi_index
+  {
+    int mind;
+    int maxd;
+    int depth;
+    ivector index;
+  public:
+    multi_index(int min,int max,int dim);
+    ivector& operator () (void) {return index;}
+    void operator ++ (void);
+    int get_depth(void) { return depth;}
+    int get_offset(void);
+    void initialize();
+  };
+  inline void ADMB_getcallindex(int x){;}
+  inline void ADMB_getcallindex(double x){;}
+  inline void ADMB_getcallindex(const dvector& v){;}
+  inline void ADMB_getcallindex(const dmatrix& v){;}
+  inline void ADMB_getcallindex(const d3_array& v){;}
+  inline void ADMB_getcallindex(const d4_array& v){;}
+  inline void ADMB_getcallindex(const prevariable&){;}
+  inline void ADMB_getcallindex(const dvar_vector& v){;}
+  inline void ADMB_getcallindex(const dvar_matrix& v){;}
+  inline void ADMB_getcallindex(const dvar3_array& v){;}
+  inline void ADMB_getcallindex(dvar4_array& v){;}
 
-inline void ADMB_getcallindex(int x)
-{;
-}
+  void clean(ivector& v,int level);
 
-inline void ADMB_getcallindex(double x)
-{;
-}
-
-inline void ADMB_getcallindex(const dvector & v)
-{;
-}
-
-inline void ADMB_getcallindex(const dmatrix & v)
-{;
-}
-
-inline void ADMB_getcallindex(const d3_array & v)
-{;
-}
-
-inline void ADMB_getcallindex(const d4_array & v)
-{;
-}
-
-inline void ADMB_getcallindex(const prevariable &)
-{;
-}
-
-inline void ADMB_getcallindex(const dvar_vector & v)
-{;
-}
-
-inline void ADMB_getcallindex(const dvar_matrix & v)
-{;
-}
-
-inline void ADMB_getcallindex(const dvar3_array & v)
-{;
-}
-
-inline void ADMB_getcallindex(dvar4_array & v)
-{;
-}
-
-void clean(ivector & v, int level);
-
+ class dcompressed_triplet;
 /**
  * Description not yet available.
  * \param
  */
-class dvar_compressed_triplet
-{
-   int n;
-   int m;
-   imatrix coords;
-   dvar_vector x;
- public:
-   int indexmin(void)
-   {
-      return x.indexmin();
-   }
-   int indexmax(void)
-   {
-      return x.indexmax();
-   }
-   prevariable operator [] (int i)
-   {
-      return x[i];
-   }
-   prevariable operator () (int i)
-   {
-      return x(i);
-   }
-   int &operator () (int i, int j)
-   {
-      return coords(i, j);
-   }
-   dvar_compressed_triplet(int mmin, int mmax, int n, int m);
-   void allocate(int mmin, int mmax, int n, int m);
-   void deallocate(void);
-   imatrix & get_coords(void)
-   {
-      return coords;
-   }
-   dvar_vector & get_x(void)
-   {
-      return x;
-   }
-   int get_n()
-   {
-      return n;
-   }
-   int get_m()
-   {
-      return m;
-   }
-};
 
+  class dvar_compressed_triplet
+  {
+    int n;
+    int m;
+    imatrix coords;
+    dvar_vector x;
+  public:
+    int indexmin(void) { return x.indexmin();}
+    int indexmax(void) { return x.indexmax();}
+    prevariable operator [] (int i) { return x[i];} 
+    prevariable operator () (int i) { return x(i);} 
+    int& operator () (int i,int j) { return coords(i,j);} 
+    dvar_compressed_triplet(int mmin,int mmax,int n,int m);
+    dvar_compressed_triplet(void);
+    void allocate(int mmin,int mmax,int n,int m);
+    void deallocate(void);
+    imatrix& get_coords(void)  { return coords; }
+    dvar_vector& get_x(void)  { return x; }
+    int get_n(){return n;}
+    int get_m(){return m;}
+    dvar_compressed_triplet & operator = (const dvar_compressed_triplet& m);
+    dvar_compressed_triplet & operator = (const dcompressed_triplet& m);
+  };
+  
+  dvar_vector operator * (const dvar_compressed_triplet& M,const dvar_vector& v);
+
 /**
  * Description not yet available.
  * \param
  */
-class dcompressed_triplet
-{
-   int n;			// number of rows
-   int m;			// number of columns
-   imatrix coords;
-   dvector x;
- public:
-   int indexmin(void)
-   {
-      return x.indexmin();
-   }
-   int indexmax(void)
-   {
-      return x.indexmax();
-   }
-   double &operator [] (int i)
-   {
-      return x[i];
-   }
-   double &operator () (int i)
-   {
-      return x(i);
-   }
-   int &operator () (int i, int j)
-   {
-      return coords(i, j);
-   }
-   dcompressed_triplet(int mmin, int mmax, int n, int m);
-   //dcompressed_triplet make_dcompressed_triplet(const dmatrix & );
-   void allocate(int mmin, int mmax, int n, int m);
-   void deallocate(void);
-   imatrix & get_coords(void)
-   {
-      return coords;
-   }
-   dvector & get_x(void)
-   {
-      return x;
-   }
-   int get_n()
-   {
-      return n;
-   }
-   int get_m()
-   {
-      return m;
-   }
-   void initialize(void);
-};
+ class dcompressed_triplet
+  {
+    int n;  // number of rows
+    int m;  // number of columns
+    imatrix coords;
+    dvector x;
+  public:
+    int indexmin(void) { return x.indexmin();}
+    int indexmax(void) { return x.indexmax();}
+    double& operator [] (int i) { return x[i];}
+    double& operator () (int i) { return x(i);}
+    int& operator () (int i,int j) { return coords(i,j);}
+    dcompressed_triplet(int mmin,int mmax,int n,int m);
+    explicit dcompressed_triplet(const dmatrix&);
+    dcompressed_triplet(void);
+    //dcompressed_triplet make_dcompressed_triplet(const dmatrix & );
+    void allocate(int mmin,int mmax,int n,int m);
+    void deallocate(void);
+    imatrix& get_coords(void)  { return coords; }
+    dvector& get_x(void)  { return x; }
+    int get_n(){return n;}
+    int get_m(){return m;}
+    void initialize(void);
+  };
 
  /*
-    ostream& operator <<  (const ostream&,const dcompressed_triplet& );
-    istream& operator >>  (const istream&,const dcompressed_triplet& );
-    ostream& operator <<  (const ostream&,const dvar_compressed_triplet& );
-    istream& operator >>  (const istream&,const dvar_compressed_triplet& );
+  ostream& operator <<  (const ostream&,const dcompressed_triplet& );
+  istream& operator >>  (const istream&,const dcompressed_triplet& );
+  ostream& operator <<  (const ostream&,const dvar_compressed_triplet& );
+  istream& operator >>  (const istream&,const dvar_compressed_triplet& );
   */
+  dvector operator * (const dcompressed_triplet& M,const dvector& v);
 
-typedef struct cs_symbolic css;
+  typedef struct cs_symbolic css;
 
 /**
  * Description not yet available.
  * \param
  */
-class hs_symbolic		// Info for symbolic cholesky
-{
- public:
-   int n;			// Dimension of underlying pos. def. matrix
-   int m;			// Dimension of underlying pos. def. matrix
-   ivector pinv;		// inverse row perm. for QR, fill red. perm for Chol 
-   ivector parent;		// elimination tree for Cholesky and QR 
-   ivector cp;			// column pointers for Cholesky, row counts for QR 
-   double lnz;			// # entries in L for LU or Cholesky; in V for QR 
-   hs_symbolic(int, css *);
-   hs_symbolic(int n, dmatrix & T, int order);
-   hs_symbolic(const dcompressed_triplet & T, int order);
+ class hs_symbolic     // Info for symbolic cholesky
+  {
+   public:
+      int n ;   // Dimension of underlying pos. def. matrix
+      int m ;   // Dimension of underlying pos. def. matrix
+      ivector pinv ;    // inverse row perm. for QR, fill red. perm for Chol 
+      ivector parent ;  // elimination tree for Cholesky and QR 
+      ivector cp ;      // column pointers for Cholesky, row counts for QR 
+      double lnz ;      // # entries in L for LU or Cholesky; in V for QR 
+      hs_symbolic(int,  css *);
+      hs_symbolic(int n, dmatrix &T, int order);
+      hs_symbolic(const dcompressed_triplet &T, int order);
 
-   hs_symbolic(const dvar_compressed_triplet & T, int order);
-   int is_null();
-   int cmp(hs_symbolic & S);
-   hs_symbolic(void);
-};
+      hs_symbolic(const dvar_compressed_triplet &T, int order);
+      int is_null();
+      int cmp(hs_symbolic &S);
+      hs_symbolic(void);
+  };
 
-class hs_smatrix;
-class dvar_hs_smatrix;
+  class hs_smatrix;
+  class dvar_hs_smatrix;
 
 
-hs_smatrix *return_choleski_decomp(dcompressed_triplet & st);
+  hs_smatrix * return_choleski_decomp(dcompressed_triplet & st);
 
-dvector return_choleski_factor_solve(hs_smatrix * PL, dvector & eps);
+  dvector return_choleski_factor_solve(hs_smatrix * PL,dvector& eps);
 
-dvar_vector return_choleski_factor_solve(dvar_hs_smatrix * PL,
-					 dvector & eps);
+  dvar_vector return_choleski_factor_solve(dvar_hs_smatrix * PL,dvector& eps);
 
-dvector return_choleski_decomp_solve(dcompressed_triplet & dct,
-				     dvector & eps);
+  dvector return_choleski_decomp_solve(const dcompressed_triplet & dct,
+    const dvector& eps);
 
-dvar_hs_smatrix *return_choleski_decomp(dvar_compressed_triplet & st);
+  dvar_hs_smatrix * return_choleski_decomp(dvar_compressed_triplet & st);
 
-int allocated(const dcompressed_triplet & t);
-int allocated(const dvar_compressed_triplet & t);
+  int allocated(const dcompressed_triplet & t);
+  int allocated(const dvar_compressed_triplet & t);
 
-dvector solve(const dcompressed_triplet &, const dmatrix &,
-	      const dvector &);
-dvector solve(const dcompressed_triplet &, const dvector &,
-	      const hs_symbolic &, int &ierr);
-dvector solve(const dcompressed_triplet &, const dvector &,
-	      const hs_symbolic &);
-dvector solve(const dcompressed_triplet &, const dmatrix &,
-	      const dvector &, const hs_symbolic &);
-double ln_det(const dcompressed_triplet &);
-double ln_det(const dcompressed_triplet &, const hs_symbolic &);
-double ln_det(const dcompressed_triplet &, int &ierr);
-dvariable ln_det(const dvar_compressed_triplet &, int &ierr);
+  dvector solve(const dcompressed_triplet& ,const dmatrix & ,const dvector &);
+  dvector solve(const dcompressed_triplet& ,const dvector &,const hs_symbolic&,
+    int& ierr);
 
-dvar_vector return_choleski_factor_solve(dvar_hs_smatrix * PL,
-					 dvector & eps);
-void save_ad_pointer(void *);
-void *restore_ad_pointer(void);
+  dvector solve(const dcompressed_triplet& ,const dvector &);
 
-class laplace_approximation_calculator;
+  dvector solve(const dcompressed_triplet& ,const dvector &,const hs_symbolic&);
+  dvector solve(const dcompressed_triplet&,const dmatrix& ,const dvector &,const hs_symbolic&);
+  double ln_det(const dcompressed_triplet&);
+  double ln_det(const dcompressed_triplet&,const hs_symbolic&);
+  double ln_det(const dcompressed_triplet&,int& ierr);
+  dvariable ln_det(const dvar_compressed_triplet&,int&ierr);
 
-dvariable ln_det(dvar_compressed_triplet &, hs_symbolic &,
-		 laplace_approximation_calculator *);
+  dvar_vector return_choleski_factor_solve(dvar_hs_smatrix * PL,dvector& eps);
+  void save_ad_pointer(void *);
+  void * restore_ad_pointer(void);
 
-dvariable ln_det(dvar_compressed_triplet &);
-dvariable ln_det(dvar_compressed_triplet &, hs_symbolic &);
-dvariable ln_det(dvar_compressed_triplet &, hs_symbolic &,
-		 dcompressed_triplet &);
+  class laplace_approximation_calculator;
 
-dmatrix make_dmatrix(dcompressed_triplet & M);
-int norm2(const ivector &);
-int sumsq(const ivector & v);
+  dvariable ln_det(dvar_compressed_triplet&,hs_symbolic&,
+    laplace_approximation_calculator *);
 
-#endif//#ifndef FVAR_HPP
+  dvariable ln_det(dvar_compressed_triplet&);
+  dvariable ln_det(dvar_compressed_triplet&,hs_symbolic&);
+  dvariable ln_det(dvar_compressed_triplet&,hs_symbolic&,
+    dcompressed_triplet&);
+
+  dmatrix make_dmatrix(dcompressed_triplet& M);
+  dmatrix make_sdmatrix(dcompressed_triplet& M);
+  dvar_matrix make_sdvar_matrix(dvar_compressed_triplet& M);
+
+  int norm2(const ivector&);
+  int sumsq(const ivector& v);
+
+  void add_slave_suffix(const adstring& _tmpstring);
+
+#endif //#ifndef FVAR_HPP
Index: linad99/fvarcompressed.cpp
===================================================================
--- linad99/fvarcompressed.cpp	(revision 0)
+++ linad99/fvarcompressed.cpp	(working copy)
@@ -0,0 +1,71 @@
+/*
+ * $Id: dvector.cpp 422 2012-04-12 23:02:36Z johnoel $
+ *
+ * Author: David Fournier
+ * Copyright (c) 2008-2011 Regents of the University of California 
+ */
+/**
+ * \file
+ * Description not yet available.
+ */
+#include "fvar.hpp"
+
+  // this is for a symmetrixc matrix
+  dvar_vector operator * (const dvar_compressed_triplet& _M,
+    const dvar_vector& _v)
+  {
+    ADUNCONST(dvar_compressed_triplet,M)
+    ADUNCONST(dvar_vector,v)
+    
+    if (v.indexmin()!=1 ||
+         M.get_m() !=v.indexmax() )
+    {
+      cerr << "Indices do not match in "
+        " operator * (const dcompressed_triplet& _M,const dvector& _v)"
+        << endl;
+      ad_exit(1);
+    }
+    imatrix coords= M.get_coords();
+    dvar_vector& x= M.get_x();
+    dvar_vector tmp(1,v.indexmax());
+    int mmin=x.indexmin();
+    int mmax=x.indexmax();
+    tmp.initialize();
+    for (int i=mmin;i<=mmax;i++)
+    {
+      tmp(coords(1,i))+=x(i)*v(coords(2,i));
+      if(coords(1,i)!=coords(2,i))
+        tmp(coords(2,i))+=x(i)*v(coords(1,i));
+    }
+     
+    return tmp;
+  } 
+    
+  dvar_compressed_triplet::dvar_compressed_triplet(void)
+  {
+    n=-1;
+    m=-1;
+  }
+
+   dvar_compressed_triplet & dvar_compressed_triplet::operator = 
+     (const dvar_compressed_triplet& _M)
+   {
+     ADUNCONST(dvar_compressed_triplet,M)
+     n=M.get_n();
+     m=M.get_m();
+     coords=M.get_coords();
+     x=M.get_x();
+     return *this;
+   }
+
+   dvar_compressed_triplet & dvar_compressed_triplet::operator = 
+     (const dcompressed_triplet& _M)
+   {
+     ADUNCONST(dcompressed_triplet,M)
+     n=M.get_n();
+     m=M.get_m();
+     coords=M.get_coords();
+     x=M.get_x();
+     return *this;
+   }
+
Index: linad99/gradstak.cpp
===================================================================
--- linad99/gradstak.cpp	(revision 682)
+++ linad99/gradstak.cpp	(working copy)
@@ -91,6 +91,13 @@
 #include <string.h>
 #include <time.h>
 
+#if defined(USE_ADMPI)
+  void add_slave_suffix(const adstring& tmp);
+  void report_file_opening(const adstring& tmp);
+#endif
+
+
+
   char lastchar(char *);
 
   char ad_random_part[6]="tmp";
@@ -194,6 +201,9 @@
     {
       sprintf(&gradfile_name1[0],"gradfil1.%s",ad_random_part);
     }
+    adstring tmps=gradfile_name1;
+    add_slave_suffix(tmps);
+    strncpy(gradfile_name1,tmps,100);
 
     path = getenv("ADTMP1"); // NULL if not defined
 #if defined(USE_ADPVM)
@@ -241,6 +251,14 @@
       sprintf(&var_store_file_name[0],"varssave.%s",
         ad_random_part);
     }
+    adstring tmps2=gradfile_name2;
+    add_slave_suffix(tmps2);
+    strncpy(gradfile_name2,tmps2,100);
+
+    adstring tmps3=var_store_file_name;
+    add_slave_suffix(tmps3);
+    strncpy(var_store_file_name,tmps3,100);
+
     create_gradfile();
 
     strcpy(gradfile_name, gradfile_name1);
Index: linad99/gradstrc.cpp
===================================================================
--- linad99/gradstrc.cpp	(revision 682)
+++ linad99/gradstrc.cpp	(working copy)
@@ -68,31 +68,31 @@
 // *************************************************************
 // *************************************************************
 int ctlc_flag = 0;
-int gradient_structure::Hybrid_bounded_flag=0;
-DF_FILE * gradient_structure::fp=NULL;
-char gradient_structure::cmpdif_file_name[61];
-//char gradient_structure::var_store_file_name[61];
+__ADMBTHREAD__ int gradient_structure::Hybrid_bounded_flag=0;
+__ADMBTHREAD__ DF_FILE * gradient_structure::fp=NULL;
+__ADMBTHREAD__ char gradient_structure::cmpdif_file_name[101];
+//char gradient_structure::var_store_file_name[101];
 int gradient_structure::NUM_RETURN_ARRAYS = 25;
-double * gradient_structure::hessian_ptr=NULL;
+__ADMBTHREAD__ double * gradient_structure::hessian_ptr=NULL;
 int gradient_structure::NUM_DEPENDENT_VARIABLES = 2000;
 #if (defined(NO_DERIVS))
   int gradient_structure::no_derivatives = 0;
 #endif
-long int gradient_structure::max_last_offset = 0;
-long int gradient_structure::NVAR = 0;
-long int gradient_structure::TOTAL_BYTES = 0;
-long int gradient_structure::PREVIOUS_TOTAL_BYTES = 0;
+__ADMBTHREAD__ long int gradient_structure::max_last_offset = 0;
+__ADMBTHREAD__ long int gradient_structure::NVAR = 0;
+__ADMBTHREAD__ long int gradient_structure::TOTAL_BYTES = 0;
+__ADMBTHREAD__ long int gradient_structure::PREVIOUS_TOTAL_BYTES = 0;
 long int gradient_structure::USE_FOR_HESSIAN = 0;
-dvariable** gradient_structure::RETURN_ARRAYS = NULL;
-int gradient_structure::RETURN_ARRAYS_PTR;
-dvariable ** gradient_structure::RETURN_PTR_CONTAINER = NULL;
-int gradient_structure::RETURN_ARRAYS_SIZE = 70;
-int gradient_structure::instances = 0;
+__ADMBTHREAD__ dvariable** gradient_structure::RETURN_ARRAYS = NULL;
+__ADMBTHREAD__ int gradient_structure::RETURN_ARRAYS_PTR;
+__ADMBTHREAD__ dvariable ** gradient_structure::RETURN_PTR_CONTAINER = NULL;
+__ADMBTHREAD__ int gradient_structure::RETURN_ARRAYS_SIZE = 70;
+__ADMBTHREAD__ int gradient_structure::instances = 0;
 //int gradient_structure::RETURN_INDEX = 0;
 //dvariable * gradient_structure::FRETURN = NULL;
-dvariable * gradient_structure::MAX_RETURN = NULL;
-dvariable * gradient_structure::MIN_RETURN = NULL;
-dvariable * gradient_structure::RETURN_PTR = NULL;
+__ADMBTHREAD__ dvariable * gradient_structure::MAX_RETURN = NULL;
+__ADMBTHREAD__ dvariable * gradient_structure::MIN_RETURN = NULL;
+__ADMBTHREAD__ dvariable * gradient_structure::RETURN_PTR = NULL;
 #ifdef __BORLANDC__
 long int gradient_structure::GRADSTACK_BUFFER_SIZE = 4000000L;
 long int gradient_structure::CMPDIF_BUFFER_SIZE=140000000L;
@@ -101,7 +101,7 @@
 long long int gradient_structure::CMPDIF_BUFFER_SIZE=140000000L;
 #endif
 
-dependent_variables_information * gradient_structure::DEPVARS_INFO=NULL;
+__ADMBTHREAD__ dependent_variables_information * gradient_structure::DEPVARS_INFO=NULL;
 
 int gradient_structure::save_var_flag=0;
 int gradient_structure::save_var_file_flag=0;
@@ -110,13 +110,13 @@
 //int gradient_structure::_GRADFILE_PTR2 = NULL; // should be int gradfile_handle;
 //int gradient_structure::_VARSSAV_PTR = 0; // should be int gradfile_handle;
 
-unsigned int gradient_structure::MAX_NVAR_OFFSET = 5000;
-unsigned long gradient_structure::ARRAY_MEMBLOCK_SIZE = 0L; //js
-dlist * gradient_structure::GRAD_LIST;
-grad_stack * gradient_structure::GRAD_STACK1;
-indvar_offset_list * gradient_structure::INDVAR_LIST = NULL;
-arr_list * gradient_structure::ARR_LIST1 = NULL;
-arr_list * gradient_structure::ARR_FREE_LIST1 = NULL;
+__ADMBTHREAD__ unsigned int gradient_structure::MAX_NVAR_OFFSET = 5000;
+__ADMBTHREAD__ unsigned long gradient_structure::ARRAY_MEMBLOCK_SIZE = 0L; //js
+__ADMBTHREAD__ dlist * gradient_structure::GRAD_LIST;
+__ADMBTHREAD__ grad_stack * gradient_structure::GRAD_STACK1;
+__ADMBTHREAD__ indvar_offset_list * gradient_structure::INDVAR_LIST = NULL;
+__ADMBTHREAD__ arr_list * gradient_structure::ARR_LIST1 = NULL;
+__ADMBTHREAD__ arr_list * gradient_structure::ARR_FREE_LIST1 = NULL;
 int gradient_structure::MAX_DLINKS = 5000;
 
 // note: ARRAY_MEMBLOCK stuff is set by tpl2cpp for historical reasons
@@ -124,10 +124,13 @@
 //       - Ian Taylor 5/3/2012
 
 //unsigned long int gradient_structure::ARRAY_MEMBLOCK_BASE = 0L;
-humungous_pointer gradient_structure::ARRAY_MEMBLOCK_BASE;
-humungous_pointer gradient_structure::ARRAY_MEMBLOCK_BASEA;
-humungous_pointer gradient_structure::ARRAY_MEMBLOCK_SAVE;
-double * gradient_structure::variables_save=NULL;
+//humungous_pointer gradient_structure::ARRAY_MEMBLOCK_BASE;
+//humungous_pointer gradient_structure::ARRAY_MEMBLOCK_BASEA;
+//humungous_pointer gradient_structure::ARRAY_MEMBLOCK_SAVE;
+__ADMBTHREAD__ char * gradient_structure::ARRAY_MEMBLOCK_BASE;
+__ADMBTHREAD__ char * gradient_structure::ARRAY_MEMBLOCK_BASEA;
+__ADMBTHREAD__ char * gradient_structure::ARRAY_MEMBLOCK_SAVE;
+__ADMBTHREAD__ double * gradient_structure::variables_save=NULL;
 void * farptr_norm(void *);
 long int farptr_tolong(void *) ;
 void memory_allocate_error(const char * s, void * ptr);
@@ -395,9 +398,9 @@
 
 //#if DOS386==1
 #if defined(DOS386) || defined (__MSVC32__) || defined (__WAT32__)
-   if ( (temp_ptr = (void *) malloc(ARRAY_MEMBLOCK_SIZE )) == 0)
+  if ( (temp_ptr = (void *) malloc(ARRAY_MEMBLOCK_SIZE)) == 0)
 #else
-   if ( (temp_ptr = farmalloc(ARRAY_MEMBLOCK_SIZE) ) == 0)
+  if ( (temp_ptr = farmalloc(ARRAY_MEMBLOCK_SIZE) ) == 0)
 #endif
    {
      cerr << "insufficient memory to allocate space for ARRAY_MEMBLOCKa\n";
@@ -412,17 +415,17 @@
    }
  */
 
-   ARRAY_MEMBLOCK_BASE = temp_ptr;
+   ARRAY_MEMBLOCK_BASE = (char*)temp_ptr;
   
    //cout << (void*) ARRAY_MEMBLOCK_BASE.ptr  << "   ";
    //cout << (int) ARRAY_MEMBLOCK_BASE.ptr  << endl;
 #if defined(__x86_64)
-   intptr_t adjustment=(8-((intptr_t)ARRAY_MEMBLOCK_BASE.ptr)%8)%8;
+   //intptr_t adjustment=(8-((intptr_t)ARRAY_MEMBLOCK_BASE.ptr)%8)%8;
 #else
-   int adjustment=(8-((int) ARRAY_MEMBLOCK_BASE.ptr)%8)%8;
+   //int adjustment=(8-((int) ARRAY_MEMBLOCK_BASE.ptr)%8)%8;
 #endif
    //cout << ((int) ARRAY_MEMBLOCK_BASE.ptr)%8  << endl;
-   ARRAY_MEMBLOCK_BASE.adjust(adjustment);
+   //ARRAY_MEMBLOCK_BASE.adjust(adjustment);
    //cout << ((int) ARRAY_MEMBLOCK_BASE.ptr)%8  << endl;
   
    if (GRAD_STACK1 != NULL)
@@ -624,7 +627,9 @@
    }
    else
    {
-     ARRAY_MEMBLOCK_BASE.free();
+     //ARRAY_MEMBLOCK_BASE.free();
+     free(ARRAY_MEMBLOCK_BASE);
+     ARRAY_MEMBLOCK_BASE=0;
    }
 
 
Index: linad99/objects.lst
===================================================================
--- linad99/objects.lst	(revision 682)
+++ linad99/objects.lst	(working copy)
@@ -495,7 +495,12 @@
 orthpoly.obj \
 makesub.obj \
 fvar_a49.obj \
-adpvm2.obj 
+adpvm2.obj \
+dcompressed.obj \
+fvarcompressed.obj \
+eigen_dmat.obj \
+eigen_dvar.obj \
+fvar_m38.obj
 OBJ4= \
 manip.obj \
 conjprod.obj 
Index: linad99/ranfill.cpp
===================================================================
--- linad99/ranfill.cpp	(revision 682)
+++ linad99/ranfill.cpp	(working copy)
@@ -53,6 +53,8 @@
     \n\n The implementation of this algorithm was inspired by
     "Numerical Recipes in C", 2nd edition,
     Press, Teukolsky, Vetterling, Flannery, chapter 7
+
+    \deprecated Scheduled for replacement by 2010.
 */
 double auto_rand(long int& idum, int reset)
 {
Index: linad99/sedcmd
===================================================================
--- linad99/sedcmd	(revision 0)
+++ linad99/sedcmd	(working copy)
@@ -0,0 +1,7 @@
+s/_CONST/const/g
+s/prevariable&/double/g
+s/prevariable &/double/g
+s/const double/double/g
+s/df1_two_variable/double/g
+s/double &/double/g
+s/double&/double/g
Index: linad99/sgradclc.cpp
===================================================================
--- linad99/sgradclc.cpp	(revision 682)
+++ linad99/sgradclc.cpp	(working copy)
@@ -180,7 +180,8 @@
      #endif
    }
 
-    * gradient_structure::GRAD_STACK1->ptr->dep_addr  = 1;
+    if (nvar>0)
+      * gradient_structure::GRAD_STACK1->ptr->dep_addr  = 1;
     zptr = gradient_structure::GRAD_STACK1->ptr->dep_addr;
 
 //double z;
@@ -301,7 +302,8 @@
   }
   else
   {
-     humungous_pointer src = ARRAY_MEMBLOCK_BASE;
+     char * src = ARRAY_MEMBLOCK_BASE;
+     //humungous_pointer src = ARRAY_MEMBLOCK_BASE;
      lseek(gradient_structure::GRAD_STACK1->_VARSSAV_PTR,0L,SEEK_SET);
      #if defined(DOS386)
      //#if DOS386==1
@@ -345,8 +347,10 @@
      unsigned long max_move=50000;
 
      long int left_to_move=bytes_needed;
-     humungous_pointer src = ARRAY_MEMBLOCK_SAVE;
-     humungous_pointer dest = ARRAY_MEMBLOCK_BASE;
+     //humungous_pointer src = ARRAY_MEMBLOCK_SAVE;
+     //humungous_pointer dest = ARRAY_MEMBLOCK_BASE;
+     char *  src = ARRAY_MEMBLOCK_SAVE;
+     char * dest = ARRAY_MEMBLOCK_BASE;
      while(left_to_move > max_move)
      {
        memcpy((char*)dest,(char*)src,max_move);
@@ -356,11 +360,13 @@
      }
      memcpy((char*)dest,(char*)src,left_to_move);
     #endif
-    ARRAY_MEMBLOCK_SAVE.free();
+    free(ARRAY_MEMBLOCK_SAVE);
+    ARRAY_MEMBLOCK_SAVE=0;
   }
   else
   {
-    humungous_pointer dest = ARRAY_MEMBLOCK_BASE;
+    //humungous_pointer dest = ARRAY_MEMBLOCK_BASE;
+    char * dest = ARRAY_MEMBLOCK_BASE;
     lseek(gradient_structure::GRAD_STACK1->_VARSSAV_PTR,0L,SEEK_SET);
     #if defined(DOS386)
     // #if DOS386==1
Index: linad99/vbetacf.cpp
===================================================================
--- linad99/vbetacf.cpp	(revision 682)
+++ linad99/vbetacf.cpp	(working copy)
@@ -21,7 +21,7 @@
     "Numerical Recipes in C", 2nd edition,
     Press, Teukolsky, Vetterling, Flannery, chapter 2
 */
-dvariable betacf(_CONST dvariable& _a,_CONST dvariable& _b,_CONST dvariable& _x,
+dvariable betacf(const dvariable& _a, const dvariable& _b, const dvariable& _x,
   int MAXIT)
 {
   int m,m2;
Index: linad99/vbetai.cpp
===================================================================
--- linad99/vbetai.cpp	(revision 682)
+++ linad99/vbetai.cpp	(working copy)
@@ -7,6 +7,9 @@
 #include <fvar.hpp>
 #include <math.h>
 
+dvariable betacf(const dvariable& _a, const dvariable& _b, const dvariable& _x,
+  int MAXIT);
+
 /** Incomplete beta function for variable objects.
     \param a \f$a\f$
     \param b \f$b\f$
@@ -18,7 +21,7 @@
     "Numerical Recipes in C", 2nd edition,
     Press, Teukolsky, Vetterling, Flannery, chapter 2
 */
-dvariable betai(_CONST dvariable a,_CONST dvariable b,_CONST dvariable x,
+dvariable betai(const dvariable a, const dvariable b, const dvariable x,
   int maxit)
 {
   dvariable bt;
Index: linad99/vgamdev.cpp
===================================================================
--- linad99/vgamdev.cpp	(revision 682)
+++ linad99/vgamdev.cpp	(working copy)
@@ -1,8 +1,8 @@
-/*
-  $Id$
- 
-  Author: David Fournier
-  Copyright (c) 2008, 2009, 2010 Regents of the University of California 
+/**
+ * $Id$
+ *
+ * Author: David Fournier
+ * Copyright (c) 2008, 2009, 2010 Regents of the University of California 
  */
 #include <fvar.hpp>
 #define ITMAX 100
@@ -12,10 +12,6 @@
 static void gcf(double& gammcf,double a,double x,double &gln);
 static void gser(double& gamser,double a,double x,double& gln);
 
-/**
-  \file gamma functions for differentiable objects.
-*/
-
   dvariable gamma_deviate(const prevariable& _x,const prevariable& _a)
   {
     prevariable& x= (prevariable&)(_x);
@@ -51,6 +47,8 @@
     \n\n The implementation of this algorithm was inspired by
     "Numerical Recipes in C", 2nd edition,
     Press, Teukolsky, Vetterling, Flannery, chapter 6
+
+    \deprecated Scheduled for replacement by 2010.
 */
 static void gcf(double& gammcf,double a,double x,double &gln)
 {
@@ -84,6 +82,8 @@
     \n\n The implementation of this algorithm was inspired by
     "Numerical Recipes in C", 2nd edition,
     Press, Teukolsky, Vetterling, Flannery, chapter 6
+
+    \deprecated Scheduled for replacement by 2010.
 */
 static void gser(double& gamser,double a,double x,double& gln)
 {
@@ -176,7 +176,7 @@
   return vz;
 }
 
-#endif //#if defined(USE_LAPLACE)
+#endif
 
 #undef ITMAX
 #undef EPS
Index: linux.mak
===================================================================
--- linux.mak	(revision 682)
+++ linux.mak	(working copy)
@@ -37,9 +37,9 @@
 endif
 
 ifdef DEBUG
-CXXFLAGS:=-c -g $(CXXFLAGS)
+CXXFLAGS:=-c -g -fpermissive $(CXXFLAGS)
 else
-CXXFLAGS:=-c -O3 $(CXXFLAGS)
+CXXFLAGS:=-c -O3 -fpermissive $(CXXFLAGS)
 endif
 
 dist:
@@ -117,4 +117,7 @@
 	@rm -f nh99/lex.yy.c
 	@rm -f df1b2-separable/lex.yy.c
 	@rm -f nh99/tpl2cpp
+	@rm -f nh99/tpl2cpp.c
 	@rm -f df1b2-separable/tpl2rem
+	@rm -f df1b2-separable/tpl2rem.c
+
Index: nh99/admodel.h
===================================================================
--- nh99/admodel.h	(revision 682)
+++ nh99/admodel.h	(working copy)
@@ -1696,6 +1696,8 @@
  * Description not yet available.
  * \param
  */
+ class sparse_qp_info;
+
 class function_minimizer
 {
 public:
@@ -1709,12 +1711,14 @@
 #if defined(USE_LAPLACE)
   static int inner_opt_flag;
   static int inner_opt(void);
+  sparse_qp_info * spqp;
   laplace_approximation_calculator * lapprox;
   dvector * multinomial_weights;
   void set_multinomial_weights(dvector&d);
   //init_df1b2vector* py;
   virtual void AD_uf_inner(void);
   virtual void AD_uf_outer(void);
+  virtual void get_sparse_stuff(void * triplet_information,int jobno){;}
   virtual void user_function(void);
   void pre_user_function(void);
   //void df1b2_pre_user_function(void);
@@ -2817,4 +2821,12 @@
 #include "param_init_bounded_number_matrix.h"
 
 extern int to_make_sure_admodel_cpp_gets_linked;
+class sparse_qp_info
+{
+public:
+  int n;
+  imatrix compm;
+  sparse_qp_info(void) {n=10;}
+  void make_compressed_triplet_info(imatrix & im);
+};
 #endif
Index: nh99/mod_hess.cpp
===================================================================
--- nh99/mod_hess.cpp	(revision 682)
+++ nh99/mod_hess.cpp	(working copy)
@@ -476,6 +476,12 @@
   gradcalc(0,ggg);
   gradient_structure::set_YES_DERIVATIVES();
   initial_params::restore_start_phase();
+#if defined(USE_LAPLACE)
+  if (lapprox  && lapprox->no_re_ders_flag)
+  {
+    initial_params::set_inactive_only_random_effects();
+  }
+#endif
   int nvar=initial_params::nvarcalc(); // get the number of active parameters
   int ndvar=stddev_params::num_stddev_calc();
   independent_variables x(1,nvar);
@@ -604,13 +610,10 @@
   {
     ofstream ofs3((char*)(ad_comm::adprogram_name + adstring(".eva")));
     {
-      dvector se=eigenvalues(hess);
+      dvector se=sort(eigenvalues(hess));
       ofs3 << setshowpoint() << setw(14) << setprecision(10)
-	 << "unsorted:\t" << se << endl;
-     se=sort(se);
-     ofs3 << setshowpoint() << setw(14) << setprecision(10)
-     << "sorted:\t" << se << endl;
-     if (se(se.indexmin())<=0.0)
+	 << se << endl;
+      if (se(se.indexmin())<=0.0)
       {
 #if defined(USE_LAPLACE)
         negative_eigenvalue_flag=1;
Index: nh99/mod_pmin.cpp
===================================================================
--- nh99/mod_pmin.cpp	(revision 682)
+++ nh99/mod_pmin.cpp	(working copy)
@@ -17,6 +17,8 @@
 void report_onesided_confidence_limits(const ofstream& ofs3,int numsig_levels,
   dvector& siglevel, const dvector& left_bd, const dvector& right_bd,int ip);
 
+void get_ee(const dmatrix& hh, const ofstream& of5); 
+
 ofstream of5("eigv.rpt");
 
 dmatrix trans(const dvector& x)
@@ -403,7 +405,6 @@
 #endif
   }
 
-/*
 void get_ee(const dmatrix& hh, const ofstream& _of5) 
 {
   ofstream& of5= (ofstream&) _of5; 
@@ -419,4 +420,3 @@
     of5 << l(i) << "  " << ll(i) << endl;
   }
 }
-*/
Index: nh99/mod_sd.cpp
===================================================================
--- nh99/mod_sd.cpp	(revision 682)
+++ nh99/mod_sd.cpp	(working copy)
@@ -44,6 +44,12 @@
   initial_params::xinit(x); // get the number of active parameters
 
   initial_params::restore_start_phase();
+#if defined(USE_LAPLACE)
+  if (lapprox  && lapprox->no_re_ders_flag)
+  {
+    initial_params::set_inactive_only_random_effects();
+  }
+#endif
   int nvar1=initial_params::nvarcalc(); // get the number of active parameters
   int num_sdrep_types=stddev_params::num_stddev_params +
     initial_params::num_active_calc();
@@ -116,6 +122,12 @@
   int check=initial_params::stddev_scale(scale,x);
   double lndet=-ln_det(S,sgn)-2.0*sum(log(scale));
   initial_params::set_active_random_effects(); 
+#if defined(USE_LAPLACE)
+  if (lapprox  && lapprox->no_re_ders_flag)
+  {
+    initial_params::set_inactive_only_random_effects();
+  }
+#endif
   //int nvar1=initial_params::nvarcalc(); 
   dvector diag(1,nvar1+ndvar);
   dvector tmp(1,nvar1+ndvar);
Index: nh99/model7.cpp
===================================================================
--- nh99/model7.cpp	(revision 682)
+++ nh99/model7.cpp	(working copy)
@@ -229,6 +229,7 @@
       (*ad_printf)( " -hbf            set the hybrid bounded flag for bounded parameters\n");
       (*ad_printf)( " -hyeps          mean step size for hybrid Monte Carlo\n");
       (*ad_printf)( " -hynstep        number of steps for hybrid Monte Carlo\n");
+      (*ad_printf)( " -noreders       turn off re's for derivative calcs for std devs\n");
       (*ad_printf)( " -noinit         do not initialize RE before inner optimization\n");
       (*ad_printf)( " -ndi N          set maximum number of separable calls\n");
       (*ad_printf)( " -ndb N          set number of blocks for RE derivatives (reduce temp file size)\n");
@@ -562,3 +563,44 @@
   }
 #endif
 }
+#if defined(USE_ADMPI)
+void add_slave_suffix(const adstring& _tmpstring)
+{
+  ADUNCONST(adstring,tmpstring)
+  if (ad_comm::mpi_manager)
+  {
+    if (ad_comm::mpi_manager->is_slave())
+    {
+      tmpstring += "_";
+      tmpstring += str(ad_comm::mpi_manager->get_slave_number());
+       cout << "In slave " << tmpstring << endl;
+    }
+    else
+    {
+      tmpstring += "_master";
+       cout << "In master " << tmpstring << endl;
+    }
+  }
+}
+
+#else if defined(USE_PTHREADS)
+
+void add_slave_suffix(const adstring& _tmpstring)
+{
+  ADUNCONST(adstring,tmpstring)
+  if (ad_comm::pthreads_manager)
+  {
+    if (ad_comm::pthreads_manager->is_slave())
+    {
+      tmpstring += "_";
+      tmpstring += str(ad_comm::pthreads_manager->get_slave_number());
+       cout << "In slave " << tmpstring << endl;
+    }
+    else
+    {
+      tmpstring += "_master";
+       cout << "In master " << tmpstring << endl;
+    }
+  }
+}
+#endif
Index: nh99/modspmin.cpp
===================================================================
--- nh99/modspmin.cpp	(revision 682)
+++ nh99/modspmin.cpp	(working copy)
@@ -641,6 +641,10 @@
       }
     }
     while(spminflag || repeatminflag);
+
+    // moved quadratic prior cleanupo to here ?
+    quadratic_prior::cleanup(); 
+    df1b2quadratic_prior::cleanup(); 
   }
 
 
Index: sparse/hs_sparse.cpp
===================================================================
--- sparse/hs_sparse.cpp	(revision 682)
+++ sparse/hs_sparse.cpp	(working copy)
@@ -245,6 +245,20 @@
   return tmp;
 }
 
+dvar_matrix make_sdvar_matrix(dvar_compressed_triplet& M,int n,int m)
+{
+  dvar_matrix tmp(1,n,1,m);
+  int nz = M.indexmax()- M.indexmin() + 1;
+  for (int i=1;i<=nz;i++)
+  {
+    tmp(M(1,i),M(2,i))=M(i);
+    if (M(1,i) != M(2,i))
+    {
+      tmp(M(2,i),M(1,i))=M(i);
+    }
+  }
+  return tmp;
+}
 
 hs_smatrix::hs_smatrix(int _n, XCONST dcompressed_triplet &_M)         
 {
@@ -281,7 +295,10 @@
     for (k = 0 ; k < nz ; k++)
       lower_tri += Ti[k]>Tj[k];
     if(lower_tri) 
+    {
       cout << "hs_smatrix::hs_smatrix: M must be upper triangular" << endl;
+      ad_exit(1);
+    }
 
     // Matrix in compressed format 
     p.allocate(0,n);
@@ -2565,8 +2582,12 @@
 {
   allocate(mmin,mmax,_n,_m);
 }
+dcompressed_triplet::dcompressed_triplet(void)
+{
+  n=0;
+  m=-1;
+}
 
-
 void dvar_compressed_triplet::allocate(int mmin,int mmax,int _n,int _m)
 {
   n=_n;
@@ -2809,6 +2830,33 @@
     return x;
   }
   
+  dvector solve(const dcompressed_triplet & _st,const dvector& _grad)
+  {
+    ADUNCONST(dcompressed_triplet,st)
+    ADUNCONST(dvector,grad)
+    int n=st.get_n();
+    //int n=Hess.indexmax();
+    // fill up compressed triplet with nonzero entries of the Hessian
+    hs_symbolic S(st,1);         // Fill reducing row-col permutation                 
+  
+    hs_smatrix HS(n,st);  // Convert triplet to working format
+  
+    hs_smatrix L(S);              // Allocates cholesky factor
+  
+    ivector nxcount;
+    chol(HS,S,L);                  // Does numeric factorization
+  
+    dvector x(0,n-1);
+    grad.shift(0);
+    x = cs_ipvec(S.pinv, grad);
+    grad.shift(1);
+    x = cs_lsolve(L,x);
+    x = cs_ltsolve(L,x);
+    x = cs_pvec(S.pinv,x);
+    x.shift(1);
+    return x;
+  }
+  
   dvector solve(const dcompressed_triplet & _st,const dvector& _grad,const hs_symbolic& S,int& ierr)
   {
     ADUNCONST(dcompressed_triplet,st)
@@ -2857,7 +2905,11 @@
 {
   int n=VM.get_n();
   dvar_hs_smatrix H(n,VM);  
-  hs_symbolic S(VM,1);         // Fill reducing row-col permutation  
+  cout << "Needs fixing ??? " << endl;
+  //sleep(1);
+  // what is difference between 0 and 1
+  hs_symbolic S(VM,0);         // Fill reducing row-col permutation  
+  //hs_symbolic S(VM,1);         // Fill reducing row-col permutation  
   dvar_hs_smatrix L(S);              // Allocates cholesky factor
   int ierr=chol(H,S,L);                  // Does numeric factorization
   if (ierr==0)
@@ -3048,17 +3100,16 @@
 
 static void dfcholeski_sparse(void);
 
-int varchol(XCONST dvar_hs_smatrix &AA, XCONST hs_symbolic &T,dvar_hs_smatrix &LL,
- dcompressed_triplet & sparse_triplet2)
- //laplace_approximation_calculator * lapprox)
+int varchol(XCONST dvar_hs_smatrix &AA, XCONST hs_symbolic &T,
+ dvar_hs_smatrix &LL,dcompressed_triplet & sparse_triplet2)
 {
   RETURN_ARRAYS_INCREMENT(); //Need this statement because the function
-  //ADUNCONST(hs_symbolic,S)
-  //ADUNCONST(dvar_hs_smatrix,L)
-  //ADUNCONST(dvar_hs_smatrix,A)
-    hs_symbolic& S = (hs_symbolic&)T;
-    dvar_hs_smatrix& A = (dvar_hs_smatrix&)AA;
-    dvar_hs_smatrix& L = (dvar_hs_smatrix&)LL;
+
+  dvar_vector tmp1=AA.x;
+  dvector tmp2=sparse_triplet2.get_x();
+  hs_symbolic& S = (hs_symbolic&)T;
+  dvar_hs_smatrix& A = (dvar_hs_smatrix&)AA;
+  dvar_hs_smatrix& L = (dvar_hs_smatrix&)LL;
   int icount=0;
   double lki;
   double d;
@@ -3676,6 +3727,43 @@
   }
   return dct;
 } 
+dcompressed_triplet::dcompressed_triplet (const dmatrix & M)
+{
+  int mmin=M.indexmin();
+  int mmax=M.indexmax();
+  int n=mmax-mmin+1;
+  int jmin=M(mmin).indexmin();
+  int jmax=M(mmax).indexmax();
+  int m=jmax-jmin+1;
+  int ii=0;
+  int i,j;
+  for (i=mmin;i<=mmax;i++)
+  {
+    int jmin=M(i).indexmin();
+    int jmax=M(i).indexmax();
+    for (j=jmin;j<=jmax;j++)
+    {
+      if (M(i,j) !=0) ii++;
+    }
+  }
+  allocate(1,ii,n,m);
+  ii=0;
+  for (i=mmin;i<=mmax;i++)
+  {
+    int jmin=M(i).indexmin();
+    int jmax=M(i).indexmax();
+    for (j=jmin;j<=jmax;j++)
+    {
+      if (M(i,j) !=0) 
+      {
+        ii++;
+        x(ii)=M(i,j);
+        coords(1,ii)=i;
+        coords(2,ii)=j;
+      }
+    }
+  }
+} 
 /*
 extern "C"  {
   void ad_boundf(int i)
Index: tools99/string1.cpp
===================================================================
--- tools99/string1.cpp	(revision 682)
+++ tools99/string1.cpp	(working copy)
@@ -7,7 +7,6 @@
 #include <fvar.hpp>
 #include <string.h>
 #include <stdlib.h>
-#include <safe_mem.h>
 #include "admb_messages.h"
 
 adstring adstring::operator()(int i, int j)
@@ -62,11 +61,11 @@
   {
     int sz = t.size ();
     shape->size() = t.size();
-    mem_free(++s);
+    free(++s);
   #if (defined __ZTC__) || (defined __NDPX__)
-    s =  (char*)mem_malloc(sz+1);
+    s =  (char*)malloc(sz+1);
   #else
-    s =  (unsigned char*)mem_malloc(sz+1);
+    s =  (unsigned char*)malloc(sz+1);
   #endif
     s--;
     int size = t.size();
@@ -90,8 +89,8 @@
 {
   int sz = strlen(t);
   shape->size() = strlen(t);
-  mem_free(++s);
-  s =  (unsigned char*)mem_malloc(sz+1);
+  free(++s);
+  s =  (unsigned char*)malloc(sz+1);
   strcpy((char*)(s),t);
   s--;
   adstring * tmp = (adstring *) this->next;
@@ -107,8 +106,8 @@
 {
   if (next==this)
   {
-    mem_free(shape);
-    mem_free(++s);
+    free(shape);
+    shape=0;
   }
 };
  
